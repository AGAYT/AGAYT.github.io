<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;agayt.github.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.json&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script>
<meta name="description" content="Redis从入门到精通">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis笔记">
<meta property="og:url" content="http://agayt.github.com/p/65035/index.html">
<meta property="og:site_name" content="阿甘的blog">
<meta property="og:description" content="Redis从入门到精通">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607111504594.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607113648442.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607115932817.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607132056492.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607163714604.png">
<meta property="og:image" content="c:/Users/86188/AppData/Roaming/Typora/typora-user-images/image-20220607163727221.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607174338373.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220608201645761.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609081252242.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609093731061.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609112029276.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609150836867.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609151616222.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609151917794.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609162606965.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609162849629.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609153138567.png">
<meta property="og:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609153341131.png">
<meta property="article:published_time" content="2022-06-09T08:35:08.000Z">
<meta property="article:modified_time" content="2022-06-09T08:38:59.338Z">
<meta property="article:author" content="AGA">
<meta property="article:tag" content="keyword">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607111504594.png">


<link rel="canonical" href="http://agayt.github.com/p/65035/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;agayt.github.com&#x2F;p&#x2F;65035&#x2F;&quot;,&quot;path&quot;:&quot;p&#x2F;65035&#x2F;&quot;,&quot;title&quot;:&quot;Redis笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Redis笔记 | 阿甘的blog</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
 
<script type="text/javascript" src="/js/nest.js"></script>


  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">阿甘的blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">走过路过不要错过</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">NoSQL数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NoSQL%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.</span> <span class="nav-text">NoSQL适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.</span> <span class="nav-text">Redis应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">常用数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">string类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">list类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">hash类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hash%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.1.</span> <span class="nav-text">hash类型数据操作的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">set类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zset%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.5.</span> <span class="nav-text">zset类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">新数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="nav-number">5.</span> <span class="nav-text">发布与订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E5%90%88Springboot"><span class="nav-number">6.</span> <span class="nav-text">整合Springboot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jedis"><span class="nav-number">6.1.</span> <span class="nav-text">jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jedis%E5%8D%95%E6%9C%BA%E4%BD%BF%E7%94%A8"><span class="nav-number">6.1.1.</span> <span class="nav-text">jedis单机使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">6.1.2.</span> <span class="nav-text">jedis连接池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lettuce"><span class="nav-number">6.2.</span> <span class="nav-text">lettuce</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lettuce%E5%8D%95%E6%9C%BA%E4%BD%BF%E7%94%A8"><span class="nav-number">6.2.1.</span> <span class="nav-text">lettuce单机使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lettuce%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">6.2.2.</span> <span class="nav-text">lettuce连接池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8"><span class="nav-number">6.2.3.</span> <span class="nav-text">集群使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">持久化方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Snapshot"><span class="nav-number">7.1.</span> <span class="nav-text">Snapshot</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">7.1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="nav-number">7.1.2.</span> <span class="nav-text">生成方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BGSAVE"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">BGSAVE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SAVE%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">7.1.2.2.</span> <span class="nav-text">SAVE（不推荐）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">7.1.2.3.</span> <span class="nav-text">服务器配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFshutdown"><span class="nav-number">7.1.2.4.</span> <span class="nav-text">客户端shutdown</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1"><span class="nav-number">7.1.3.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">7.1.4.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">7.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">7.2.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E9%A2%91%E7%8E%87"><span class="nav-number">7.2.2.</span> <span class="nav-text">追加频率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">7.2.3.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D"><span class="nav-number">7.2.4.</span> <span class="nav-text">修复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="nav-number">8.</span> <span class="nav-text">分布式缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">9.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">9.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%89%B9%E6%80%A7"><span class="nav-number">9.2.</span> <span class="nav-text">主从复制特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%86"><span class="nav-number">9.2.1.</span> <span class="nav-text">一主两仆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="nav-number">9.2.2.</span> <span class="nav-text">薪火相传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="nav-number">9.2.3.</span> <span class="nav-text">反客为主</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">9.3.</span> <span class="nav-text">哨兵机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">9.3.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">9.3.2.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="nav-number">10.</span> <span class="nav-text">Redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">10.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="nav-number">10.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA"><span class="nav-number">10.3.</span> <span class="nav-text">搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">10.4.</span> <span class="nav-text">集群常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%BB%86%E8%8A%82"><span class="nav-number">10.5.</span> <span class="nav-text">集群细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%90%88springboot"><span class="nav-number">10.6.</span> <span class="nav-text">整合springboot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86"><span class="nav-number">10.7.</span> <span class="nav-text">集群原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="nav-number">10.7.1.</span> <span class="nav-text">一致性哈希算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A7%BD-slot"><span class="nav-number">10.7.2.</span> <span class="nav-text">槽(slot)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8"><span class="nav-number">11.</span> <span class="nav-text">缓存异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">12.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">13.</span> <span class="nav-text"></span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">AGA</p>
  <div class="site-description" itemprop="description">hiahiahia</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://agayt.github.com/p/65035/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AGA">
      <meta itemprop="description" content="hiahiahia">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿甘的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-09 16:35:08 / 修改时间：16:38:59" itemprop="dateCreated datePublished" datetime="2022-06-09T16:35:08+08:00">2022-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">Redis从入门到精通</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607111504594.png" alt="image-20220607111504594"></p>
<h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Web1.0的时代，由于数据访问量有限，用高性能的单点服务器可以解决大部分问题。<br>Web2.0的时代的到来，使得用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。暴露了很多难以克服的问题,例如:.<br>①对数据库高并发读写的需求<br>②对海量数据的高效率存储和访问的需求<br>③对数据库的高可扩展性和高可用性的需求</p>
<p>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战,尤其是大数据应用难题<br>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。<br>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<p>技术发展</p>
<p>技术的分类<br>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、Git<br>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis<br>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p> 不遵循SQL标准。<br> 不支持ACID。（并不是说NoSQL事务）<br> 远超于SQL的性能。</p>
<p> 降低了CPU以及IO的压力</p>
<h3 id="NoSQL适用场景"><a href="#NoSQL适用场景" class="headerlink" title="NoSQL适用场景"></a>NoSQL适用场景</h3><p>对数据高并发的读写，海量数据的读写，对数据高可扩展性的。<br>需要事务支持，表之间有较为复杂的关系的场景不建议使用。<br>一句话:对于用不着sql的和用了sq也不行的情况，请考虑用NoSql</p>
<p>常见的NoSQL分类：</p>
<p>1.键值存储如Memcache，redis</p>
<p>2.文档存储如MongoDB</p>
<p>3.行式存储，列式存储如HBase，Cassandra</p>
<p>4.图关系存储</p>
<p>常用的如下</p>
<table>
<thead>
<tr>
<th>Memcache</th>
<th>很早出现的NoSql数据库 数据都在内存中，一般不持久化 支持简单的key-value模式，支持类型单一 一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td>Redis</td>
<td>几乎覆盖了Memcached的绝大部分功能 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。 一般是作为缓存数据库辅助持久化的数据库</td>
</tr>
<tr>
<td>MongoDB</td>
<td>高性能、开源、模式自由(schema free)的文档型数据库 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能 支持二进制数据及大型对象 可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</td>
</tr>
</tbody></table>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607113648442.png" alt="image-20220607113648442"></p>
<h3 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h3><p>1、redis用于控制数据库表主键id,为数据库表主键提供生成策略，保障数据库表的主键唯一性<br>2、redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作<br>3、redis应用于各种结构型和非结构型高热度数据访问加速<br>4、redis应用于购物车数据存储设计<br>5、redis应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计<br>6、redis应用于具有操作先后顺序的数据控制<br>7、redis应用于最新消息展示<br>8、redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等<br>9、redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索<br>10、redis应用于同类型不重复数据的合并、取交集操作<br>11、redis应用于同类型数据的快速去重<br>12、redis.应用于基于黑名单与白名单设定的服务控制<br>13、redis.应用于计数器组合排序功能对应的排名<br>14、redis.应用于定时任务执行顺序管理或任务过期管理<br>15、redis,应用于及时任务/消息队列执行管理<br>16、redis,应用于按次结算的服务控制<br>17、redis应用于基于时间顺序的数据操作，而不关注具体时间</p>
<h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><p>主要有5种：string，list，set，hash，zset</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607115932817.png" alt="image-20220607115932817"></p>
<h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</p>
<p>存储数据的格式：一个存储空间保存一个数据，与java的String类似</p>
<p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用(但是仍是字符串)</p>
<p>String是最常用的一种数据类型，普通的key/value存储都可以归为此类。一个Key对应一个Value，string类型是二进制安全的。</p>
<p>Redis的string可以包含任何数据，比如jpg图片(生成二进制)或者序列化的对象</p>
<p>常用Api</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> key <span class="keyword">value</span></span><br><span class="line">mset key1 value1 key2 value2 ..... </span><br><span class="line"><span class="keyword">get</span> key</span><br><span class="line">mget key1 key2 ...</span><br><span class="line">del key </span><br><span class="line">strlen key</span><br><span class="line">append key <span class="keyword">value</span> #有则追加，否则新建</span><br><span class="line">setnx key <span class="keyword">value</span>  #不存在才创建，否则失败</span><br><span class="line">setex key <span class="type">time</span> <span class="keyword">value</span> #设置值得同时设置过期时间</span><br><span class="line"><span class="keyword">set</span> key <span class="keyword">value</span> nx ex <span class="type">time</span>  </span><br><span class="line">incr key</span><br><span class="line">incrby key increment	#以步长增加</span><br><span class="line">decr key</span><br><span class="line">decrby key increment	#以步长减少</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h3><p>据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分<br>需要的存储数据：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p>
<p>list类型：保存多个数据，底层使用双向链表+压缩链表</p>
<p>常用Api</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 value2...</span><br><span class="line">rpush key value1 value2...</span><br><span class="line">lpop key </span><br><span class="line">lpop key</span><br><span class="line">lrange key stratindex endindex</span><br><span class="line">lindex key index	#查询第几个元素</span><br><span class="line">llen key	#获取长度</span><br><span class="line">blpop key timeout</span><br><span class="line">brpop key timeout</span><br><span class="line">#阻塞式获取，在规定时间内获取这个值，规定时间内如果还没有的时候可以等，直到有值就可以获取到获取超时获取为空。开两个客户端，一个设置<span class="number">15</span>s内获取list1中的值，此时list1位空一直等待(阻塞)，在<span class="number">15</span>秒内另一个客户端存入到list1中数据，此时就被获取到</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><p>String类型存储对象类数据的存储如果具有较为频繁的更新需求，操作会显得笨重，存容易，改麻烦。可以选择hash类型存储，每个hash类型的key对应一张表，为了区别与Redis中的键值对的称呼，hash中的键成为field，而key特征Redis的键。</p>
<p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息<br>需要的内存结构：一个存储空间保存多少个键值对数据<br>hash类型：底层使用哈希表与HashMap类似</p>
<p>常用APi</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hset key field1 value1 field2 value2 field3 value3</span><br><span class="line">hget key field</span><br><span class="line">hgetall key</span><br><span class="line">hkeys key #获得所有field的集合</span><br><span class="line">hvals key #获得所有<span class="keyword">value</span>的集合</span><br></pre></td></tr></table></figure>

<h4 id="hash类型数据操作的注意事项"><a href="#hash类型数据操作的注意事项" class="headerlink" title="hash类型数据操作的注意事项"></a>hash类型数据操作的注意事项</h4><p>hash类型下的value只能存储字符串，不允许存储其他类型数据，不存在嵌套现象。如果数据未获取到，对应的值为(nil)</p>
<p>每个hash可以存储232-1个键值对</p>
<p>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计不是为了存储大量对象的，切记不可滥用，更不可以将hash作为对象列表使用</p>
<p>hgetall操作可以获取全部属性，如果内部fiekd过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈。</p>
<h3 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h3><ul>
<li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p>
</li>
<li><p>需要的存储结构：能够保存大量的数据，搞笑的内部存储机制，便于查询</p>
</li>
<li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil)，并且值式不允许重复的。也就是只有键没有值的hash</p>
</li>
</ul>
<p>常用Api</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd key value1 value2 ...</span><br><span class="line">smembers key</span><br><span class="line">srem key value1 value2 ...</span><br><span class="line">scard key</span><br></pre></td></tr></table></figure>



<h3 id="zset类型"><a href="#zset类型" class="headerlink" title="zset类型"></a>zset类型</h3><ul>
<li>新的存储需求：根据排序有利于数据的有效显示，需要提供一种可以根据自身特征进行排序的方式。</li>
<li>需要的存储结构：新的存储模型，可以保存可排序的数据。</li>
<li>sorted_set类型：在set的存储结构基础上添加可排序字段。（添加一个分数，可以根据分数排名）</li>
</ul>
<p>常用Api</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 value1 score2 value2 score3 value3 ....</span><br><span class="line">zrange key <span class="keyword">start</span> stop [withscore]</span><br><span class="line">zrevrange key <span class="keyword">start</span> stop [withscore]</span><br><span class="line">zrem key <span class="keyword">value</span></span><br><span class="line">#查询scores在某个范围内的值</span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT]</span><br><span class="line">#查询key某个索引范围内的值</span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42923363/article/details/123199880">https://blog.csdn.net/weixin_42923363/article/details/123199880</a></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<pre><code> 1. 单位不区分大小写
 2. include &quot;./redis.conf&quot;可以引入配置文件
 3. bind 127.0.0.1 -::1表示只可本地访问 0.0.0.0表示谁都可以访问
 4. proteceed-mode 表示允不允许远程访问与上类似
 5. port修改监听端口
 6. tcp-backlog 在高并发环境下需要一个高backlog值避免慢客户端连接的问题
 7. daemonlize 表示是否后台启动
 8. pidfile当前进程号
 9. database设置使用的数据库
 10. requirepass设置密码
 11. maxclients最大连接数，默认1000，超出会拒绝
 12. maxmemory 必须设置否则服务器内存占满，服务器会宕机，一旦达到内存使用上限，redis将会视图移除内部数据，移除规则可以通过maxmemory-policy来指定
</code></pre>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607132056492.png" alt="image-20220607132056492"></p>
</blockquote>
<p>可以在客户端中通过命令<code>config set key value</code>设置但是设置不会持久化重启就消失，如果需要持久化可以通过save实现</p>
<h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>订阅<code>subscribe channel </code></p>
<p>发布<code>publish channel message</code></p>
<p> 注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息。（只能在订阅的频道收到消息，没有订阅的频道收不到任何消息），可以订阅多个channel，</p>
<p>应用场景</p>
<p>1、构建实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p>2、微信的公共号订阅消息推送等</p>
<h2 id="整合Springboot"><a href="#整合Springboot" class="headerlink" title="整合Springboot"></a>整合Springboot</h2><p>redis的常用客户端有jedis与lettuce，在springboot2.2版本后默认是lettuce，如果不想用可以在redis依赖中排除lettuce</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h3><blockquote>
<p>Jedis是同步的，不支持异步，Jedis客户端实例不是线程安全的，需要每个线程一个Jedis实例，所以一般通过连接池来使用Jedis.</p>
<p>优点：</p>
<p>提供了比较全面的 Redis 操作特性的 APIAPI 基本与 Redis 的指令一一对应，使用简单易理解</p>
<p>缺点：</p>
<p>同步阻塞 IO,不支持异步,线程不安全</p>
</blockquote>
<h4 id="jedis单机使用"><a href="#jedis单机使用" class="headerlink" title="jedis单机使用"></a>jedis单机使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;124.223.84.201&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;xxxxxxx&quot;</span>);<span class="comment">//如果有密码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 操作</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">jedis.close();</span><br><span class="line">然后通过jedis操作redis</span><br></pre></td></tr></table></figure>

<p>可以在配置文件中配置连接</p>
<h4 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h4><p>jedis连接池一般都是单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">JedisPoolFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (JedisPoolFactory.class)&#123;</span><br><span class="line">				<span class="keyword">if</span> (jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">					JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">					config.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">					config.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">					config.setMaxWaitMillis(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">					config.setBlockWhenExhausted(<span class="keyword">true</span>);</span><br><span class="line">					config.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">					jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">&quot;124.223.84.201&quot;</span>,<span class="number">6379</span>,<span class="number">6000</span>,<span class="string">&quot;gxy261023&quot;</span>);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> jedisPool;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用法</span></span><br><span class="line">JedisPool jedisPool = JedisPoolFactory.getJedisPool();</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">jedis.lpush(<span class="string">&quot;workder&quot;</span>,<span class="string">&quot;xiaoli&quot;</span>,<span class="string">&quot;xiaohone&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">jedis.rpush(<span class="string">&quot;sttudd&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>,<span class="string">&quot;ccccc&quot;</span>&#125;);</span><br><span class="line">String gxy = jedis.get(<span class="string">&quot;gxy&quot;</span>);</span><br><span class="line">System.out.println(gxy);</span><br><span class="line">jedis.close();</span><br><span class="line">jedisPool.close();</span><br></pre></td></tr></table></figure>





<h3 id="lettuce"><a href="#lettuce" class="headerlink" title="lettuce"></a>lettuce</h3><blockquote>
<p>Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的，Lettuce的API也是线程安全的，所以多个线程可以操作单个Lettuce连接来完成各种操作，同时Lettuce也支持连接池.</p>
<p>优点：</p>
<p>线程安全<br>基于 Netty 框架的事件驱动的通信，可异步调用<br>适用于分布式缓存</p>
<p>缺点：</p>
<p>API 更抽象，学习使用成本高</p>
</blockquote>
<h4 id="lettuce单机使用"><a href="#lettuce单机使用" class="headerlink" title="lettuce单机使用"></a>lettuce单机使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建uri</span></span><br><span class="line">RedisURI uri = RedisURI.Builder.redis(<span class="string">&quot;124.223.84.201&quot;</span>,<span class="number">6379</span>).withPassword(<span class="string">&quot;gxy261023&quot;</span>).build();</span><br><span class="line"><span class="comment">//2.创建客户端</span></span><br><span class="line">RedisClient redisClient = RedisClient.create(uri);</span><br><span class="line"><span class="comment">//3.通过客户端进行连接</span></span><br><span class="line">StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.1异步命令</span></span><br><span class="line">RedisAsyncCommands&lt;String, String&gt; async = connect.async();</span><br><span class="line">async.set(<span class="string">&quot;springboot&quot;</span>,<span class="string">&quot;hello redis&quot;</span>);</span><br><span class="line">RedisFuture&lt;String&gt; gxy = async.get(<span class="string">&quot;gxy&quot;</span>);</span><br><span class="line"><span class="comment">//get方法会阻塞直至有结果，除非设置超时</span></span><br><span class="line">System.out.println(gxy.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2同步命令</span></span><br><span class="line">RedisCommands&lt;String, String&gt; sync = connect.sync();</span><br><span class="line">String a = sync.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line"></span><br><span class="line">redisClient.shutdown();</span><br></pre></td></tr></table></figure>

<p>可以在配置文件中配置连接</p>
<h4 id="lettuce连接池"><a href="#lettuce连接池" class="headerlink" title="lettuce连接池"></a>lettuce连接池</h4><p>　我们在服务器开发的过程中，往往会有一些对象，它的创建和初始化需要的时间比较长，比如数据库连接，网络IO，大数据对象等。在大量使用这些对象时，如果不采用一些技术优化，就会造成一些不可忽略的性能影响。一种办法就是使用对象池，每次创建的对象并不实际销毁，而是缓存在对象池中，下次使用的时候，不用再重新创建，直接从对象池的缓存中取即可。为了避免重新造轮子，我们可以使用优秀的开源对象池化组件apache-commons-pool2，它对对象池化操作进行了很好的封装，我们只需要根据自己的业务需求重写或实现部分接口即可，使用它可以快速的创建一个方便，简单，强大对象连接池管理类</p>
<p>lettuce连接池需要commons-pool2依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建uri</span></span><br><span class="line">RedisURI uri = RedisURI.Builder.redis(<span class="string">&quot;124.223.84.201&quot;</span>,<span class="number">6379</span>).withPassword(<span class="string">&quot;gxy261023&quot;</span>).build();</span><br><span class="line"><span class="comment">//2.创建客户端</span></span><br><span class="line">RedisClient client = RedisClient.create(uri);</span><br><span class="line"><span class="comment">//3.配置连接</span></span><br><span class="line">GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig&lt;&gt;();</span><br><span class="line">config.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">20</span>);</span><br><span class="line">config.setMinIdle(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//4.通过工具类生成连接池</span></span><br><span class="line">GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; pool = ConnectionPoolSupport.createGenericObjectPool(client::connect, config);</span><br><span class="line">StatefulRedisConnection&lt;String, String&gt; connection = pool.borrowObject();</span><br><span class="line">RedisAsyncCommands&lt;String, String&gt; asyncCommands = connection.async();</span><br><span class="line">asyncCommands.multi();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行原子操作</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">asyncCommands.exec();</span><br><span class="line"><span class="comment">//5.归还连接</span></span><br><span class="line">pool.returnObject(connection);</span><br><span class="line">pool.close();</span><br><span class="line">client.shutdown();</span><br></pre></td></tr></table></figure>





<h4 id="集群使用"><a href="#集群使用" class="headerlink" title="集群使用"></a>集群使用</h4><blockquote>
<p>只需要把RedisClient换成RedisClusterClient</p>
<p>RedisClusterClient clusterClient = RedisClusterClient.create(uri);</p>
</blockquote>
<p>springboot包装好了客户端给我们使用（StringRedisTemplate与RedisTemplate），就效率而言jedis比RedisTemplate快,如果需要使用</p>
<h2 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h2><p>​    下次重新开机后redis会将保存的数据恢复到内存中</p>
<p>​    两种持久化方案既可以同时使用(of),又可以单独使用，在某种情况下也可以都不使用，具体使用那种持久化方案取决于用户的数据和应用决定。无论使用AOF还是快照机制持久化，将数据持久化到硬盘都是有必要的，除了持久化外，用户还应该对持久化的文件进行备份<br>最好备份在多个不同地方)。</p>
<p>​    相同的数据量下,rdb 文件要小于 aof 文件,且恢复速度要快于 aof</p>
<h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这种方式可以将某一时刻所有的数据都写入硬盘中，当然这也是redis的默认开启的持久化方式，保存的文件以.rdb形式结尾，因此这种方式也称为RDB方式</p>
<h4 id="生成方式"><a href="#生成方式" class="headerlink" title="生成方式"></a>生成方式</h4><ul>
<li>客户端方式：SAVE和BGSAVE</li>
<li>服务端配置自动触发</li>
</ul>
<h5 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h5><p>客户端可以使用BGSAVE命令来创建一个快照，当接收到客户端的BGSAVE命令时，redis会调用fork来创建一个子进程，然后子进程负<br>责将快照写入磁盘中，而父进程则继续处理命令请求。<br>“名词解释：fork一个进程创建子进程的时候，底层的操作系统会创建该进程的一个副本，在linux系统中创建子进程的操作会进行优<br>化：在刚开始的时候，父子进程共享相同内存，直到父进程或子进程对内存进行了写之后，对被写入的内存的共享才会结束服务</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607163714604.png" alt="image-20220607163714604"></p>
<p>写时复制（COW）</p>
<p>Redis借助了linux系统的写时复制（Copy-On-Write）技术，在生成快照的同时，仍然可以接收命令处理数据。简单来说，bgsave线程是由主线程fork生成的子线程，可以共享主线程所有的内存数据。bgsave线程运行后，开始读取主线程的内存数据，也就是redis的内存数据，将内存数据写入到dump.rdb文件中。此时，如果主线程处理的命令都是读操作，则bgsave线程不受影响。如果主线程处理了写操作，则会对该命令操作的数据复制一份，生成副本，bgsave线程会把这个副本写入到dump.rdb文件中，而在这个过程中，主线程仍可执行命令。</p>
<h5 id="SAVE（不推荐）"><a href="#SAVE（不推荐）" class="headerlink" title="SAVE（不推荐）"></a>SAVE（不推荐）</h5><p>在快照生成完成之前不会再响应其他的命令</p>
<p><img src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20220607163727221.png" alt="image-20220607163727221"></p>
<p>对比</p>
<table>
<thead>
<tr>
<th></th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞其他命令</td>
<td>是</td>
<td>否（fork会短暂阻塞）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞操作</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞操作</td>
<td>会消耗额外内存</td>
</tr>
</tbody></table>
<h5 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h5><p>在配置文件中配置了<code>SAVE n m</code>(表示在n秒内至少m条记录发生变化    )后,达到任意一条SAVE的要求后会自动执行一次<code>bgsave</code></p>
<h5 id="客户端shutdown"><a href="#客户端shutdown" class="headerlink" title="客户端shutdown"></a>客户端shutdown</h5><p>当redis通过shutdown指令关闭服务器时，会执行一个save命令，阻塞所有的客户端，不再执行客户端发送的任何命令，并且在<code>save</code>命令后关闭服务器</p>
<h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><ul>
<li><p>修改dbfilename修改生成的文件名字</p>
</li>
<li><p>修改dir修改生成文件的路径</p>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>缺点：</p>
<ol>
<li>RDB每次持久化需要将所有内存数据写入文件，然后替换原有文件，当内存数据量很大的时候，频繁的生成快照会很耗性能。</li>
<li>如果将生成快照的策略设置的时间间隔很大，会导致redis宕机的时候丢失过的的数据。也就是最后一次快照后的数据</li>
</ol>
<p>优点：<br>由于dump.rdb文件是二进制文件，所以当redis服务崩溃恢复的时候，能很快的将文件数据恢复到内存之中。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中，AOF持久化会将被执行的写命令写到AOF的文件末尾，以此来记录数据发生的变化，因此只要redis从头到为执行一次AOF文件所报好的所有写命令，就可以恢复AOF文件的记录的数据。默认不开启，通过修改配置文件的appendonly为yes</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220607174338373.png" alt="image-20220607174338373"></p>
<h4 id="追加频率"><a href="#追加频率" class="headerlink" title="追加频率"></a>追加频率</h4><p>通过修改配置文件的appendsync设置</p>
<p>1。always【谨慎使用】</p>
<ul>
<li><p>说明：每个redis写命令都要同步写入硬盘，严重降低redis速度</p>
</li>
<li><p>解释：如果用户使用了always选项，那么每个redis2写命令都会被写入硬盘，从而将发生系统崩溃时出现的数据丢失减到最少；遗憾的<br>是，因为这种同步策略需要对硬盘进行大量的写入操作，所以rdis处理命令的速度会受到硬盘性能的限制；<br>-注意：转盘式硬盘在这种频率下200左右个命令/s;固态硬盘(SSD)几百万个命令/s;<br>-警告：使用SSD用户请谨慎使用always选项，这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题，导致将固态硬盘的<br>寿命从原来的几年降低为几个月。</p>
</li>
</ul>
<p>2.everysec【推荐】</p>
<ul>
<li><p>说明：每秒执行一次同步显式的将多个写命令同步到磁盘</p>
</li>
<li><p>解释：为了兼顾数据安全和写入性能，用户可以考虑使用everysec选项，让redis每秒一次的频率对AOF文件进行同步；redis每秒同<br>步一次A0F文件时性能和不使用任何持久化特性时的性能相差无几，而通过每秒同步一次AOF文件，redis可以保证，即使系统崩溃，用户最<br>多丢失一秒之内产生的数据。</p>
</li>
</ul>
<p>3.no【不推荐】</p>
<ul>
<li>说明：由操作系统决定何时同步</li>
<li>解释：最后使用no选项，将完全有操作系统决定什么时候同步AOF日志文件，这个选项不会对redis性能带来影响但是系统崩溃时，会丢<br>失不定数量的数据，另外如果用户硬盘处理写入操作不够快的话，当缓冲区被等待写入硬盘数据填满时，rd1s会处于阻塞状态，并导致<br>redis的处理命令请求的速度变慢。</li>
</ul>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr testi命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test100就够了。为了压缩aof的持久化文件Redis提供了AOF重写机制。</p>
<p>AOF重写一定程度上减少了AOF文件的大小</p>
<p>触发重写的方式 ::first_quarter_moon:</p>
<blockquote>
<ol>
<li>客户端方式重写，执行BGREWRITEAOF命令，不会阻塞Redis的服务</li>
<li>服务端配置自动触发</li>
</ol>
<p>在redis.conf中配置auto-aof-rewrite-percentage</p>
<p>如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64MB,并且启用的A0F持久化时，那么当A0F<br>文件体积大于64M,并且A0F文件的体积比上一次重写之后体积大了至少一倍(100%)时，会自动触发，如果重写过于频繁，用户可以考虑将<br>auto-aof-rewrite-percentage设置为更大</p>
</blockquote>
<p><strong>重写原理</strong></p>
<pre><code>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，替换原有的文件这点和快照有点类似。
</code></pre>
<p>重写流程<br>1.redis调用fork，现在有父子两个进程，子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令<br>2,父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写<br>失败的话并不会出问题。<br>3，当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。<br>4.现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</p>
<p>当aof文件过大时，删除会占用较高资源</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220608201645761.png" alt="image-20220608201645761"></p>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>​    如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</p>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>缓存的概念：</p>
<p>​    在服务端中，缓存主要是指将数据库的数据加载到内存中，之后对该数据的访问都在内存中完成，从而减少了对数据库的访问；解决了高并发场景中数据库容易成为性能瓶颈的问题；以及基于内存的访问速度高于磁盘的访问速度的原理，提高了数据的访问速度和程序性能。<br>而根据缓存是否与应用程序属于同一进程，可以将内存分为本地缓存和分布式缓存。</p>
<p>​    本地缓存是在同一个进程内的内存空间中缓存数据，数据读写都是在同一个进程内完成；</p>
<p>​    缺点：</p>
<ul>
<li><p>占用了应用程序的空间比如JVM，无法进行大数据量缓存</p>
</li>
<li><p>本地缓存无法被其他应用程序访问，在集群中需要同步更新较为复杂（比如nginx负载均衡会打到不同主机）</p>
</li>
<li><p>重启数据丢失</p>
</li>
</ul>
<p>​    分布式缓存是一个独立部署的进程，一般都是与应用进程部署在不同的机器，需要通过网络来完成分布式缓存的数据读写操作的数据传输。</p>
<p>​    优点：</p>
<ul>
<li>支持大量数据存储，不影响应用进程。重启不丢失数据</li>
<li>数据集中存储，保证了数据的一致性</li>
<li>数据读写分离，高性能，高可用，避免了因为宕机而数据不可用的问题</li>
<li>需要网络传输，性能略低</li>
</ul>
<p>Redis与Mybatis整合实现分布式缓存，</p>
<p>Mybatis一级缓存作用域为sqlsession，不同sqlsession无法共享缓存，一般需要开启二级缓存，二级缓存的作用域为sqlsessionfactory，同一个工厂下的sqlsession的缓存能够共享。</p>
<p>Mybatis开启缓存为在mapper文件中添加<cache/>标签，其中cache的默认实现类是PerpetualCache类，实现类ibatis下的Cache接口，</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609081252242.png" alt="image-20220609081252242"></p>
<p>底层的数据结构为Hashmap，无法用于分布式环境，因此可以通过修改实现类（在cache标签中添加type属性，值为缓存实现类的全限定名），可以结合redis实现分布式缓存。底层调用的仍然是redis的Hashmap</p>
<blockquote>
<ol>
<li><p>先自定义类实现Cache接口</p>
</li>
<li><p>添加id成员变量并编写构造函数和getId方法</p>
<p>id其实是对应mapper文件的namespace比如com.gan.dao.UserDao,相当于redis的hash存储的key，每次查询时会以namespace+当前方法名+执行的sql语句整体作为field（由于这个整体过于冗长，可以取其md5代之）value为查询得到的数据结果    </p>
</li>
<li><p>重写cache的get和put方法，通过工具类获得的redistemplate对hash结构进行put和get完成缓存的存取功能</p>
</li>
<li><p>增删改需要清除对应的缓存（java会自动调用clear方法），因此需要重写clear方法直接清除id也就是UserDao，那么下次调用相关Dao时没有缓存只能到数据库去获取</p>
</li>
</ol>
</blockquote>
<p>在上面的缓存中，如果项目中表查询之间没有任何关联查询使用现在的这种缓存方式没有任何问题，但如果表之间有关联则存在一定存在问题？</p>
<p>因为不同的Dao在增删改时只能删除自己的缓存，不能操作其他Dao对应的缓存</p>
<p>为了解决这个问题可以将多个有关系的Dao放在同一个id下一起管理，起到牵一发而动全身的效果。</p>
<p>实现方法通过cache-ref，指向有关联的dao</p>
<p><code>&lt;cache type=&quot;com.gan.util.RedisCache&quot;/&gt;</code></p>
<p><code>&lt;cache-ref namespace=&quot;com.gan.dao.TeacherDao&quot;/&gt;</code></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>主从复制架构仅仅用来解决数据的冗余备份，从节点基金用来同步数据。主节点用于写，从节点用于读</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609093731061.png" alt="image-20220609093731061"></p>
<p>可以在配置文件中slaveof 也可以在客户端中slaveof</p>
<p>客户端执行info replication查看主从信息</p>
<h3 id="主从复制特性"><a href="#主从复制特性" class="headerlink" title="主从复制特性"></a>主从复制特性</h3><h4 id="一主两仆"><a href="#一主两仆" class="headerlink" title="一主两仆"></a>一主两仆</h4><p>如果从服务器突然断开，并且设置从服务器是在命令行的（也就是一次性的，配置文件设置的不是一次性的）那么他会恢复主服务器的身份。最好是在配置文件中配置从服务器，更加稳定。</p>
<p>从服务器断开连接重连后，会将主服务器的数据全部复制</p>
<p>主服务器断开连接后，从服务器不会篡位，会等待大哥回归</p>
<p>复制原理</p>
<ul>
<li><p>Slave启动成功连接到master后会发送一个sync命令（主动）</p>
</li>
<li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步（底层通过rdb文件传输）</p>
<p>全量复制：而slve服务在接收到数据库文件数据后，将其存盘并加载到内存中。·<br>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步，<br>但是只要是重新连接master,一次完全同步（全量复制将被自动执行）</p>
</li>
</ul>
<h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>上一个Slave可以是下一个slave的Master,</p>
<p>Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力，去中心化降低风险。 用slaveof <ip> <port></p>
<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的，风险是一旦某个slave宕机，后面的slave都没法备份</p>
<h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>通过slave no one 可以使得从机变主机，需要手动不方便，因此引出了哨兵机制</p>
<h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>Sentinel(哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，<br>以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级<br>为新的主服务器。简单的说哨兵就是带有自动故障转移功能的主从架构。</p>
<p><strong>1.无法解决单节点并发压力问题 2.单节点内存和磁盘的物理上限</strong></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609112029276.png" alt="image-20220609112029276"></p>
<p>搭建过程</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在主节点上创建哨兵配置</span></span><br><span class="line"><span class="bullet">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字固定</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span></span><br><span class="line"><span class="bullet">-</span> sentinel monitor 被监控的数据库名(自己起) ip port 2</span><br><span class="line"> 说明：后面的数字2，是指有两个及以上的sentinel服务检测大搜master宕机才会执行主从切换的功能，通常是哨兵数/2 +1（也就是半数以上）</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.启动哨兵模式并进行测试</span></span><br><span class="line"><span class="bullet">-</span> redis-sentinel /myredis/sentinel.conf(相当于一个独立的redis服务)</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>通过springboot操作redis哨兵,根据哨兵获得master节点</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在配置文件中配置</span></span><br><span class="line">spring.redis.sentinel.master =  在sentinel配置文件中配置的名字</span><br><span class="line">spring.redis.sentinel.nodes = ip:port,ip:port...</span><br></pre></td></tr></table></figure>









<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>容量不够，redis如何进行扩容？</li>
<li>并发写操作， redis如何分摊？<br> <strong>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</strong><br> 之前通过<code>代理主机</code>来解决，但是redis3.0中提供了解决方案。就是<code>无中心化集群配置</code>。</li>
</ul>
<h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。（slot的引入对数据进行分配）<br>Redis集群通过分区（partition)来提供一定程度的可用性（availability):即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</p>
</blockquote>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>搭建集群至少需要6台redis服务器，3主3从，一共节点，分布式中建议节点的数量为单数，这样投票时更容易做出决策</p>
<p>步骤：</p>
<ol>
<li>生成6个文件夹，不同文件夹放置不同服务器的配置文件</li>
<li>修改配置如下</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.daemonize yes</span></span><br><span class="line"><span class="bullet">-</span> 开启后台启动</span><br><span class="line"><span class="section"># 2.bind 0.0.0.0</span></span><br><span class="line"><span class="bullet">-</span> 设置可以远程访问</span><br><span class="line"><span class="section"># 3.port 6379</span></span><br><span class="line"><span class="bullet">-</span> 端口号</span><br><span class="line"><span class="section"># 4.appendonly yes</span></span><br><span class="line"><span class="bullet">-</span> 开启AOF持久化</span><br><span class="line"><span class="section"># 5.cluster-enabled yes</span></span><br><span class="line"><span class="bullet">-</span> 开启集群</span><br><span class="line"><span class="section"># 6.cluster-config-file nodes-xxxx.conf</span></span><br><span class="line"><span class="bullet">-</span> 集群配置文件</span><br><span class="line"><span class="section"># 7.cluster-node-timeout 5000</span></span><br><span class="line"><span class="bullet">-</span> 心跳等待时间，超过这个时间就开始投票选举新主节点</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>启动6台服务</li>
<li>通过自带的ruby命令生成集群,在redis目录下的src文件的redis-trib.rb</li>
</ol>
<p><code>./redis-trib.rb create --replicas 1 192.168.1.100:7000 192.168.1.100:7001 .....</code> 把六个服务全写上去</p>
<p>其中1表示每台主机有多少台从机，1是最简单的方式。</p>
<p>命令结束后看到 <strong>[OK] ALL 16384 slots covered</strong> 表示成功生成集群</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609150836867.png" alt="image-20220609150836867"></p>
<h3 id="集群常用命令"><a href="#集群常用命令" class="headerlink" title="集群常用命令"></a>集群常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看某个主机的当前状态</span></span><br><span class="line">./redis-trib.rb check ip:port</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609151616222.png" alt="image-20220609151616222"></p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609151917794.png" alt="image-20220609151917794"></p>
<h3 id="集群细节"><a href="#集群细节" class="headerlink" title="集群细节"></a>集群细节</h3><ul>
<li><p>主节点存在hash slots，且不能被删除，一主可以有多从，不同节点存储的是不一样的数据，主节点宕机时，经过设定好的超时时间后，从节点自动选举出新的主节点，此时就算之前的主节点重新连接回来也只能当从节点</p>
</li>
<li><p>从节点没有hash slots,可以被删除，只负责数据的同步与读</p>
</li>
</ul>
<p>客户端连接集群需要添加-c,表示是集群，至于连接集群的哪一台主机都是可以的，集群会根据crc16(key)算法获得key所在槽，并将你操作重定向到该槽所在的主机上</p>
<p><code>./redis-cli ip -p port -c</code> </p>
<h3 id="整合springboot"><a href="#整合springboot" class="headerlink" title="整合springboot"></a>整合springboot</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">		<span class="attr">cluster:</span></span><br><span class="line">			<span class="attr">nodes:</span> <span class="string">ip1:port1,ip2:port2....</span></span><br><span class="line"><span class="comment"># 最好把集群的节点全部写上去，如果只写一台，恰巧他又宕机了那么就无法连接</span></span><br></pre></td></tr></table></figure>



<h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p><strong>背景：</strong></p>
<p>​    原来使用hash取模算法，假设有3台服务器s0，s1,s2,对要存储的值进行计算hash然后求余3，将文件均匀分别划分到3台服务器上。这样拓展性较低，如果需要增加一台服务器s3，那么需要计算hash求余4，原来在s0的文件被计算到s3上，明显不对。大量缓存失效会引起缓存雪崩。</p>
<p>一致性哈希算法将服务器放在环上，将计算得到的结果放在环上，顺时针寻找最近的服务器。这种做法只会使得一部分缓存失效（也就是s2服务器到s3服务器这一段），极大减轻了数据库的压力</p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609162606965.png" alt="image-20220609162606965"></p>
<p>但是以上所说的前提是节点均匀地在环上，实际上会有哈希环偏斜的问题，那么很多键会缓存到同一台服务器上，压力过大可能引起系统崩溃</p>
<blockquote>
<p>解决方案：</p>
<ul>
<li><p>尽可能使用较多的服务器</p>
</li>
<li><p>将物理节点映射出虚拟节点，再将虚拟节点投射到哈希环，使得缓存均匀分配，减少哈希环偏斜带来的影响</p>
</li>
</ul>
<p>缓存读写-&gt;虚拟节点-&gt;真实节点  最后才读取</p>
</blockquote>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609162849629.png" alt="image-20220609162849629"></p>
<h4 id="槽-slot"><a href="#槽-slot" class="headerlink" title="槽(slot)"></a>槽(slot)</h4><p>  Redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为<strong>16384</strong>个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理至少1个或最多16384个。一个节点相当与一台主机。因此一个集群中最多可以有16384台主机，每个主机只少一个槽。</p>
<p>​                    <strong>只有当数据库中的16384个槽都有节点在处理时，集群才处于上线状态。</strong></p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609153138567.png" alt="image-20220609153138567"></p>
<p><img src="https://testmybuck.oss-cn-beijing.aliyuncs.com/img/image-20220609153341131.png" alt="image-20220609153341131"></p>
<p>也就是不同的数据会交到不同的槽处理，新添加的节点还没有划分槽，可以以下方法重新分片</p>
<ul>
<li><p><code>redis-cli -h 192.168.11.176 -p 7000 --cluster reshard 192.168.11.229:7006 -a 123456</code></p>
</li>
<li><p><code>./redis-trib.rb reshard ip:port</code></p>
</li>
</ul>
<p>集群的ping-pong心跳机制保证了高可用性    </p>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><table>
<thead>
<tr>
<th>缓存异常</th>
<th>产生原因</th>
<th>应对方案</th>
</tr>
</thead>
<tbody><tr>
<td>缓存雪崩</td>
<td>大量数据同时过期</td>
<td>1.均匀设置过期时间，避免同一时间过期<br />2.互斥锁，保证同一时间只有一个应用构建缓存<br />3.双key策略，主key设置过期时间，备key永不过时，主过期返回备</td>
</tr>
<tr>
<td></td>
<td>Redis故障宕机</td>
<td>1.服务熔断<br />2.请求限流<br />3.构建Redis缓存高可靠集群</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>频繁访问的热点数据过期</td>
<td>1.互斥锁<br />2.热点数据永不过期，后台更新缓存</td>
</tr>
<tr>
<td>缓存穿透</td>
<td>访问的数据不在缓存也不在数据库（黑客）</td>
<td>1.限制非法请求<br />2.缓存空值（redis+mybatis会自动缓存）<br />3.布隆过滤器</td>
</tr>
</tbody></table>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/p/65034/" rel="prev" title="AQS详解">
                  <i class="fa fa-chevron-left"></i> AQS详解
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AGA</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





</body>
</html>
